This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.mcp.json
components.json
eslint.config.mjs
lepac.db
next.config.ts
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/pdf.worker.min.mjs
public/vercel.svg
public/window.svg
README.md
src/app/actions/uploadFile.ts
src/app/api/auth/[...nextauth]/route.ts
src/app/api/calendar/events/[id]/route.ts
src/app/api/calendar/events/route.ts
src/app/api/calendar/ical/route.ts
src/app/api/dashboard/route.ts
src/app/api/feedbacks/[id]/like/route.ts
src/app/api/feedbacks/[id]/route.ts
src/app/api/feedbacks/route.ts
src/app/api/meetings/[id]/route.ts
src/app/api/meetings/route.ts
src/app/api/projects/[id]/comments/route.ts
src/app/api/projects/[id]/construction-photos/[photoId]/route.ts
src/app/api/projects/[id]/construction-photos/route.ts
src/app/api/projects/[id]/construction-progress/route.ts
src/app/api/projects/[id]/files/[fileId]/download/route.ts
src/app/api/projects/[id]/files/[fileId]/preview/route.ts
src/app/api/projects/[id]/files/[fileId]/route.ts
src/app/api/projects/[id]/files/route.ts
src/app/api/projects/[id]/progress/generate/route.ts
src/app/api/projects/[id]/progress/route.ts
src/app/api/projects/[id]/route.ts
src/app/api/projects/[id]/todos/route.ts
src/app/api/projects/route.ts
src/app/api/register-initial-user/route.ts
src/app/api/search/route.ts
src/app/api/todos/[id]/route.ts
src/app/api/todos/route.ts
src/app/calendar/page.tsx
src/app/favicon.ico
src/app/feedbacks/page.tsx
src/app/globals.css
src/app/layout.tsx
src/app/legal/page.tsx
src/app/login/page.tsx
src/app/map/page.tsx
src/app/meetings/[id]/MeetingMinutesSection.tsx
src/app/meetings/[id]/page.tsx
src/app/meetings/MeetingsView.tsx
src/app/meetings/page.tsx
src/app/page.tsx
src/app/projects/[id]/page.tsx
src/app/projects/page.tsx
src/app/projects/ProjectsView.tsx
src/app/schedule/page.tsx
src/app/todo/page.tsx
src/app/todos/page.tsx
src/app/todos/TimelineView.tsx
src/app/todos/TodosView.tsx
src/app/tools/filename/page.tsx
src/app/tools/mail/page.tsx
src/app/tools/page.tsx
src/auth.config.ts
src/auth.ts
src/components/ContactDeptAlertCard.tsx
src/components/DeleteConfirmDialog.tsx
src/components/FeedbackInput.tsx
src/components/FullCalendarView.tsx
src/components/GeoSearchView.tsx
src/components/Header.tsx
src/components/HomeProjectSearch.tsx
src/components/HomeSearchView.tsx
src/components/HomeTodosView.tsx
src/components/icons/AlanIcon.tsx
src/components/LawAlertCard.tsx
src/components/PDFThumbnail.tsx
src/components/ProjectFiles.tsx
src/components/SessionProvider.tsx
src/components/SideNav.tsx
src/components/ThemeProvider.tsx
src/components/ThemeToggle.tsx
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/dialog.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/popover.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/db/index.ts
src/db/schema.ts
src/lib/address.ts
src/lib/coordinates.ts
src/lib/supabase.ts
src/lib/timeline.ts
src/lib/utils.ts
src/middleware.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".mcp.json">
{
  "mcpServers": {
    "repomix": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y",
        "repomix",
        "--mcp"
      ],
      "env": {}
    }
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="src/app/actions/uploadFile.ts">
"use server";

import { db } from "@/db";
import { projectFiles } from "@/db/schema";
import { supabaseAdmin, STORAGE_BUCKET } from "@/lib/supabase";

export async function uploadFile(formData: FormData) {
  const file = formData.get("file") as File | null;
  const projectIdStr = formData.get("projectId") as string | null;
  const category = (formData.get("category") as string | null) || "other";

  if (!file || !projectIdStr) {
    return { error: "Missing file or projectId" };
  }

  const projectId = Number(projectIdStr);
  if (isNaN(projectId)) {
    return { error: "Invalid project ID" };
  }

  // カテゴリのバリデーション
  const allowedCategories = ["registry_copy", "cadastral_map", "drawing", "consent_form", "other"];
  if (!allowedCategories.includes(category)) {
    return { error: "Invalid category" };
  }

  // ファイルタイプのバリデーション
  const allowedTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "application/pdf",
  ];

  if (!allowedTypes.includes(file.type)) {
    return { error: "File type not allowed. Allowed: JPG, PNG, GIF, WebP, PDF" };
  }

  // ファイルサイズ制限（10MB）
  const maxSize = 10 * 1024 * 1024;
  if (file.size > maxSize) {
    return { error: "File too large. Maximum size is 10MB" };
  }

  try {
    // ファイルパスを生成（プロジェクトID/タイムスタンプ-ファイル名）
    const timestamp = Date.now();
    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, "_");
    const filePath = `projects/${projectId}/${timestamp}-${safeName}`;

    console.log("Upload - file.name:", file.name);
    console.log("Upload - file.size:", file.size);
    console.log("Upload - file.type:", file.type);

    // ファイルをバッファに変換（ストリームベースの読み込み）
    const chunks: Uint8Array[] = [];
    const stream = file.stream();
    const reader = stream.getReader();

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      if (value) chunks.push(value);
    }

    // 全チャンクを結合
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const buffer = Buffer.alloc(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      buffer.set(chunk, offset);
      offset += chunk.length;
    }

    console.log("Upload - buffer.length:", buffer.length);

    // Supabase Storageにアップロード
    const { data: uploadData, error: uploadError } = await supabaseAdmin.storage
      .from(STORAGE_BUCKET)
      .upload(filePath, buffer, {
        contentType: file.type,
        upsert: false,
      });

    if (uploadError) {
      console.error("Supabase upload error:", uploadError);
      return { error: `Upload failed: ${uploadError.message}` };
    }

    // 署名付きURLを生成（1年間有効）
    const { data: signedUrlData, error: signedUrlError } = await supabaseAdmin.storage
      .from(STORAGE_BUCKET)
      .createSignedUrl(filePath, 60 * 60 * 24 * 365); // 1年

    if (signedUrlError) {
      console.error("Signed URL error:", signedUrlError);
      return { error: `Failed to create signed URL: ${signedUrlError.message}` };
    }

    // DBに保存
    const [dbResult] = await db
      .insert(projectFiles)
      .values({
        projectId,
        fileName: file.name,
        fileUrl: signedUrlData.signedUrl,
        fileType: file.type,
        fileSize: file.size,
        category,
        createdAt: new Date().toISOString(),
      })
      .returning();

    return { success: true, file: dbResult };
  } catch (error) {
    console.error("File upload error:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return { error: `Failed to upload: ${errorMessage}` };
  }
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import { handlers } from "@/auth";
export const { GET, POST } = handlers;
</file>

<file path="src/app/api/calendar/events/[id]/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { calendarEvents } from "@/db/schema";
import { eq } from "drizzle-orm";

// カスタムイベントを削除
export async function DELETE(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // custom-123 形式からIDを抽出
    const eventId = id.startsWith("custom-") ? parseInt(id.replace("custom-", "")) : parseInt(id);

    if (isNaN(eventId)) {
      return NextResponse.json({ error: "無効なIDです" }, { status: 400 });
    }

    await db.delete(calendarEvents).where(eq(calendarEvents.id, eventId));

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("イベントの削除に失敗:", error);
    return NextResponse.json({ error: "イベントの削除に失敗しました" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/calendar/ical/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projects, progress } from "@/db/schema";
import { eq } from "drizzle-orm";

/**
 * iCal形式で未完了の予定をエクスポート
 * Notion CalendarやGoogleカレンダーで購読可能
 */
export async function GET() {
  // 全案件を取得
  const allProjects = await db.select().from(projects);
  
  // 全進捗を取得（未完了のみ）
  const allProgress = await db
    .select()
    .from(progress)
    .where(eq(progress.status, "planned"));

  // プロジェクトIDから管理番号へのマップを作成
  const projectMap = new Map(
    allProjects.map((p) => [p.id, p.managementNumber])
  );

  // iCalヘッダー
  const icalLines: string[] = [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//ALAN//ALAN Calendar//JA",
    "X-WR-CALNAME:ALAN",
    "X-WR-TIMEZONE:Asia/Tokyo",
    "CALSCALE:GREGORIAN",
    "METHOD:PUBLISH",
  ];

  // 各進捗をイベントとして追加
  for (const prog of allProgress) {
    const managementNumber = projectMap.get(prog.projectId) || "不明";
    const title = `${managementNumber} ${prog.title}`;
    
    // 日付をiCal形式に変換（YYYYMMDD）
    const dateStr = formatDateForICal(prog.createdAt);
    const nextDateStr = formatNextDateForICal(prog.createdAt);
    
    // イベントを追加
    icalLines.push("BEGIN:VEVENT");
    icalLines.push(`UID:progress-${prog.id}@alan`);
    icalLines.push(`DTSTAMP:${formatDateTimeForICal(new Date())}`);
    icalLines.push(`DTSTART;VALUE=DATE:${dateStr}`);
    icalLines.push(`DTEND;VALUE=DATE:${nextDateStr}`);
    icalLines.push(`SUMMARY:${escapeICalText(title)}`);
    if (prog.description) {
      icalLines.push(`DESCRIPTION:${escapeICalText(prog.description)}`);
    }
    icalLines.push("STATUS:TENTATIVE");
    icalLines.push("END:VEVENT");
  }

  // iCalフッター
  icalLines.push("END:VCALENDAR");

  // レスポンスを返す
  const icalContent = icalLines.join("\r\n");
  
  return new NextResponse(icalContent, {
    headers: {
      "Content-Type": "text/calendar; charset=utf-8",
      "Content-Disposition": "attachment; filename=alan-calendar.ics",
      "Cache-Control": "no-cache, no-store, must-revalidate",
    },
  });
}

/**
 * 日付文字列をiCal形式（YYYYMMDD）に変換
 */
function formatDateForICal(dateStr: string): string {
  const date = new Date(dateStr);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}${month}${day}`;
}

/**
 * 翌日の日付をiCal形式（YYYYMMDD）に変換（終日イベント用）
 */
function formatNextDateForICal(dateStr: string): string {
  const date = new Date(dateStr);
  date.setDate(date.getDate() + 1);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}${month}${day}`;
}

/**
 * 日時をiCal形式（YYYYMMDDTHHMMSSZ）に変換
 */
function formatDateTimeForICal(date: Date): string {
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, "0");
  const day = String(date.getUTCDate()).padStart(2, "0");
  const hours = String(date.getUTCHours()).padStart(2, "0");
  const minutes = String(date.getUTCMinutes()).padStart(2, "0");
  const seconds = String(date.getUTCSeconds()).padStart(2, "0");
  return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
}

/**
 * iCalテキストのエスケープ
 */
function escapeICalText(text: string): string {
  return text
    .replace(/\\/g, "\\\\")
    .replace(/;/g, "\\;")
    .replace(/,/g, "\\,")
    .replace(/\n/g, "\\n");
}
</file>

<file path="src/app/api/dashboard/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projects, progress, todos } from "@/db/schema";

export const dynamic = "force-dynamic";

// タイムラインと同じフェーズ定義
const PHASES = [
  "合意書", "案件提出", "現調", "土地売買契約", "土地契約",
  "法令申請", "法令許可", "電力申請", "電力回答", "SS依頼",
  "SS実施", "土地決済", "発注", "着工", "連系", "完工"
];

export async function GET() {
  const now = new Date();
  now.setHours(0, 0, 0, 0);
  const today = now.toISOString().split("T")[0];
  const weekFromNow = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString().split("T")[0];

  // 全データ取得
  const allProjects = await db.select().from(projects);
  const allProgress = await db.select().from(progress);
  const allTodos = await db.select().from(todos);

  // 1. 期日超過TODO（未完了で期日が今日より前）
  const overdueTodos = allTodos.filter((t) => {
    if (t.completedAt) return false;
    return t.dueDate < today;
  });

  // 2. 今日期日のTODO
  const todayTodos = allTodos.filter((t) => {
    if (t.completedAt) return false;
    return t.dueDate === today;
  });

  // 3. 今週期日のTODO（今日より後、1週間以内）
  const thisWeekTodos = allTodos.filter((t) => {
    if (t.completedAt) return false;
    return t.dueDate > today && t.dueDate <= weekFromNow;
  });

  // 4. 案件アラート（タイムラインと同じロジック）
  // 各フェーズで、完了していない場合:
  // - 期日未設定（progressがない、またはcreatedAtがない） → アラート
  // - 期日超過（未完了でcreatedAt < 今日） → アラート
  const projectsWithAlerts: { id: number; managementNumber: string; alertCount: number }[] = [];
  let totalAlertCount = 0;

  for (const project of allProjects) {
    const projectProgress = allProgress.filter((p) => p.projectId === project.id);
    let alertCount = 0;

    for (const phaseTitle of PHASES) {
      const phaseProgress = projectProgress.find((p) => p.title === phaseTitle);

      // 完了済みはスキップ（status === "completed" かつ completedAt がある場合のみ）
      if (phaseProgress?.status === "completed" && phaseProgress?.completedAt) continue;

      // 期日を取得（タイムラインと同じロジック）
      let phaseDate: Date | null = null;
      if (phaseProgress?.createdAt) {
        phaseDate = new Date(phaseProgress.createdAt);
      }

      // 期日未設定 → アラート
      if (!phaseDate) {
        alertCount++;
        continue;
      }

      // 期日超過（未完了でcreatedAt < 今日） → アラート
      phaseDate.setHours(0, 0, 0, 0);
      if (phaseDate < now) {
        alertCount++;
      }
    }

    if (alertCount > 0) {
      projectsWithAlerts.push({
        id: project.id,
        managementNumber: project.managementNumber,
        alertCount,
      });
      totalAlertCount += alertCount;
    }
  }

  // 5. 進行中案件（完工済みでない案件）
  const activeProjects = allProjects.filter((p) => {
    const projectProgress = allProgress.filter((prog) => prog.projectId === p.id);
    const completionProgress = projectProgress.find((prog) => prog.title === "完工");
    return !completionProgress || completionProgress.status !== "completed";
  });

  // 6. 最近追加された案件（idでソート、上位5件）
  const recentProjects = [...allProjects]
    .sort((a, b) => b.id - a.id)
    .slice(0, 5);

  // TODO詳細を案件情報付きで取得
  const enrichTodos = (todoList: typeof allTodos) => {
    return todoList.slice(0, 5).map((t) => {
      const project = allProjects.find((p) => p.id === t.projectId);
      return {
        id: t.id,
        content: t.content,
        dueDate: t.dueDate,
        projectId: t.projectId,
        managementNumber: project?.managementNumber || "不明",
      };
    });
  };

  return NextResponse.json({
    overdueTodos: {
      count: overdueTodos.length,
      items: enrichTodos(overdueTodos),
    },
    todayTodos: {
      count: todayTodos.length,
      items: enrichTodos(todayTodos),
    },
    thisWeekTodos: {
      count: thisWeekTodos.length,
      items: enrichTodos(thisWeekTodos),
    },
    projectAlerts: {
      count: projectsWithAlerts.length,
      totalAlerts: totalAlertCount,
      items: projectsWithAlerts.slice(0, 5),
    },
    activeProjects: {
      count: activeProjects.length,
      items: activeProjects.slice(0, 5).map((p) => ({
        id: p.id,
        managementNumber: p.managementNumber,
        client: p.client,
      })),
    },
    recentProjects: {
      items: recentProjects.map((p) => ({
        id: p.id,
        managementNumber: p.managementNumber,
        client: p.client,
      })),
    },
  });
}
</file>

<file path="src/app/api/feedbacks/[id]/like/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { feedbacks } from "@/db/schema";
import { eq, sql } from "drizzle-orm";

export const dynamic = "force-dynamic";

// いいねを追加
export async function POST(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const feedbackId = Number(id);

  if (isNaN(feedbackId)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  const [result] = await db
    .update(feedbacks)
    .set({
      likes: sql`${feedbacks.likes} + 1`,
    })
    .where(eq(feedbacks.id, feedbackId))
    .returning();

  return NextResponse.json(result);
}
</file>

<file path="src/app/api/feedbacks/[id]/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { feedbacks } from "@/db/schema";
import { eq } from "drizzle-orm";

export const dynamic = "force-dynamic";

// 要望取得
export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const feedbackId = Number(id);

  if (isNaN(feedbackId)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  const [feedback] = await db
    .select()
    .from(feedbacks)
    .where(eq(feedbacks.id, feedbackId));

  if (!feedback) {
    return NextResponse.json({ error: "Feedback not found" }, { status: 404 });
  }

  return NextResponse.json(feedback);
}

// 要望更新（ステータス、返信など）
export async function PUT(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const feedbackId = Number(id);

  if (isNaN(feedbackId)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  const body = await request.json();
  const { status, replies } = body;

  const updateData: Record<string, unknown> = {};
  if (status !== undefined) updateData.status = status;
  if (replies !== undefined) updateData.replies = replies;

  if (Object.keys(updateData).length === 0) {
    return NextResponse.json({ error: "No fields to update" }, { status: 400 });
  }

  const [result] = await db
    .update(feedbacks)
    .set(updateData)
    .where(eq(feedbacks.id, feedbackId))
    .returning();

  return NextResponse.json(result);
}

// 要望削除
export async function DELETE(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const feedbackId = Number(id);

  if (isNaN(feedbackId)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  await db.delete(feedbacks).where(eq(feedbacks.id, feedbackId));

  return NextResponse.json({ success: true });
}
</file>

<file path="src/app/api/meetings/route.ts">
import { NextResponse } from "next/server";
import { desc } from "drizzle-orm";
import { db } from "@/db";
import { meetings } from "@/db/schema";

export const dynamic = "force-dynamic";

export async function GET() {
  const list = await db.select().from(meetings).orderBy(desc(meetings.meetingDate));
  return NextResponse.json(list);
}

export async function POST(request: Request) {
  const body = await request.json();
  const [result] = await db
    .insert(meetings)
    .values({
      title: body.title ?? "",
      meetingDate: body.meetingDate ?? "",
      category: body.category ?? "社内",
      content: body.content ?? null,
      agenda: body.agenda ?? null,
    })
    .returning();
  return NextResponse.json(result);
}
</file>

<file path="src/app/api/projects/[id]/construction-photos/[photoId]/route.ts">
import { NextResponse } from "next/server";
import { del } from "@vercel/blob";
import { db } from "@/db";
import { constructionPhotos } from "@/db/schema";
import { eq, and } from "drizzle-orm";

export const dynamic = "force-dynamic";

// 工事写真削除
export async function DELETE(
  _request: Request,
  { params }: { params: Promise<{ id: string; photoId: string }> }
) {
  const { id, photoId } = await params;
  const projectId = Number(id);
  const photoIdNum = Number(photoId);

  if (isNaN(projectId) || isNaN(photoIdNum)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  try {
    // 写真情報を取得
    const [photo] = await db
      .select()
      .from(constructionPhotos)
      .where(
        and(
          eq(constructionPhotos.id, photoIdNum),
          eq(constructionPhotos.projectId, projectId)
        )
      )
      .limit(1);

    if (!photo) {
      return NextResponse.json({ error: "Photo not found" }, { status: 404 });
    }

    // Blobから削除
    const token = process.env.BLOB_READ_WRITE_TOKEN;
    if (token && photo.fileUrl) {
      try {
        await del(photo.fileUrl, { token });
      } catch (blobError) {
        console.error("Failed to delete from blob:", blobError);
      }
    }

    // DBから削除
    await db
      .delete(constructionPhotos)
      .where(eq(constructionPhotos.id, photoIdNum));

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Delete photo error:", error);
    return NextResponse.json(
      { error: "Failed to delete photo" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/projects/[id]/construction-photos/route.ts">
import { NextResponse } from "next/server";
import { put } from "@vercel/blob";
import { db } from "@/db";
import { constructionPhotos, CONSTRUCTION_PHOTO_CATEGORIES } from "@/db/schema";
import { eq, desc } from "drizzle-orm";

export const dynamic = "force-dynamic";

// 工事写真一覧取得
export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }

  const photos = await db
    .select()
    .from(constructionPhotos)
    .where(eq(constructionPhotos.projectId, projectId))
    .orderBy(desc(constructionPhotos.createdAt));

  return NextResponse.json(photos);
}

// 工事写真アップロード
export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File | null;
    const category = formData.get("category") as string | null;
    const contractorName = formData.get("contractorName") as string | null;
    const note = formData.get("note") as string | null;
    const takenAt = formData.get("takenAt") as string | null;

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    if (!category) {
      return NextResponse.json({ error: "Category is required" }, { status: 400 });
    }

    // カテゴリのバリデーション
    if (!CONSTRUCTION_PHOTO_CATEGORIES.includes(category as typeof CONSTRUCTION_PHOTO_CATEGORIES[number])) {
      return NextResponse.json(
        { error: `Invalid category. Allowed: ${CONSTRUCTION_PHOTO_CATEGORIES.join(", ")}` },
        { status: 400 }
      );
    }

    // ファイルタイプのバリデーション（画像のみ）
    const allowedTypes = [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/heic",
      "image/heif",
    ];

    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json(
        { error: "File type not allowed. Allowed: JPG, PNG, GIF, WebP, HEIC" },
        { status: 400 }
      );
    }

    // ファイルサイズ制限（20MB - 工事写真は大きめを許容）
    const maxSize = 20 * 1024 * 1024;
    if (file.size > maxSize) {
      return NextResponse.json(
        { error: "File too large. Maximum size is 20MB" },
        { status: 400 }
      );
    }

    const pathname = `projects/${projectId}/construction/${Date.now()}-${file.name}`;
    const token = process.env.BLOB_READ_WRITE_TOKEN;

    if (!token) {
      return NextResponse.json(
        { error: "Blob storage not configured" },
        { status: 500 }
      );
    }

    // ファイルの内容を読み取って新しいBlobを作成
    const bytes = await file.arrayBuffer();
    const newBlob = new Blob([bytes], { type: file.type });

    // Vercel Blobにアップロード
    const blob = await put(pathname, newBlob, {
      access: "public",
      token: token,
      addRandomSuffix: false,
    });

    // DBに保存
    const [result] = await db
      .insert(constructionPhotos)
      .values({
        projectId,
        category,
        fileName: file.name,
        fileUrl: blob.url,
        fileType: file.type,
        fileSize: file.size,
        contractorName: contractorName || null,
        note: note || null,
        takenAt: takenAt || null,
        createdAt: new Date().toISOString(),
      })
      .returning();

    return NextResponse.json(result);
  } catch (error) {
    console.error("Construction photo upload error:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { error: `Failed to upload photo: ${errorMessage}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/projects/[id]/construction-progress/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { constructionProgress, CONSTRUCTION_PROGRESS_CATEGORIES } from "@/db/schema";
import { eq, and, desc } from "drizzle-orm";

export const dynamic = "force-dynamic";

// 工事進捗一覧取得
export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }

  const progressList = await db
    .select()
    .from(constructionProgress)
    .where(eq(constructionProgress.projectId, projectId))
    .orderBy(desc(constructionProgress.createdAt));

  return NextResponse.json(progressList);
}

// 工事進捗作成・更新
export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }

  try {
    const body = await request.json();
    const { category, status, note } = body;

    // カテゴリのバリデーション
    if (!CONSTRUCTION_PROGRESS_CATEGORIES.includes(category)) {
      return NextResponse.json(
        { error: `Invalid category. Allowed: ${CONSTRUCTION_PROGRESS_CATEGORIES.join(", ")}` },
        { status: 400 }
      );
    }

    // ステータスのバリデーション
    const allowedStatuses = ["pending", "in_progress", "completed"];
    if (!allowedStatuses.includes(status)) {
      return NextResponse.json(
        { error: "Invalid status. Allowed: pending, in_progress, completed" },
        { status: 400 }
      );
    }

    // 同じカテゴリが既に存在するか確認
    const existing = await db
      .select()
      .from(constructionProgress)
      .where(
        and(
          eq(constructionProgress.projectId, projectId),
          eq(constructionProgress.category, category)
        )
      )
      .limit(1);

    const now = new Date().toISOString();

    if (existing.length > 0) {
      // 更新
      const [result] = await db
        .update(constructionProgress)
        .set({
          status,
          note: note || null,
          completedAt: status === "completed" ? now : null,
          updatedAt: now,
        })
        .where(eq(constructionProgress.id, existing[0].id))
        .returning();

      return NextResponse.json(result);
    } else {
      // 新規作成
      const [result] = await db
        .insert(constructionProgress)
        .values({
          projectId,
          category,
          status,
          note: note || null,
          completedAt: status === "completed" ? now : null,
          createdAt: now,
        })
        .returning();

      return NextResponse.json(result);
    }
  } catch (error) {
    console.error("Construction progress error:", error);
    return NextResponse.json(
      { error: "Failed to save construction progress" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/projects/[id]/files/[fileId]/download/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projectFiles } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import { supabaseAdmin, STORAGE_BUCKET } from "@/lib/supabase";

export const dynamic = "force-dynamic";

// ファイルダウンロード用の署名付きURLを生成
export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string; fileId: string }> }
) {
  const { id, fileId } = await params;
  const projectId = Number(id);
  const fileIdNum = Number(fileId);

  if (isNaN(projectId) || isNaN(fileIdNum)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  // DBからファイル情報を取得
  const [file] = await db
    .select()
    .from(projectFiles)
    .where(
      and(
        eq(projectFiles.id, fileIdNum),
        eq(projectFiles.projectId, projectId)
      )
    );

  if (!file) {
    return NextResponse.json({ error: "File not found" }, { status: 404 });
  }

  // 既存のURLからパスを抽出
  // URLの形式: https://xxx.supabase.co/storage/v1/object/sign/project-files/projects/2/xxx.jpg?token=...
  const urlObj = new URL(file.fileUrl);
  const pathMatch = urlObj.pathname.match(/\/storage\/v1\/object\/sign\/project-files\/(.+)$/);

  if (!pathMatch) {
    // 古い形式のURLの場合はそのままリダイレクト
    return NextResponse.redirect(file.fileUrl);
  }

  const filePath = decodeURIComponent(pathMatch[1]);

  // 新しい署名付きURLを生成（1時間有効）
  const { data, error } = await supabaseAdmin.storage
    .from(STORAGE_BUCKET)
    .createSignedUrl(filePath, 3600, {
      download: file.fileName, // ダウンロード時のファイル名を指定
    });

  if (error || !data) {
    console.error("Failed to create signed URL:", error);
    return NextResponse.json({ error: "Failed to generate download URL" }, { status: 500 });
  }

  // 新しいURLにリダイレクト
  return NextResponse.redirect(data.signedUrl);
}
</file>

<file path="src/app/api/projects/[id]/files/[fileId]/preview/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projectFiles } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import { supabaseAdmin, STORAGE_BUCKET } from "@/lib/supabase";

export const dynamic = "force-dynamic";

// ファイルプレビュー用 - 画像を直接プロキシして返す
export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string; fileId: string }> }
) {
  const { id, fileId } = await params;
  const projectId = Number(id);
  const fileIdNum = Number(fileId);

  if (isNaN(projectId) || isNaN(fileIdNum)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  // DBからファイル情報を取得
  const [file] = await db
    .select()
    .from(projectFiles)
    .where(
      and(
        eq(projectFiles.id, fileIdNum),
        eq(projectFiles.projectId, projectId)
      )
    );

  if (!file) {
    return NextResponse.json({ error: "File not found" }, { status: 404 });
  }

  // ファイルパスを抽出
  const urlObj = new URL(file.fileUrl);
  const pathMatch = urlObj.pathname.match(/\/storage\/v1\/object\/sign\/project-files\/(.+)$/);

  if (!pathMatch) {
    // 古い形式のURLの場合
    return NextResponse.redirect(file.fileUrl);
  }

  const filePath = decodeURIComponent(pathMatch[1]);

  // Supabaseからファイルをダウンロード
  const { data, error } = await supabaseAdmin.storage
    .from(STORAGE_BUCKET)
    .download(filePath);

  if (error || !data) {
    console.error("Failed to download file:", error);
    return NextResponse.json({ error: "Failed to load file", details: error?.message }, { status: 500 });
  }

  const arrayBuffer = await data.arrayBuffer();

  // ヘッダーを設定
  const headers: HeadersInit = {
    "Content-Type": file.fileType,
    "Content-Length": String(arrayBuffer.byteLength),
    "Cache-Control": "public, max-age=3600",
  };

  // PDFの場合はインライン表示用のヘッダーを追加
  if (file.fileType === "application/pdf") {
    headers["Content-Disposition"] = "inline";
  }

  return new NextResponse(arrayBuffer, { headers });
}
</file>

<file path="src/app/api/projects/[id]/files/[fileId]/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projectFiles } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import { supabaseAdmin, STORAGE_BUCKET } from "@/lib/supabase";

export const dynamic = "force-dynamic";

// ファイル削除
export async function DELETE(
  _request: Request,
  { params }: { params: Promise<{ id: string; fileId: string }> }
) {
  const { id, fileId } = await params;
  const projectId = Number(id);
  const fileIdNum = Number(fileId);

  if (isNaN(projectId) || isNaN(fileIdNum)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }

  // ファイル情報を取得
  const [file] = await db
    .select()
    .from(projectFiles)
    .where(
      and(
        eq(projectFiles.id, fileIdNum),
        eq(projectFiles.projectId, projectId)
      )
    );

  if (!file) {
    return NextResponse.json({ error: "File not found" }, { status: 404 });
  }

  try {
    // URLからファイルパスを抽出
    const urlObj = new URL(file.fileUrl);
    const pathMatch = urlObj.pathname.match(/\/storage\/v1\/object\/sign\/project-files\/(.+)$/);

    if (pathMatch) {
      const filePath = decodeURIComponent(pathMatch[1]);
      // Supabase Storageから削除
      const { error: deleteError } = await supabaseAdmin.storage
        .from(STORAGE_BUCKET)
        .remove([filePath]);

      if (deleteError) {
        console.error("Supabase delete error:", deleteError);
        // ストレージの削除に失敗してもDBからは削除を続行
      }
    }

    // DBから削除
    await db
      .delete(projectFiles)
      .where(eq(projectFiles.id, fileIdNum));

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("File delete error:", error);
    return NextResponse.json(
      { error: "Failed to delete file" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/projects/[id]/files/route.ts">
import { NextResponse } from "next/server";
import { put, del } from "@vercel/blob";
import { db } from "@/db";
import { projectFiles } from "@/db/schema";
import { eq, desc } from "drizzle-orm";

export const dynamic = "force-dynamic";

// ファイル一覧取得
export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }

  const files = await db
    .select()
    .from(projectFiles)
    .where(eq(projectFiles.projectId, projectId))
    .orderBy(desc(projectFiles.createdAt));

  return NextResponse.json(files);
}

// ファイルアップロード（FormData形式で受け取り）
export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get("file") as File | null;
    const category = (formData.get("category") as string | null) || "other";

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    // カテゴリのバリデーション
    const allowedCategories = ["registry_copy", "cadastral_map", "drawing", "consent_form", "other"];
    if (!allowedCategories.includes(category)) {
      return NextResponse.json(
        { error: "Invalid category. Allowed: registry_copy, cadastral_map, drawing, consent_form, other" },
        { status: 400 }
      );
    }

    // ファイルタイプのバリデーション
    const allowedTypes = [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "application/pdf",
    ];

    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json(
        { error: "File type not allowed. Allowed: JPG, PNG, GIF, WebP, PDF" },
        { status: 400 }
      );
    }

    // ファイルサイズ制限（10MB）
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      return NextResponse.json(
        { error: "File too large. Maximum size is 10MB" },
        { status: 500 }
      );
    }

    const pathname = `projects/${projectId}/${Date.now()}-${file.name}`;
    const token = process.env.BLOB_READ_WRITE_TOKEN;

    if (!token) {
      return NextResponse.json(
        { error: "Blob storage not configured" },
        { status: 500 }
      );
    }

    // ファイルの内容を読み取って新しいBlobを作成
    const bytes = await file.arrayBuffer();
    const newBlob = new Blob([bytes], { type: file.type });

    // Vercel Blobにアップロード
    const blob = await put(pathname, newBlob, {
      access: "public",
      token: token,
      addRandomSuffix: false,
    });

    // DBに保存
    const [result] = await db
      .insert(projectFiles)
      .values({
        projectId,
        fileName: file.name,
        fileUrl: blob.url,
        fileType: file.type,
        fileSize: file.size,
        category,
        createdAt: new Date().toISOString(),
      })
      .returning();

    return NextResponse.json(result);
  } catch (error) {
    console.error("File upload error:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { error: `Failed to upload file: ${errorMessage}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/search/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projects, todos, meetings } from "@/db/schema";
import { like, or, asc, desc } from "drizzle-orm";

export const dynamic = "force-dynamic";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get("q")?.trim();

  if (!query) {
    return NextResponse.json([]);
  }

  const searchPattern = `%${query}%`;

  // 案件を検索（管理番号、販売先、担当、現地住所、案件番号、地権者）
  const projectResults = await db
    .select()
    .from(projects)
    .where(
      or(
        like(projects.managementNumber, searchPattern),
        like(projects.client, searchPattern),
        like(projects.manager, searchPattern),
        like(projects.address, searchPattern),
        like(projects.projectNumber, searchPattern),
        like(projects.landowner1, searchPattern),
        like(projects.landowner2, searchPattern),
        like(projects.landowner3, searchPattern)
      )
    )
    .orderBy(asc(projects.managementNumber))
    .limit(10);

  // TODOを検索
  const todoResults = await db
    .select()
    .from(todos)
    .where(like(todos.content, searchPattern))
    .orderBy(asc(todos.dueDate))
    .limit(10);

  // 会議を検索（タイトル、内容、議題）
  const meetingResults = await db
    .select()
    .from(meetings)
    .where(
      or(
        like(meetings.title, searchPattern),
        like(meetings.content, searchPattern),
        like(meetings.agenda, searchPattern)
      )
    )
    .orderBy(desc(meetings.meetingDate))
    .limit(10);

  // 結果を統合
  const results = [
    ...projectResults.map((p) => ({
      type: "project" as const,
      id: p.id,
      title: p.managementNumber,
      subtitle: p.client,
      href: `/projects/${p.id}`,
    })),
    ...todoResults.map((t) => ({
      type: "todo" as const,
      id: t.id,
      title: t.content,
      subtitle: t.dueDate,
      href: t.projectId ? `/projects/${t.projectId}` : "/todo",
    })),
    ...meetingResults.map((m) => ({
      type: "meeting" as const,
      id: m.id,
      title: m.title,
      subtitle: `${m.meetingDate} - ${m.category}`,
      href: `/meetings/${m.id}`,
    })),
  ];

  return NextResponse.json(results);
}
</file>

<file path="src/app/meetings/MeetingsView.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Plus, Calendar as CalendarIcon, Loader2, Search } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import type { Meeting } from "@/db/schema";
import { format } from "date-fns";
import { ja } from "date-fns/locale";
import { cn } from "@/lib/utils";

const CATEGORY_OPTIONS = ["社内", "社外"] as const;

interface MeetingsViewProps {
  initialMeetings: Meeting[];
}

export default function MeetingsView({ initialMeetings }: MeetingsViewProps) {
  const router = useRouter();
  const [meetings, setMeetings] = useState<Meeting[]>(initialMeetings);
  const [open, setOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [calendarOpen, setCalendarOpen] = useState(false);
  const [form, setForm] = useState<{
    title: string;
    meetingDate: string;
    category: string;
    content: string;
  }>({
    title: "",
    meetingDate: "",
    category: "社内",
    content: "",
  });
  const [selectedDate, setSelectedDate] = useState<Date | undefined>(undefined);
  const [searchQuery, setSearchQuery] = useState("");

  // 検索フィルタ（タイトル・内容・議題・種別）
  const filteredMeetings = meetings.filter((meeting) => {
    if (!searchQuery.trim()) return true;
    const q = searchQuery.toLowerCase();
    const title = (meeting.title ?? "").toLowerCase();
    const content = (meeting.content ?? "").toLowerCase();
    const agenda = (meeting.agenda ?? "").toLowerCase();
    const category = (meeting.category ?? "").toLowerCase();
    return (
      title.includes(q) ||
      content.includes(q) ||
      agenda.includes(q) ||
      category.includes(q)
    );
  });

  const fetchMeetings = () => {
    fetch("/api/meetings", { cache: "no-store" })
      .then((res) => res.json())
      .then(setMeetings)
      .catch((err) => console.error("会議一覧の取得に失敗しました:", err));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!form.title.trim()) {
      alert("タイトルを入力してください");
      return;
    }
    if (!form.meetingDate) {
      alert("日付を選択してください");
      return;
    }
    setIsSubmitting(true);
    try {
      await fetch("/api/meetings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title: form.title.trim(),
          meetingDate: form.meetingDate,
          category: form.category,
          content: form.content.trim() || null,
        }),
      });
      setForm({ title: "", meetingDate: "", category: "社内", content: "" });
      setSelectedDate(undefined);
      setOpen(false);
      fetchMeetings();
    } finally {
      setIsSubmitting(false);
    }
  };

  const formatDisplayDate = (dateStr: string | null) => {
    if (!dateStr) return "-";
    const d = new Date(dateStr + "T00:00:00");
    if (isNaN(d.getTime())) return dateStr;
    return format(d, "yyyy年M月d日", { locale: ja });
  };

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto max-w-5xl py-10">
        <div className="space-y-6">
          <div className="flex items-center justify-between gap-4">
            <div className="space-y-1 shrink-0">
              <h1 className="text-xl font-semibold">会議</h1>
              <p className="text-sm text-muted-foreground">
                議事録を保存・確認できます
              </p>
            </div>

            <div className="relative flex-1 max-w-xl">
              <Search className="absolute left-4 top-1/2 h-5 w-5 -translate-y-1/2 text-muted-foreground" />
              <Input
                placeholder="タイトル・内容・議題・種別で検索"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full pl-12 h-12 text-base bg-muted/50 border-0 focus-visible:ring-2 rounded-xl"
              />
            </div>

            <Dialog open={open} onOpenChange={setOpen}>
              <DialogTrigger asChild>
                <Button>
                  <Plus className="h-4 w-4" />
                  新規登録
                </Button>
              </DialogTrigger>
              <DialogContent className="max-h-[90vh] overflow-y-auto max-w-lg">
                <DialogHeader>
                  <DialogTitle>議事録を新規登録</DialogTitle>
                </DialogHeader>
                <form onSubmit={handleSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="meeting-title">タイトル</Label>
                    <Input
                      id="meeting-title"
                      value={form.title}
                      onChange={(e) => setForm({ ...form, title: e.target.value })}
                      placeholder="例: 〇〇案件 定例ミーティング"
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label>日付</Label>
                    <Popover open={calendarOpen} onOpenChange={setCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button
                          type="button"
                          variant="outline"
                          className={cn(
                            "w-full justify-start text-left font-normal",
                            !selectedDate && "text-muted-foreground"
                          )}
                        >
                          <CalendarIcon className="mr-2 h-4 w-4" />
                          {selectedDate
                            ? format(selectedDate, "yyyy年M月d日", { locale: ja })
                            : "選択してください"}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={selectedDate}
                          onSelect={(date) => {
                            setSelectedDate(date);
                            if (date) {
                              const y = date.getFullYear();
                              const m = String(date.getMonth() + 1).padStart(2, "0");
                              const d = String(date.getDate()).padStart(2, "0");
                              setForm({ ...form, meetingDate: `${y}-${m}-${d}` });
                              setCalendarOpen(false);
                            }
                          }}
                          locale={ja}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="meeting-category">カテゴリ</Label>
                    <Select
                      value={form.category}
                      onValueChange={(value) => setForm({ ...form, category: value })}
                    >
                      <SelectTrigger id="meeting-category" className="w-full">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        {CATEGORY_OPTIONS.map((opt) => (
                          <SelectItem key={opt} value={opt}>
                            {opt}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="meeting-content">内容</Label>
                    <Textarea
                      id="meeting-content"
                      value={form.content}
                      onChange={(e) => setForm({ ...form, content: e.target.value })}
                      placeholder="議事録の長文テキストをペーストしてください"
                      className="min-h-[200px] resize-y font-mono text-sm"
                    />
                  </div>
                  <div className="flex justify-end gap-2">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => setOpen(false)}
                      disabled={isSubmitting}
                    >
                      キャンセル
                    </Button>
                    <Button type="submit" disabled={isSubmitting}>
                      {isSubmitting ? (
                        <>
                          <Loader2 className="h-4 w-4 animate-spin mr-2" />
                          登録中...
                        </>
                      ) : (
                        "登録"
                      )}
                    </Button>
                  </div>
                </form>
              </DialogContent>
            </Dialog>
          </div>

          <div className="rounded-xl border border-border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>タイトル</TableHead>
                  <TableHead>日付</TableHead>
                  <TableHead>種別</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredMeetings.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={3} className="text-center text-muted-foreground">
                      {searchQuery ? "検索結果がありません" : "議事録がありません"}
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredMeetings.map((meeting) => (
                    <TableRow
                      key={meeting.id}
                      className="cursor-pointer hover:bg-muted/50"
                      onClick={() => router.push(`/meetings/${meeting.id}`)}
                    >
                      <TableCell className="font-medium">{meeting.title}</TableCell>
                      <TableCell>{formatDisplayDate(meeting.meetingDate)}</TableCell>
                      <TableCell>{meeting.category}</TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/meetings/page.tsx">
import { desc } from "drizzle-orm";
import { db } from "@/db";
import { meetings } from "@/db/schema";
import MeetingsView from "./MeetingsView";

export const dynamic = "force-dynamic";

export default async function MeetingsPage() {
  const list = await db.select().from(meetings).orderBy(desc(meetings.meetingDate));
  return <MeetingsView initialMeetings={list} />;
}
</file>

<file path="src/app/tools/mail/page.tsx">
"use client";

import * as React from "react";
import Link from "next/link";
import { ArrowLeft, ChevronLeft, RotateCcw, Copy, Check } from "lucide-react";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

type Option = { id: string; label: string };
type Question = { id: string; title: string; options: Option[] };

const QUESTIONS: Question[] = [
  {
    id: "content",
    title: "Q1. メールの内容",
    options: [{ id: "ownership-transfer", label: "所有権移転登記" }],
  },
  {
    id: "deed",
    title: "Q2. 権利証",
    options: [
      { id: "lost", label: "紛失" },
      { id: "checked", label: "お預かりしていないが確認済み" },
    ],
  },
  {
    id: "land-use",
    title: "Q3. 地目変更",
    options: [
      { id: "yes", label: "あり" },
      { id: "no", label: "なし" },
    ],
  },
];

function buildEmail(answers: Record<string, string>) {
  const content = answers.content;
  const deed = answers.deed;
  const landUse = answers["land-use"];

  // 所有権移転登記 ⇒ 紛失 ⇒ あり
  if (content === "ownership-transfer" && deed === "lost" && landUse === "yes") {
    return [
      "吉村司法書士事務所",
      "吉村　様",
      "",
      "お世話になっております。",
      "Person Energyです。",
      "所有権移転登記をお願いいたします。",
      "権利証は紛失しておりますので、事前通知でお願いいたします。",
      "",
      "また、直近で地目変更をしておりますので、近傍評価の請求をお願いいたします。",
      "（概算で先に御見積等いただけると助かります）",
      "",
      "決済日はまだ未定です。",
      "",
      "何卒よろしくお願いいたします。",
    ].join("\n");
  }

  // 所有権移転登記 ⇒ お預かりしていないが確認済み ⇒ あり
  if (content === "ownership-transfer" && deed === "checked" && landUse === "yes") {
    return [
      "吉村司法書士事務所",
      "吉村　様",
      "",
      "お世話になっております。",
      "Person Energyです。",
      "所有権移転登記をお願いいたします。",
      "権利証はお預かりしておりませんが、確認はしています。",
      "入金後にお預かりの予定です。",
      "（登記申請書を送り返していただくときに、一緒に送っていただくよう案内していただけると助かります）",
      "",
      "また、直近で地目変更・相続をしておりますので、近傍評価の請求をお願いいたします。",
      "（概算で先に御見積等いただけると助かります）",
      "",
      "決済日はまだ未定です。",
      "",
      "何卒よろしくお願いいたします。",
    ].join("\n");
  }

  return "";
}

export default function MailPage() {
  const [step, setStep] = React.useState(0);
  const [answers, setAnswers] = React.useState<Record<string, string>>({});
  const [copiedBody, setCopiedBody] = React.useState(false);
  const [copiedTitle, setCopiedTitle] = React.useState(false);

  const done = step >= QUESTIONS.length;
  const question = QUESTIONS[step];
  const emailText = React.useMemo(() => (done ? buildEmail(answers) : ""), [done, answers]);
  
  // メールタイトルを生成
  const emailTitle = React.useMemo(() => {
    if (!done) return "";
    const content = answers.content;
    if (content === "ownership-transfer") {
      return "所有権移転登記のお願い（会社名_P番号)";
    }
    return "";
  }, [done, answers]);

  const choose = (qId: string, optionId: string) => {
    setAnswers((prev) => ({ ...prev, [qId]: optionId }));
    setStep((s) => s + 1);
  };

  const back = () => setStep((s) => Math.max(0, s - 1));
  const reset = () => {
    setAnswers({});
    setStep(0);
    setCopiedBody(false);
    setCopiedTitle(false);
  };

  const onCopyBody = async () => {
    if (!emailText) return;
    await navigator.clipboard.writeText(emailText);
    setCopiedBody(true);
    setTimeout(() => setCopiedBody(false), 1500);
  };

  const onCopyTitle = async () => {
    if (!emailTitle) return;
    await navigator.clipboard.writeText(emailTitle);
    setCopiedTitle(true);
    setTimeout(() => setCopiedTitle(false), 1500);
  };

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto flex min-h-screen max-w-3xl items-center justify-center py-10">
        <div className="w-full space-y-4">
          {!done ? (
            <>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Button
                    asChild
                    variant="ghost"
                    size="icon"
                    aria-label="ツール一覧に戻る"
                    title="戻る"
                  >
                    <Link href="/tools">
                      <ArrowLeft className="h-4 w-4" />
                    </Link>
                  </Button>
                  <p className="text-sm text-muted-foreground">
                    質問 {step + 1} / {QUESTIONS.length}
                  </p>
                </div>

                <div className="flex gap-2">
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={back}
                    disabled={step === 0}
                    aria-label="戻る"
                    title="戻る"
                  >
                    <ChevronLeft className="h-4 w-4" />
                  </Button>
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={reset}
                    aria-label="最初から"
                    title="最初から"
                  >
                    <RotateCcw className="h-4 w-4" />
                  </Button>
                </div>
              </div>

              <Card>
                <CardHeader>
                  <CardTitle>{question.title}</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="grid grid-cols-1 gap-3">
                    {question.options.map((opt) => (
                      <button
                        key={opt.id}
                        type="button"
                        onClick={() => choose(question.id, opt.id)}
                        className="rounded-2xl border border-border bg-card px-4 py-4 text-left transition-colors hover:bg-accent"
                      >
                        <p className="text-base">{opt.label}</p>
                      </button>
                    ))}
                  </div>
                </CardContent>
              </Card>
            </>
          ) : (
            <>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <Button
                    asChild
                    variant="ghost"
                    size="icon"
                    aria-label="ツール一覧に戻る"
                    title="戻る"
                  >
                    <Link href="/tools">
                      <ArrowLeft className="h-4 w-4" />
                    </Link>
                  </Button>
                  <h1 className="text-xl font-semibold">メール文面</h1>
                </div>
                <Button type="button" variant="ghost" onClick={reset}>
                  <RotateCcw className="h-4 w-4" />
                  最初から
                </Button>
              </div>

              {/* メールタイトルカード */}
              {emailTitle && (
                <div className="flex items-center justify-between gap-3 rounded-2xl border border-border bg-card px-4 py-3">
                  <p className="min-w-0 flex-1 truncate text-sm font-medium text-card-foreground">
                    {emailTitle}
                  </p>
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={onCopyTitle}
                    disabled={!emailTitle}
                    aria-label="タイトルをコピー"
                    title="コピー"
                  >
                    {copiedTitle ? (
                      <Check className="h-4 w-4 text-green-500" />
                    ) : (
                      <Copy className="h-4 w-4" />
                    )}
                  </Button>
                </div>
              )}

              {/* メール文面カード */}
              <div className="rounded-2xl border border-border bg-card p-4">
                {emailText ? (
                  <div className="space-y-3">
                    <div className="flex items-start justify-between gap-3">
                      <pre className="min-w-0 flex-1 whitespace-pre-wrap break-words text-sm text-card-foreground">
                        {emailText}
                      </pre>
                      <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        onClick={onCopyBody}
                        className="shrink-0"
                        aria-label="本文をコピー"
                        title="コピー"
                      >
                        {copiedBody ? (
                          <Check className="h-4 w-4 text-green-500" />
                        ) : (
                          <Copy className="h-4 w-4" />
                        )}
                      </Button>
                    </div>
                  </div>
                ) : (
                  <p className="text-sm text-muted-foreground">
                    （この条件のメール文面は未登録です）
                  </p>
                )}
              </div>

              {/* 添付資料の注意書き */}
              {emailText && (
                <div className="rounded-2xl border-2 border-amber-500/50 bg-amber-500/10 p-4">
                  <div className="flex items-start gap-3">
                    <div className="shrink-0 rounded-full bg-amber-500/20 p-2">
                      <svg
                        className="h-5 w-5 text-amber-600 dark:text-amber-400"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"
                        />
                      </svg>
                    </div>
                    <div className="flex-1 space-y-2">
                      <p className="font-semibold text-amber-900 dark:text-amber-200">
                        添付資料をお忘れなく
                      </p>
                      <ul className="space-y-1 text-sm text-amber-800 dark:text-amber-300">
                        <li className="flex items-center gap-2">
                          <span className="h-1.5 w-1.5 rounded-full bg-amber-600 dark:bg-amber-400"></span>
                          土地売買契約書
                        </li>
                        <li className="flex items-center gap-2">
                          <span className="h-1.5 w-1.5 rounded-full bg-amber-600 dark:bg-amber-400"></span>
                          印鑑登録証明書
                        </li>
                        <li className="flex items-center gap-2">
                          <span className="h-1.5 w-1.5 rounded-full bg-amber-600 dark:bg-amber-400"></span>
                          身分証明書
                        </li>
                        <li className="flex items-center gap-2">
                          <span className="h-1.5 w-1.5 rounded-full bg-amber-600 dark:bg-amber-400"></span>
                          不動産登記
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/tools/page.tsx">
"use client";

import Link from "next/link";
import { FileText, Mail } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

const tools = [
  {
    href: "/tools/filename",
    label: "ファイル名生成",
    description: "書類・氏名・日付からファイル名を生成",
    icon: FileText,
  },
  {
    href: "/tools/mail",
    label: "メール文面生成",
    description: "質問に答えてメール文面を自動生成",
    icon: Mail,
  },
] as const;

export default function ToolsPage() {
  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto max-w-5xl py-10">
        <div className="space-y-6">
          <div className="space-y-1">
            <h1 className="text-xl font-semibold">ツール</h1>
            <p className="text-sm text-muted-foreground">
              業務で使う便利機能を集約しています
            </p>
          </div>

          <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
            {tools.map((tool) => {
              const Icon = tool.icon;
              return (
                <Link key={tool.href} href={tool.href}>
                  <Card className="h-full transition-colors hover:bg-accent cursor-pointer">
                    <CardHeader>
                      <CardTitle className="flex items-center gap-2">
                        <Icon className="h-5 w-5" />
                        {tool.label}
                      </CardTitle>
                    </CardHeader>
                    <CardContent>
                      <p className="text-sm text-muted-foreground">
                        {tool.description}
                      </p>
                    </CardContent>
                  </Card>
                </Link>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ContactDeptAlertCard.tsx">
"use client";

import { Button } from "@/components/ui/button";

export interface ContactDeptAlertCardProps {
  /** 法令名（カードのタイトル） */
  title: string;
  /** アラート本文 */
  message: string;
  /** Googleで検索ボタン押下時のコールバック（lawName, lawId を渡して検索） */
  onSearch: (lawName: string, lawId?: number) => void;
  /** 検索時に渡す法令名 */
  lawName: string;
  /** 検索時に渡す法令ID（担当部署クエリ追加用） */
  lawId?: number;
  className?: string;
}

/**
 * 担当部署にお問い合わせのアラートカード（黄色）。
 * 河川法・急傾斜地・砂防・地すべり・森林法などで使用。
 */
export function ContactDeptAlertCard({
  title,
  message,
  onSearch,
  lawName,
  lawId,
  className,
}: ContactDeptAlertCardProps) {
  return (
    <div
      className={
        className ??
        "bg-yellow-50 dark:bg-yellow-950/30 rounded-4xl border border-yellow-200 dark:border-yellow-800 shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500"
      }
    >
      <div className="flex items-stretch gap-6">
        <div className="flex-1 min-w-0 flex flex-col justify-center">
          <p className="text-foreground font-medium mb-2">{title}</p>
          <p className="text-sm text-foreground">{message}</p>
        </div>
        <div className="flex shrink-0 items-center">
          <Button
            variant="outline"
            size="lg"
            onClick={() => onSearch(lawName, lawId)}
            className="h-12 px-6 text-base"
          >
            Googleで検索
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/DeleteConfirmDialog.tsx">
"use client";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface DeleteConfirmDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  title?: string;
  description?: string;
  isLoading?: boolean;
}

export function DeleteConfirmDialog({
  open,
  onOpenChange,
  onConfirm,
  title = "削除の確認",
  description = "本当に削除してもよろしいですか？この操作は取り消せません。",
  isLoading = false,
}: DeleteConfirmDialogProps) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{title}</AlertDialogTitle>
          <AlertDialogDescription>{description}</AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isLoading}>キャンセル</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            disabled={isLoading}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isLoading ? "削除中..." : "削除する"}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="src/components/Header.tsx">
"use client";

import { useSession } from "next-auth/react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { signOut } from "next-auth/react";
import { LogOut, User } from "lucide-react";
import { usePathname } from "next/navigation";

export function Header() {
  const { data: session } = useSession();
  const pathname = usePathname();

  // ログインページでは非表示
  if (pathname === "/login") return null;

  const user = session?.user;
  const userName = user?.name || (user as any)?.username || "ユーザー";
  const userImage = user?.image;
  const initials = userName.slice(0, 2).toUpperCase();

  return (
    <header className="sticky top-0 z-30 flex h-14 items-center justify-end border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 px-6">
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <button className="flex items-center gap-2 rounded-full p-1 hover:bg-muted transition-colors">
            <Avatar className="h-8 w-8">
              {userImage && <AvatarImage src={userImage} alt={userName} />}
              <AvatarFallback className="text-xs bg-primary text-primary-foreground">
                {initials}
              </AvatarFallback>
            </Avatar>
            <span className="text-sm font-medium hidden sm:inline-block max-w-[150px] truncate">
              {userName}
            </span>
          </button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end" className="w-56">
          <DropdownMenuLabel className="font-normal">
            <div className="flex flex-col space-y-1">
              <p className="text-sm font-medium leading-none">{userName}</p>
              {user?.email && (
                <p className="text-xs leading-none text-muted-foreground">
                  {user.email}
                </p>
              )}
            </div>
          </DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            onClick={() => signOut({ callbackUrl: "/login" })}
            className="text-destructive focus:text-destructive cursor-pointer"
          >
            <LogOut className="mr-2 h-4 w-4" />
            ログアウト
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </header>
  );
}
</file>

<file path="src/components/icons/AlanIcon.tsx">
import { cn } from "@/lib/utils";

interface AlanIconProps {
  className?: string;
}

export function AlanIcon({ className }: AlanIconProps) {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      className={cn("h-5 w-5", className)}
    >
      {/* 帽子本体（塗りつぶし） */}
      <path
        d="M3 8.5 L7 9.5 C7 7 9 4.5 13 4 C17 3.5 20 5.5 20.5 8.5 L20.5 10 L18 10 L18 9 C18 7 16 5.5 13 6 C10.5 6.5 9 8 9 10 L3 8.5 Z"
        fill="currentColor"
      />
      {/* 帽子のつば */}
      <path
        d="M3 8.5 L7 9.5 L9 10 L3.5 9.5 Z"
        fill="currentColor"
      />
      {/* 帽子のボタン */}
      <circle cx="13" cy="3.5" r="0.8" fill="currentColor" />
      {/* 帽子の調整部分（snapback） */}
      <rect x="18" y="9" width="2.5" height="1.5" rx="0.3" fill="currentColor" />
      {/* 顔の輪郭（額〜鼻〜口〜顎） */}
      <path
        d="M9 10
           C8.5 11 8 12 8 12.5
           L7.5 13.5
           C7 14.5 6.5 15 6.5 15.5
           C7 15.5 7.5 15.5 7.5 16
           C7.5 16.5 7 17 7 17.5
           C8 18 9 18.5 10 18.5
           C11 18.5 12 18 13 17.5"
        stroke="currentColor"
        strokeWidth="1.2"
        strokeLinecap="round"
        strokeLinejoin="round"
        fill="none"
      />
      {/* 後頭部〜首の後ろ */}
      <path
        d="M20.5 10
           C21 12 20.5 14 19 16
           C18 17 17 17.5 16 18
           L15 18.5"
        stroke="currentColor"
        strokeWidth="1.2"
        strokeLinecap="round"
        fill="none"
      />
      {/* 顎から首 */}
      <path
        d="M13 17.5 C13 18 13 19 12.5 20"
        stroke="currentColor"
        strokeWidth="1.2"
        strokeLinecap="round"
        fill="none"
      />
      {/* 首の後ろ */}
      <path
        d="M15 18.5 C15 19.5 15.5 20.5 16 21"
        stroke="currentColor"
        strokeWidth="1.2"
        strokeLinecap="round"
        fill="none"
      />
      {/* 襟 */}
      <path
        d="M12.5 20 C13 20 14 20 15 19.5"
        stroke="currentColor"
        strokeWidth="1.2"
        strokeLinecap="round"
        fill="none"
      />
      <path
        d="M16 21 L17 22"
        stroke="currentColor"
        strokeWidth="1.2"
        strokeLinecap="round"
        fill="none"
      />
      {/* 耳 */}
      <path
        d="M18.5 12 C19.5 12.5 19.5 14 19 14.5 C18.5 15 18 14.5 18 14"
        stroke="currentColor"
        strokeWidth="1.2"
        strokeLinecap="round"
        fill="none"
      />
      {/* 眉毛 */}
      <path
        d="M8 11.5 L10 11.5"
        stroke="currentColor"
        strokeWidth="0.8"
        strokeLinecap="round"
        fill="none"
      />
      {/* 目 */}
      <ellipse cx="9" cy="13" rx="0.5" ry="0.7" fill="currentColor" />
    </svg>
  );
}
</file>

<file path="src/components/LawAlertCard.tsx">
"use client";

import { ExternalLink } from "lucide-react";
import { Button } from "@/components/ui/button";

export interface LawAlertCardProps {
  /** 法令名（カードのタイトル） */
  title: string;
  /** アラート本文 */
  message: string;
  /** 「詳細はこちら」のリンク先URL */
  detailUrl: string;
  /** リスト用の key は親で付与する想定 */
  className?: string;
  /** 琥珀色（既定）または赤 */
  variant?: "amber" | "red";
}

/**
 * 現地住所に応じて表示する法令アラートカード。
 * 土壌汚染対策法（福山市対象地区）など、条件を満たすときのみ親で差し替えて表示する。
 */
const variantClasses = {
  amber:
    "bg-amber-50 dark:bg-amber-950/30 border-amber-200 dark:border-amber-800",
  red: "bg-red-50 dark:bg-red-950/30 border-red-200 dark:border-red-800",
};

export function LawAlertCard({
  title,
  message,
  detailUrl,
  className,
  variant = "amber",
}: LawAlertCardProps) {
  const base =
    className ??
    `rounded-4xl border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500 ${variantClasses[variant]}`;
  return (
    <div className={base}>
      <div className="flex items-stretch gap-6">
        <div className="flex-1 min-w-0 flex flex-col justify-center">
          <p className="text-foreground font-medium mb-2">{title}</p>
          <p className="text-sm text-foreground">{message}</p>
        </div>
        <div className="flex shrink-0 items-center">
          <Button
            variant="outline"
            size="lg"
            onClick={() => window.open(detailUrl, "_blank")}
            className="h-12 px-6 text-base"
          >
            <ExternalLink className="h-4 w-4 mr-2" />
            詳細はこちら
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/PDFThumbnail.tsx">
"use client";

import { useEffect, useRef, useState } from "react";
import { FileText, Loader2 } from "lucide-react";

interface PDFThumbnailProps {
  src: string;
  alt: string;
  className?: string;
  onClick?: () => void;
}

export function PDFThumbnail({ src, alt, className, onClick }: PDFThumbnailProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const renderTaskRef = useRef<{ cancel: () => void } | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(false);

  useEffect(() => {
    let isCancelled = false;

    const loadPDF = async () => {
      if (!canvasRef.current) return;

      // 前回のレンダリングタスクをキャンセル
      if (renderTaskRef.current) {
        renderTaskRef.current.cancel();
        renderTaskRef.current = null;
      }

      try {
        setIsLoading(true);
        setError(false);

        // pdf.jsを動的にインポート（クライアントサイドのみ）
        const pdfjsLib = await import("pdfjs-dist");

        if (isCancelled) return;

        // Worker設定
        pdfjsLib.GlobalWorkerOptions.workerSrc = "/pdf.worker.min.mjs";

        // PDFを読み込む
        const loadingTask = pdfjsLib.getDocument(src);
        const pdf = await loadingTask.promise;

        if (isCancelled) return;

        // 1ページ目を取得
        const page = await pdf.getPage(1);

        if (isCancelled) return;

        // キャンバスのサイズを計算（アスペクト比を維持）
        const canvas = canvasRef.current;
        if (!canvas) return;

        const containerWidth = canvas.parentElement?.clientWidth || 300;
        const viewport = page.getViewport({ scale: 1 });
        const scale = containerWidth / viewport.width;
        const scaledViewport = page.getViewport({ scale });

        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;

        // レンダリング
        const context = canvas.getContext("2d");
        if (context && !isCancelled) {
          // キャンバスをクリア
          context.clearRect(0, 0, canvas.width, canvas.height);

          const renderTask = page.render({
            canvasContext: context,
            viewport: scaledViewport,
            canvas: canvas,
          } as Parameters<typeof page.render>[0]);

          renderTaskRef.current = renderTask;

          await renderTask.promise;

          if (!isCancelled) {
            setIsLoading(false);
          }
        }
      } catch (err) {
        if (!isCancelled) {
          // キャンセルエラーは無視
          if (err instanceof Error && err.message.includes("cancel")) {
            return;
          }
          console.error("PDF thumbnail error:", err);
          setError(true);
          setIsLoading(false);
        }
      }
    };

    loadPDF();

    return () => {
      isCancelled = true;
      if (renderTaskRef.current) {
        renderTaskRef.current.cancel();
        renderTaskRef.current = null;
      }
    };
  }, [src]);

  if (error) {
    return (
      <button
        onClick={onClick}
        className={`flex items-center justify-center bg-muted ${className}`}
      >
        <FileText className="h-12 w-12 text-muted-foreground" />
      </button>
    );
  }

  return (
    <button
      onClick={onClick}
      className={`relative overflow-hidden bg-muted ${className}`}
    >
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-muted">
          <Loader2 className="h-8 w-8 text-muted-foreground animate-spin" />
        </div>
      )}
      <canvas
        ref={canvasRef}
        className={`w-full h-full object-contain ${isLoading ? "opacity-0" : "opacity-100"}`}
      />
      <div className="absolute bottom-2 right-2 bg-black/70 text-white text-xs px-2 py-1 rounded">
        PDF
      </div>
    </button>
  );
}
</file>

<file path="src/components/ProjectFiles.tsx">
"use client";

import { useState, useCallback, useEffect, useMemo } from "react";
import { Upload, File, Image as ImageIcon, FileText, Trash2, Download, Eye, FolderOpen } from "lucide-react";
import { PDFThumbnail } from "@/components/PDFThumbnail";
import { uploadFile } from "@/app/actions/uploadFile";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { cn } from "@/lib/utils";
import type { ProjectFile } from "@/db/schema";

// ファイルカテゴリの定義
const FILE_CATEGORIES = {
  registry_copy: { label: "謄本", color: "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200" },
  cadastral_map: { label: "公図", color: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" },
  drawing: { label: "図面", color: "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200" },
  consent_form: { label: "同意書", color: "bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200" },
  other: { label: "その他", color: "bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200" },
} as const;

type FileCategory = keyof typeof FILE_CATEGORIES;

interface ProjectFilesProps {
  projectId: number;
  initialFiles?: ProjectFile[];
}

function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function getFileIcon(fileType: string) {
  if (fileType.startsWith("image/")) {
    return <ImageIcon className="h-5 w-5" />;
  }
  if (fileType === "application/pdf") {
    return <FileText className="h-5 w-5" />;
  }
  return <File className="h-5 w-5" />;
}

export function ProjectFiles({ projectId, initialFiles = [] }: ProjectFilesProps) {
  const [files, setFiles] = useState<ProjectFile[]>(initialFiles);
  const [isUploading, setIsUploading] = useState(false);
  const [isDragOver, setIsDragOver] = useState(false);
  const [previewFile, setPreviewFile] = useState<ProjectFile | null>(null);
  const [deleteFile, setDeleteFile] = useState<ProjectFile | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<FileCategory>("other");
  const [activeTab, setActiveTab] = useState<string>("all");

  // カテゴリ別にファイルをグループ化
  const filesByCategory = useMemo(() => {
    const grouped: Record<string, ProjectFile[]> = { all: files };
    Object.keys(FILE_CATEGORIES).forEach((cat) => {
      grouped[cat] = files.filter((f) => (f.category || "other") === cat);
    });
    return grouped;
  }, [files]);

  const fetchFiles = useCallback(async () => {
    const res = await fetch(`/api/projects/${projectId}/files`);
    if (res.ok) {
      const data = await res.json();
      setFiles(data);
    }
  }, [projectId]);

  // マウント時にファイル一覧を取得
  useEffect(() => {
    fetchFiles();
  }, [fetchFiles]);

  // デバッグ用ログ
  useEffect(() => {
    console.log("ProjectFiles - files:", files);
    console.log("ProjectFiles - projectId:", projectId);
  }, [files, projectId]);

  const handleUpload = async (fileList: FileList | null, category?: FileCategory) => {
    if (!fileList || fileList.length === 0) return;

    setIsUploading(true);
    const uploadCategory = category || selectedCategory;

    for (const file of Array.from(fileList)) {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("projectId", String(projectId));
      formData.append("category", uploadCategory);

      try {
        const result = await uploadFile(formData);

        if (result.error) {
          console.error("Server error:", result.error);
          alert(`アップロード失敗: ${result.error}`);
        }
      } catch (err) {
        console.error("Upload error:", err);
        alert(`アップロードに失敗しました: ${err instanceof Error ? err.message : "Unknown error"}`);
      }
    }

    await fetchFiles();
    setIsUploading(false);
  };

  const handleDelete = async () => {
    if (!deleteFile) return;

    try {
      const res = await fetch(
        `/api/projects/${projectId}/files/${deleteFile.id}`,
        { method: "DELETE" }
      );

      if (res.ok) {
        await fetchFiles();
      } else {
        alert("削除に失敗しました");
      }
    } catch (err) {
      console.error("Delete error:", err);
      alert("削除に失敗しました");
    }

    setDeleteFile(null);
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
    handleUpload(e.dataTransfer.files);
  };

  // ファイルカードのレンダリング
  const renderFileCard = (file: ProjectFile) => {
    const category = (file.category || "other") as FileCategory;
    const categoryInfo = FILE_CATEGORIES[category];

    return (
      <Card key={file.id} className="overflow-hidden">
        <CardContent className="p-0">
          {/* プレビューサムネイル */}
          {file.fileType.startsWith("image/") ? (
            <button
              onClick={() => setPreviewFile(file)}
              className="w-full aspect-video bg-muted flex items-center justify-center overflow-hidden hover:opacity-80 transition-opacity"
            >
              <img
                src={`/api/projects/${projectId}/files/${file.id}/preview`}
                alt={file.fileName}
                className="w-full h-full object-cover"
                onError={(e) => {
                  e.currentTarget.style.display = 'none';
                }}
              />
            </button>
          ) : file.fileType === "application/pdf" ? (
            <PDFThumbnail
              src={`/api/projects/${projectId}/files/${file.id}/preview`}
              alt={file.fileName}
              className="w-full aspect-video hover:opacity-80 transition-opacity"
              onClick={() => setPreviewFile(file)}
            />
          ) : (
            <button
              onClick={() => setPreviewFile(file)}
              className="w-full aspect-video bg-muted flex items-center justify-center hover:bg-muted/80 transition-colors"
            >
              <FileText className="h-12 w-12 text-muted-foreground" />
            </button>
          )}

          {/* ファイル情報 */}
          <div className="p-3">
            <div className="flex items-start gap-2">
              <div className="shrink-0 text-muted-foreground">
                {getFileIcon(file.fileType)}
              </div>
              <div className="min-w-0 flex-1">
                <p className="text-sm font-medium truncate" title={file.fileName}>
                  {file.fileName}
                </p>
                <div className="flex items-center gap-2 mt-1">
                  <span className={cn("text-xs px-2 py-0.5 rounded-full", categoryInfo.color)}>
                    {categoryInfo.label}
                  </span>
                  <span className="text-xs text-muted-foreground">
                    {formatFileSize(file.fileSize)}
                  </span>
                </div>
              </div>
            </div>
            <div className="flex items-center gap-1 mt-2">
              <Button
                variant="ghost"
                size="sm"
                className="h-8 flex-1"
                onClick={() => setPreviewFile(file)}
              >
                <Eye className="h-3 w-3 mr-1" />
                表示
              </Button>
              <Button
                variant="ghost"
                size="sm"
                className="h-8 flex-1"
                asChild
              >
                <a href={`/api/projects/${projectId}/files/${file.id}/download`} target="_blank" rel="noopener noreferrer">
                  <Download className="h-3 w-3 mr-1" />
                  保存
                </a>
              </Button>
              <Button
                variant="ghost"
                size="sm"
                className="h-8 text-destructive hover:text-destructive"
                onClick={() => setDeleteFile(file)}
              >
                <Trash2 className="h-3 w-3" />
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  return (
    <div className="space-y-4">
      {/* アップロードエリア */}
      <div className="space-y-3">
        {/* カテゴリ選択 */}
        <div className="flex items-center gap-3">
          <label className="text-sm font-medium text-muted-foreground">カテゴリ:</label>
          <Select value={selectedCategory} onValueChange={(v) => setSelectedCategory(v as FileCategory)}>
            <SelectTrigger className="w-40">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {Object.entries(FILE_CATEGORIES).map(([key, { label }]) => (
                <SelectItem key={key} value={key}>{label}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        <div
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          className={cn(
            "border-2 border-dashed rounded-xl p-6 text-center transition-colors",
            isDragOver
              ? "border-primary bg-primary/5"
              : "border-border hover:border-primary/50",
            isUploading && "opacity-50 pointer-events-none"
          )}
        >
          <input
            type="file"
            id="file-upload"
            className="hidden"
            multiple
            accept="image/jpeg,image/png,image/gif,image/webp,application/pdf"
            onChange={(e) => handleUpload(e.target.files)}
          />
          <label
            htmlFor="file-upload"
            className="cursor-pointer flex flex-col items-center gap-2"
          >
            <Upload className="h-8 w-8 text-muted-foreground" />
            <p className="text-sm text-muted-foreground">
              {isUploading
                ? "アップロード中..."
                : "ファイルをドラッグ&ドロップ、またはクリックして選択"}
            </p>
            <p className="text-xs text-muted-foreground">
              JPG, PNG, GIF, WebP, PDF（最大10MB）
            </p>
            <p className="text-xs font-medium text-primary">
              カテゴリ: {FILE_CATEGORIES[selectedCategory].label}
            </p>
          </label>
        </div>
      </div>

      {/* ファイル一覧（カテゴリ別タブ） */}
      {files.length === 0 ? (
        <p className="text-sm text-muted-foreground text-center py-4">
          ファイルがありません
        </p>
      ) : (
        <Tabs value={activeTab} onValueChange={(value) => {
          setActiveTab(value);
          // タブ切り替え時にカテゴリプルダウンも連動（「すべて」の場合は「その他」に設定）
          if (value !== "all" && value in FILE_CATEGORIES) {
            setSelectedCategory(value as FileCategory);
          }
        }} className="w-full">
          <TabsList className="grid w-full grid-cols-3 sm:grid-cols-6 mb-4">
            <TabsTrigger value="all" className="text-xs">
              すべて ({files.length})
            </TabsTrigger>
            {Object.entries(FILE_CATEGORIES).map(([key, { label }]) => (
              <TabsTrigger key={key} value={key} className="text-xs">
                {label} ({filesByCategory[key]?.length || 0})
              </TabsTrigger>
            ))}
          </TabsList>

          <TabsContent value="all">
            <div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
              {files.map(renderFileCard)}
            </div>
          </TabsContent>

          {Object.keys(FILE_CATEGORIES).map((key) => (
            <TabsContent key={key} value={key}>
              {filesByCategory[key]?.length === 0 ? (
                <div className="flex flex-col items-center justify-center py-8 text-muted-foreground">
                  <FolderOpen className="h-12 w-12 mb-2" />
                  <p className="text-sm">{FILE_CATEGORIES[key as FileCategory].label}のファイルがありません</p>
                </div>
              ) : (
                <div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
                  {filesByCategory[key]?.map(renderFileCard)}
                </div>
              )}
            </TabsContent>
          ))}
        </Tabs>
      )}

      {/* プレビューダイアログ */}
      <Dialog open={!!previewFile} onOpenChange={() => setPreviewFile(null)}>
        <DialogContent className="!max-w-[95vw] w-[95vw] max-h-[95vh] overflow-hidden p-4 sm:!max-w-[95vw]">
          <DialogHeader>
            <DialogTitle className="truncate pr-8">
              {previewFile?.fileName}
            </DialogTitle>
          </DialogHeader>
          {previewFile && (
            <div className="mt-2 overflow-hidden">
              {previewFile.fileType.startsWith("image/") ? (
                <div className="flex items-center justify-center max-h-[calc(95vh-100px)] overflow-auto">
                  <img
                    src={`/api/projects/${projectId}/files/${previewFile.id}/preview`}
                    alt={previewFile.fileName}
                    className="max-w-full max-h-[calc(95vh-100px)] object-contain rounded-lg"
                  />
                </div>
              ) : previewFile.fileType === "application/pdf" ? (
                <div className="space-y-3">
                  <iframe
                    src={`/api/projects/${projectId}/files/${previewFile.id}/preview`}
                    className="w-full h-[calc(95vh-120px)] rounded-lg border"
                    title={previewFile.fileName}
                  />
                  <div className="flex justify-end gap-2">
                    <Button variant="outline" size="sm" asChild>
                      <a
                        href={`/api/projects/${projectId}/files/${previewFile.id}/preview`}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <Eye className="h-4 w-4 mr-2" />
                        新しいタブで開く
                      </a>
                    </Button>
                    <Button variant="outline" size="sm" asChild>
                      <a
                        href={`/api/projects/${projectId}/files/${previewFile.id}/download`}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <Download className="h-4 w-4 mr-2" />
                        ダウンロード
                      </a>
                    </Button>
                  </div>
                </div>
              ) : null}
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* 削除確認ダイアログ */}
      <AlertDialog open={!!deleteFile} onOpenChange={() => setDeleteFile(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>ファイルを削除しますか？</AlertDialogTitle>
            <AlertDialogDescription>
              「{deleteFile?.fileName}」を削除します。この操作は取り消せません。
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>キャンセル</AlertDialogCancel>
            <AlertDialogAction onClick={handleDelete} className="bg-destructive text-destructive-foreground hover:bg-destructive/90">
              削除
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="src/components/SessionProvider.tsx">
"use client";

import { SessionProvider as NextAuthSessionProvider } from "next-auth/react";

export function SessionProvider({ children }: { children: React.ReactNode }) {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>;
}
</file>

<file path="src/components/ThemeProvider.tsx">
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="src/components/ThemeToggle.tsx">
"use client";

import * as React from "react";
import { Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { Button } from "@/components/ui/button";

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();
  const [mounted, setMounted] = React.useState(false);

  // マウント後にのみレンダリング（ハイドレーションエラー防止）
  React.useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <Button variant="ghost" size="icon" className="h-9 w-9">
        <Sun className="h-4 w-4" />
      </Button>
    );
  }

  return (
    <Button
      variant="ghost"
      size="icon"
      className="h-9 w-9"
      onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
      title={theme === "dark" ? "ライトモードに切り替え" : "ダークモードに切り替え"}
    >
      {theme === "dark" ? (
        <Sun className="h-4 w-4" />
      ) : (
        <Moon className="h-4 w-4" />
      )}
    </Button>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import { Avatar as AvatarPrimitive } from "radix-ui"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  size = "default",
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root> & {
  size?: "default" | "sm" | "lg"
}) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      data-size={size}
      className={cn(
        "group/avatar relative flex size-8 shrink-0 overflow-hidden rounded-full select-none data-[size=lg]:size-10 data-[size=sm]:size-6",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted text-muted-foreground flex size-full items-center justify-center rounded-full text-sm group-data-[size=sm]/avatar:text-xs",
        className
      )}
      {...props}
    />
  )
}

function AvatarBadge({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="avatar-badge"
      className={cn(
        "bg-primary text-primary-foreground ring-background absolute right-0 bottom-0 z-10 inline-flex items-center justify-center rounded-full ring-2 select-none",
        "group-data-[size=sm]/avatar:size-2 group-data-[size=sm]/avatar:[&>svg]:hidden",
        "group-data-[size=default]/avatar:size-2.5 group-data-[size=default]/avatar:[&>svg]:size-2",
        "group-data-[size=lg]/avatar:size-3 group-data-[size=lg]/avatar:[&>svg]:size-2",
        className
      )}
      {...props}
    />
  )
}

function AvatarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="avatar-group"
      className={cn(
        "*:data-[slot=avatar]:ring-background group/avatar-group flex -space-x-2 *:data-[slot=avatar]:ring-2",
        className
      )}
      {...props}
    />
  )
}

function AvatarGroupCount({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="avatar-group-count"
      className={cn(
        "bg-muted text-muted-foreground ring-background relative flex size-8 shrink-0 items-center justify-center rounded-full text-sm ring-2 group-has-data-[size=lg]/avatar-group:size-10 group-has-data-[size=sm]/avatar-group:size-6 [&>svg]:size-4 group-has-data-[size=lg]/avatar-group:[&>svg]:size-5 group-has-data-[size=sm]/avatar-group:[&>svg]:size-3",
        className
      )}
      {...props}
    />
  )
}

export {
  Avatar,
  AvatarImage,
  AvatarFallback,
  AvatarBadge,
  AvatarGroup,
  AvatarGroupCount,
}
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        // v9 UI keys
        months: "flex flex-col gap-4",
        month: "space-y-4",
        month_caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        button_previous: cn(
          buttonVariants({ variant: "outline", size: "icon-sm" }),
          "h-7 w-7 bg-transparent p-0 opacity-70 hover:opacity-100 absolute left-1"
        ),
        button_next: cn(
          buttonVariants({ variant: "outline", size: "icon-sm" }),
          "h-7 w-7 bg-transparent p-0 opacity-70 hover:opacity-100 absolute right-1"
        ),

        month_grid: "w-full border-collapse",
        weekdays: "grid grid-cols-7",
        weekday:
          "text-muted-foreground text-center w-9 font-normal text-[0.8rem] leading-9",
        weeks: "grid gap-1",
        week: "grid grid-cols-7",

        day: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20",
          "[&:has([aria-selected])]:bg-accent [&:has([aria-selected])]:rounded-md"
        ),
        day_button: cn(
          buttonVariants({ variant: "ghost", size: "icon" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),

        selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        today: "bg-accent text-accent-foreground",
        outside:
          "text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        disabled: "text-muted-foreground opacity-50",
        range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        hidden: "invisible",
        ...classNames,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ComponentRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-3 w-3" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"
import { DropdownMenu as DropdownMenuPrimitive } from "radix-ui"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

const Popover = PopoverPrimitive.Root
const PopoverTrigger = PopoverPrimitive.Trigger
const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={[
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md border p-4 shadow-md outline-hidden",
        className,
      ]
        .filter(Boolean)
        .join(" ")}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative overflow-hidden", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none select-none transition-colors",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent p-[1px]",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent p-[1px]",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "item-aligned",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span
        data-slot="select-item-indicator"
        className="absolute right-2 flex size-3.5 items-center justify-center"
      >
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="src/lib/address.ts">
/**
 * 現地住所から検索用の都道府県名・市区町村名を抽出する
 */

/**
 * 住所文字列から都道府県名と市区町村名を取得する。
 * 例: "広島県福山市瀬戸町..." → { prefectureName: "広島県", cityName: "福山市" }
 */
export function parsePrefectureAndCity(
  address: string | null
): { prefectureName: string; cityName: string } {
  if (!address?.trim()) return { prefectureName: "", cityName: "" };
  const a = address.trim();
  let prefectureName = "";
  let remainder = a;
  if (a.startsWith("広島県")) {
    prefectureName = "広島県";
    remainder = a.slice(3).trim(); // 「広島県」は3文字
  } else if (a.startsWith("岡山県")) {
    prefectureName = "岡山県";
    remainder = a.slice(3).trim(); // 「岡山県」は3文字
  }
  // 市区町村：都道府県以降で「市」「区」「町」「村」のいずれかで終わる最初の塊を取得
  const cityMatch = remainder.match(/^(.+?[市区町村])/);
  const cityName = cityMatch ? cityMatch[1] : remainder ? (remainder.split(/\s/)[0] ?? "") : "";
  return { prefectureName, cityName };
}
</file>

<file path="src/lib/coordinates.ts">
/**
 * 座標文字列の正規化・パース
 * カンマ・スラッシュ・空白区切り（例: "34.386542/131.56731", "34.386542, 131.56731"）に対応
 */

const COORD_SPLIT = /[\s,\/]+/;

/**
 * 座標文字列を分割して [緯度, 経度] の配列を返す（前後の空白はトリム）
 */
export function splitCoordinateString(value: string): string[] {
  if (!value || typeof value !== "string") return [];
  return value.split(COORD_SPLIT).map((p) => p.trim()).filter(Boolean);
}

/**
 * 座標文字列をパースし、緯度・経度を返す。無効な場合は null
 */
export function parseCoordinateString(
  value: string
): { lat: string; lon: string } | null {
  const parts = splitCoordinateString(value);
  if (parts.length < 2) return null;
  const lat = parts[0];
  const lon = parts[1];
  if (
    lat == null ||
    lon == null ||
    isNaN(parseFloat(lat)) ||
    isNaN(parseFloat(lon))
  )
    return null;
  return { lat, lon };
}

/**
 * 座標文字列を正規化する（緯度,経度 の形式で返す）。無効な場合は空文字
 */
export function normalizeCoordinateString(value: string): string {
  const parsed = parseCoordinateString(value);
  if (!parsed) return "";
  return `${parsed.lat},${parsed.lon}`;
}
</file>

<file path="src/lib/supabase.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

// サーバーサイド専用のSupabaseクライアント（Service Role Key使用）
export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false,
  },
});

export const STORAGE_BUCKET = "project-files";
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/api/calendar/events/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { todos, projects, progress, meetings, calendarEvents } from "@/db/schema";
import { eq } from "drizzle-orm";
import { auth } from "@/auth";

// カレンダー用のイベントを一括取得
export async function GET() {
  try {
    // 並列でデータを取得
    const [allTodos, allProjects, allProgress, allMeetings, allCalendarEvents] = await Promise.all([
      db.select().from(todos),
      db.select().from(projects),
      db.select().from(progress),
      db.select().from(meetings),
      db.select().from(calendarEvents),
    ]);

    // プロジェクトIDをキーにしたマップを作成
    const projectMap = new Map(allProjects.map((p) => [p.id, p]));

    // イベントを構築
    const events = [];

    // TODOイベント
    for (const todo of allTodos) {
      const project = todo.projectId ? projectMap.get(todo.projectId) : null;
      events.push({
        id: `todo-${todo.id}`,
        type: "todo" as const,
        title: todo.content,
        start: todo.dueDate,
        projectId: todo.projectId,
        projectName: project?.managementNumber || null,
        status: todo.completedAt ? "completed" : "pending",
        description: null,
        userName: todo.userName || null,
      });
    }

    // 進捗イベント
    for (const prog of allProgress) {
      const date = prog.completedAt || prog.createdAt;
      if (!date) continue;

      const project = projectMap.get(prog.projectId);
      events.push({
        id: `progress-${prog.id}`,
        type: "progress" as const,
        title: `${project?.managementNumber || ""}: ${prog.title}`,
        start: date.split("T")[0],
        projectId: prog.projectId,
        projectName: project?.managementNumber || null,
        status: prog.status,
        description: prog.description,
        userName: null,
      });
    }

    // 会議イベント（タイトルのみ、議事録は含めない）
    for (const meeting of allMeetings) {
      events.push({
        id: `meeting-${meeting.id}`,
        type: "meeting" as const,
        title: meeting.title,
        start: meeting.meetingDate,
        projectId: null,
        projectName: null,
        status: null,
        description: null, // 議事録は含めない
        userName: null,
        category: meeting.category, // 種別（社内/社外）
      });
    }

    // カスタムイベント
    for (const event of allCalendarEvents) {
      events.push({
        id: `custom-${event.id}`,
        type: event.eventType as "todo" | "meeting" | "other",
        title: event.title,
        start: event.eventDate,
        end: event.endDate,
        projectId: null,
        projectName: null,
        status: null,
        description: event.description,
        userName: event.userName || null,
      });
    }

    return NextResponse.json(events);
  } catch (error) {
    console.error("カレンダーイベントの取得に失敗:", error);
    return NextResponse.json({ error: "データの取得に失敗しました" }, { status: 500 });
  }
}

// カスタムイベントを作成
export async function POST(request: Request) {
  try {
    const session = await auth();
    const body = await request.json();
    const { title, eventType, eventDate, endDate, description } = body;

    if (!title || !eventDate) {
      return NextResponse.json(
        { error: "タイトルと日付は必須です" },
        { status: 400 }
      );
    }

    // セッションからユーザー情報を取得
    const userId = session?.user?.id ? parseInt(session.user.id) : null;
    const userName = session?.user?.name || (session?.user as any)?.username || null;

    const [result] = await db
      .insert(calendarEvents)
      .values({
        title,
        eventType: eventType || "other",
        eventDate,
        endDate: endDate || null,
        description: description || null,
        userId,
        userName,
        createdAt: new Date().toISOString(),
      })
      .returning();

    return NextResponse.json({
      id: `custom-${result.id}`,
      type: result.eventType,
      title: result.title,
      start: result.eventDate,
      end: result.endDate,
      description: result.description,
      userName: result.userName,
    });
  } catch (error) {
    console.error("イベントの作成に失敗:", error);
    return NextResponse.json({ error: "イベントの作成に失敗しました" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/feedbacks/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { feedbacks } from "@/db/schema";
import { desc } from "drizzle-orm";
import { auth } from "@/auth";

export const dynamic = "force-dynamic";

// 要望一覧取得
export async function GET() {
  const allFeedbacks = await db
    .select()
    .from(feedbacks)
    .orderBy(desc(feedbacks.createdAt));

  return NextResponse.json(allFeedbacks);
}

// 要望投稿
export async function POST(request: Request) {
  const session = await auth();
  const body = await request.json();
  const { content, pagePath, pageTitle } = body;

  if (!content || !pagePath) {
    return NextResponse.json(
      { error: "Content and pagePath are required" },
      { status: 400 }
    );
  }

  // セッションからユーザー情報を取得
  const userId = session?.user?.id ? parseInt(session.user.id) : null;
  const userName = session?.user?.name || (session?.user as any)?.username || null;

  const [result] = await db
    .insert(feedbacks)
    .values({
      content,
      pagePath,
      pageTitle: pageTitle || null,
      status: "pending",
      likes: 0,
      createdAt: new Date().toISOString(),
      userId,
      userName,
    })
    .returning();

  return NextResponse.json(result);
}
</file>

<file path="src/app/api/meetings/[id]/route.ts">
import { NextResponse } from "next/server";
import { eq } from "drizzle-orm";
import { db } from "@/db";
import { meetings } from "@/db/schema";

export const dynamic = "force-dynamic";

export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const idNum = parseInt(id, 10);
  if (isNaN(idNum)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }
  const [row] = await db.select().from(meetings).where(eq(meetings.id, idNum));
  if (!row) {
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }
  return NextResponse.json(row);
}

export async function PUT(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const idNum = parseInt(id, 10);
  if (isNaN(idNum)) {
    return NextResponse.json({ error: "Invalid ID" }, { status: 400 });
  }
  const [existing] = await db.select().from(meetings).where(eq(meetings.id, idNum));
  if (!existing) {
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }
  const body = await request.json();
  const [updated] = await db
    .update(meetings)
    .set({
      ...(body.title !== undefined && { title: body.title }),
      ...(body.meetingDate !== undefined && { meetingDate: body.meetingDate }),
      ...(body.category !== undefined && { category: body.category }),
      ...(body.content !== undefined && { content: body.content ?? null }),
      ...(body.agenda !== undefined && { agenda: body.agenda ?? null }),
    })
    .where(eq(meetings.id, idNum))
    .returning();
  return NextResponse.json(updated);
}
</file>

<file path="src/app/api/projects/[id]/todos/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { todos } from "@/db/schema";
import { eq, asc } from "drizzle-orm";
import { auth } from "@/auth";

export async function GET(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);
  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }
  const list = await db
    .select()
    .from(todos)
    .where(eq(todos.projectId, projectId))
    .orderBy(asc(todos.dueDate));
  return NextResponse.json(list);
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  const { id } = await params;
  const projectId = Number(id);
  if (isNaN(projectId)) {
    return NextResponse.json({ error: "Invalid project ID" }, { status: 400 });
  }
  const body = await request.json();
  const content = body.content?.trim() ?? "";
  const dueDate = body.dueDate ?? "";
  if (!content || !dueDate) {
    return NextResponse.json(
      { error: "content and dueDate are required" },
      { status: 400 }
    );
  }

  // セッションからユーザー情報を取得
  const userId = session?.user?.id ? parseInt(session.user.id) : null;
  const userName = session?.user?.name || (session?.user as any)?.username || null;

  const [result] = await db
    .insert(todos)
    .values({
      projectId,
      content,
      dueDate,
      createdAt: new Date().toISOString(),
      userId,
      userName,
    })
    .returning();
  return NextResponse.json(result);
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { searchParams } = new URL(request.url);
  const todoId = searchParams.get("todoId");
  if (!todoId) {
    return NextResponse.json({ error: "todoId is required" }, { status: 400 });
  }
  await db.delete(todos).where(eq(todos.id, Number(todoId)));
  return NextResponse.json({ success: true });
}
</file>

<file path="src/app/api/register-initial-user/route.ts">
import { NextResponse } from "next/server";
import { db, initDb } from "@/db";
import { users } from "@/db/schema";
import bcrypt from "bcryptjs";

export async function GET() {
  await initDb();
  // すでにユーザーがいるか確認
  const existingUsers = await db.select().from(users);
  
  if (existingUsers.length > 0) {
    return NextResponse.json({ error: "User already exists" }, { status: 400 });
  }

  // 初期ユーザーの作成
  const hashedPassword = await bcrypt.hash("Energy", 10);
  
  const [newUser] = await db
    .insert(users)
    .values({
      username: "Person",
      name: "管理者",
      password: hashedPassword,
      role: "admin",
    })
    .returning();

  return NextResponse.json({
    message: "Initial user created",
    username: newUser.username,
    password: "Energy (Please change this immediately)"
  });
}
</file>

<file path="src/app/api/todos/[id]/route.ts">
import { NextResponse } from "next/server";
import { eq } from "drizzle-orm";
import { db } from "@/db";
import { todos } from "@/db/schema";

export const dynamic = "force-dynamic";

export async function PATCH(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const todoId = parseInt(id, 10);
  if (isNaN(todoId)) {
    return NextResponse.json({ error: "Invalid todo ID" }, { status: 400 });
  }
  const body = await request.json();
  const updates: { content?: string; dueDate?: string; completedAt?: string | null; completedMemo?: string | null } = {};
  if (body.content !== undefined) updates.content = body.content?.trim() ?? "";
  if (body.dueDate !== undefined) updates.dueDate = body.dueDate;
  if (body.completedAt !== undefined) updates.completedAt = body.completedAt ?? null;
  if (body.completedMemo !== undefined) updates.completedMemo = body.completedMemo ?? null;
  if (Object.keys(updates).length === 0) {
    return NextResponse.json({ error: "No fields to update" }, { status: 400 });
  }
  if (updates.content !== undefined && !updates.content) {
    return NextResponse.json({ error: "content cannot be empty" }, { status: 400 });
  }
  if (updates.dueDate !== undefined && !updates.dueDate) {
    return NextResponse.json({ error: "dueDate is required when updating" }, { status: 400 });
  }
  const [result] = await db
    .update(todos)
    .set(updates)
    .where(eq(todos.id, todoId))
    .returning();
  if (!result) {
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }
  return NextResponse.json(result);
}

export async function DELETE(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const todoId = parseInt(id, 10);
  if (isNaN(todoId)) {
    return NextResponse.json({ error: "Invalid todo ID" }, { status: 400 });
  }
  await db.delete(todos).where(eq(todos.id, todoId));
  return NextResponse.json({ success: true });
}
</file>

<file path="src/app/feedbacks/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useSession } from "next-auth/react";
import {
  ThumbsUp,
  MessageCircle,
  Clock,
  CheckCircle2,
  XCircle,
  Loader2,
  Plus,
  Trash2,
  ChevronDown,
  ChevronRight,
  User
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { cn } from "@/lib/utils";
import type { Feedback } from "@/db/schema";

interface ReplyMessage {
  message: string;
  createdAt: string;
  userId?: number | null;
  userName?: string | null;
}

function parseReplies(repliesStr: string | null): ReplyMessage[] {
  if (!repliesStr) return [];
  try {
    return JSON.parse(repliesStr);
  } catch {
    return [];
  }
}

function formatDate(dateStr: string): string {
  const date = new Date(dateStr);
  const m = date.getMonth() + 1;
  const d = date.getDate();
  const h = date.getHours();
  const min = String(date.getMinutes()).padStart(2, "0");
  return `${m}/${d} ${h}:${min}`;
}

function formatDateShort(dateStr: string): string {
  const date = new Date(dateStr);
  const m = date.getMonth() + 1;
  const d = date.getDate();
  return `${m}/${d}`;
}

const STATUS_CONFIG = {
  pending: {
    label: "未対応",
    icon: Clock,
    color: "bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400",
  },
  in_progress: {
    label: "対応中",
    icon: Loader2,
    color: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400",
  },
  completed: {
    label: "完了",
    icon: CheckCircle2,
    color: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400",
  },
  rejected: {
    label: "見送り",
    icon: XCircle,
    color: "bg-gray-100 text-gray-600 dark:bg-gray-900/30 dark:text-gray-400",
  },
};

export default function FeedbacksPage() {
  const { data: session } = useSession();
  const [feedbacks, setFeedbacks] = useState<Feedback[]>([]);
  const [expandedIds, setExpandedIds] = useState<Set<number>>(new Set());
  const [replyingId, setReplyingId] = useState<number | null>(null);
  const [replyContent, setReplyContent] = useState("");
  const [deleteId, setDeleteId] = useState<number | null>(null);
  const [statusFilter, setStatusFilter] = useState<string>("all");

  const fetchFeedbacks = async () => {
    const res = await fetch("/api/feedbacks");
    if (res.ok) {
      const data = await res.json();
      setFeedbacks(data);
    }
  };

  useEffect(() => {
    fetchFeedbacks();
  }, []);

  const handleLike = async (id: number) => {
    await fetch(`/api/feedbacks/${id}/like`, { method: "POST" });
    fetchFeedbacks();
  };

  const handleStatusChange = async (id: number, status: string) => {
    await fetch(`/api/feedbacks/${id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ status }),
    });
    fetchFeedbacks();
  };

  const handleReply = async (feedback: Feedback) => {
    if (!replyContent.trim()) return;

    // セッションからユーザー情報を取得
    const userId = session?.user?.id ? parseInt(session.user.id) : null;
    const userName = session?.user?.name || (session?.user as any)?.username || null;

    const currentReplies = parseReplies(feedback.replies);
    const newReplies = [
      ...currentReplies,
      {
        message: replyContent.trim(),
        createdAt: new Date().toISOString(),
        userId,
        userName,
      },
    ];

    await fetch(`/api/feedbacks/${feedback.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ replies: JSON.stringify(newReplies) }),
    });

    setReplyContent("");
    setReplyingId(null);
    fetchFeedbacks();
  };

  const handleDelete = async () => {
    if (deleteId === null) return;
    await fetch(`/api/feedbacks/${deleteId}`, { method: "DELETE" });
    setDeleteId(null);
    fetchFeedbacks();
  };

  const toggleExpand = (id: number) => {
    const newSet = new Set(expandedIds);
    if (newSet.has(id)) {
      newSet.delete(id);
    } else {
      newSet.add(id);
    }
    setExpandedIds(newSet);
  };

  const filteredFeedbacks = feedbacks.filter((f) => {
    if (statusFilter === "all") return true;
    return f.status === statusFilter;
  });

  const statusCounts = {
    all: feedbacks.length,
    pending: feedbacks.filter((f) => f.status === "pending").length,
    in_progress: feedbacks.filter((f) => f.status === "in_progress").length,
    completed: feedbacks.filter((f) => f.status === "completed").length,
    rejected: feedbacks.filter((f) => f.status === "rejected").length,
  };

  return (
    <div className="p-6 max-w-5xl mx-auto space-y-6">
      {/* ヘッダー */}
      <div>
        <h1 className="text-2xl font-bold">要望</h1>
        <p className="text-sm text-muted-foreground">
          ユーザーからのフィードバック
        </p>
      </div>

      {/* ステータスフィルター */}
      <div className="flex flex-wrap gap-2">
        {[
          { key: "all", label: "すべて", icon: null, color: "" },
          { key: "pending", label: "未対応", icon: Clock, color: "text-yellow-600" },
          { key: "in_progress", label: "対応中", icon: Loader2, color: "text-blue-600" },
          { key: "completed", label: "完了", icon: CheckCircle2, color: "text-green-600" },
          { key: "rejected", label: "見送り", icon: XCircle, color: "text-gray-500" },
        ].map(({ key, label, icon: Icon, color }) => (
          <Button
            key={key}
            variant={statusFilter === key ? "default" : "outline"}
            size="sm"
            onClick={() => setStatusFilter(key)}
            className={cn("h-9 text-sm px-3", statusFilter !== key && color)}
          >
            {Icon && <Icon className="h-4 w-4 mr-1.5" />}
            {label} ({statusCounts[key as keyof typeof statusCounts]})
          </Button>
        ))}
      </div>

      {/* 要望リスト */}
      {filteredFeedbacks.length === 0 ? (
        <Card>
          <CardContent className="py-12 text-center text-base text-muted-foreground">
            要望はまだありません
          </CardContent>
        </Card>
      ) : (
        <div className="space-y-3">
          {filteredFeedbacks.map((feedback) => {
            const statusConfig = STATUS_CONFIG[feedback.status as keyof typeof STATUS_CONFIG];
            const StatusIcon = statusConfig.icon;
            const replies = parseReplies(feedback.replies);
            const isExpanded = expandedIds.has(feedback.id);

            return (
              <Card key={feedback.id} className="overflow-hidden">
                <CardContent className="p-0">
                  {/* メインコンテンツ */}
                  <div className="p-4">
                    <div className="flex items-start gap-3">
                      {/* 展開ボタン */}
                      <button
                        onClick={() => toggleExpand(feedback.id)}
                        className={cn(
                          "mt-1 p-1 rounded hover:bg-muted transition-colors",
                          replies.length === 0 && "invisible"
                        )}
                      >
                        {isExpanded ? (
                          <ChevronDown className="h-4 w-4" />
                        ) : (
                          <ChevronRight className="h-4 w-4" />
                        )}
                      </button>

                      {/* コンテンツ */}
                      <div className="flex-1 min-w-0">
                        <div className="flex items-start justify-between gap-3">
                          <p className="text-base leading-relaxed">{feedback.content}</p>
                          <Badge className={cn("shrink-0 text-xs px-2 py-0.5", statusConfig.color)}>
                            <StatusIcon className={cn("h-3.5 w-3.5 mr-1", feedback.status === "in_progress" && "animate-spin")} />
                            {statusConfig.label}
                          </Badge>
                        </div>

                        {/* メタ情報 */}
                        <div className="flex items-center gap-3 mt-2 text-xs text-muted-foreground">
                          {(feedback as any).userName && (
                            <span className="flex items-center gap-1">
                              <User className="h-3.5 w-3.5" />
                              {(feedback as any).userName}
                            </span>
                          )}
                          <span>{formatDate(feedback.createdAt)}</span>
                          <span className="px-2 py-1 rounded bg-muted text-xs">
                            {feedback.pageTitle || feedback.pagePath}
                          </span>
                          {replies.length > 0 && (
                            <span className="flex items-center gap-1">
                              <MessageCircle className="h-3.5 w-3.5" />
                              {replies.length}
                            </span>
                          )}
                        </div>
                      </div>

                      {/* アクション */}
                      <div className="flex items-center gap-1 shrink-0">
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-8 px-2"
                          onClick={() => handleLike(feedback.id)}
                        >
                          <ThumbsUp className="h-4 w-4 mr-1" />
                          <span className="text-sm">{feedback.likes}</span>
                        </Button>
                        <Select
                          value={feedback.status}
                          onValueChange={(value) => handleStatusChange(feedback.id, value)}
                        >
                          <SelectTrigger className="h-8 w-24 text-xs px-2">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="pending" className="text-sm">未対応</SelectItem>
                            <SelectItem value="in_progress" className="text-sm">対応中</SelectItem>
                            <SelectItem value="completed" className="text-sm">完了</SelectItem>
                            <SelectItem value="rejected" className="text-sm">見送り</SelectItem>
                          </SelectContent>
                        </Select>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="h-8 w-8 text-destructive hover:text-destructive"
                          onClick={() => setDeleteId(feedback.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>
                  </div>

                  {/* 返信ツリー */}
                  {isExpanded && replies.length > 0 && (
                    <div className="border-t bg-muted/30 px-4 py-3">
                      <div className="ml-6 space-y-2">
                        {replies.map((reply, idx) => (
                          <div key={idx} className="flex items-start gap-2">
                            <div className="flex flex-col items-center">
                              <div className="w-2 h-2 rounded-full bg-primary mt-2" />
                              {idx < replies.length - 1 && (
                                <div className="w-0.5 flex-1 bg-border min-h-[20px]" />
                              )}
                            </div>
                            <div className="flex-1 p-2 rounded bg-background border text-sm">
                              <p>{reply.message}</p>
                              <div className="flex items-center gap-2 text-xs text-muted-foreground mt-1">
                                {reply.userName && (
                                  <span className="flex items-center gap-1">
                                    <User className="h-3 w-3" />
                                    {reply.userName}
                                  </span>
                                )}
                                <span>{formatDateShort(reply.createdAt)}</span>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* 返信追加ボタン */}
                  <div className="border-t px-4 py-2 flex justify-end">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-7 text-xs px-2"
                      onClick={() => {
                        setReplyingId(feedback.id);
                        if (!expandedIds.has(feedback.id)) {
                          toggleExpand(feedback.id);
                        }
                      }}
                    >
                      <Plus className="h-3.5 w-3.5 mr-1" />
                      返信
                    </Button>
                  </div>
                </CardContent>
              </Card>
            );
          })}
        </div>
      )}

      {/* 返信ダイアログ */}
      <Dialog open={replyingId !== null} onOpenChange={() => setReplyingId(null)}>
        <DialogContent className="max-w-lg">
          <DialogHeader>
            <DialogTitle className="text-lg">返信を追加</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <Textarea
              value={replyContent}
              onChange={(e) => setReplyContent(e.target.value)}
              placeholder="対応状況やコメントを入力..."
              rows={4}
              className="text-base"
            />
            <div className="flex justify-end gap-3">
              <Button variant="outline" onClick={() => setReplyingId(null)}>
                キャンセル
              </Button>
              <Button
                onClick={() => {
                  const feedback = feedbacks.find((f) => f.id === replyingId);
                  if (feedback) handleReply(feedback);
                }}
                disabled={!replyContent.trim()}
              >
                追加
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* 削除確認ダイアログ */}
      <AlertDialog open={deleteId !== null} onOpenChange={() => setDeleteId(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="text-lg">要望を削除</AlertDialogTitle>
            <AlertDialogDescription className="text-base">
              この要望を削除しますか？
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>キャンセル</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              削除
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="src/app/legal/page.tsx">
import { Suspense } from "react";
import { GeoSearchView } from "@/components/GeoSearchView";

function LegalPageContent() {
  return <GeoSearchView />;
}

export default function LegalPage() {
  return (
    <Suspense fallback={<div className="min-h-screen bg-background flex items-center justify-center text-muted-foreground">読み込み中...</div>}>
      <LegalPageContent />
    </Suspense>
  );
}
</file>

<file path="src/app/map/page.tsx">
"use client";

import { useState, useMemo } from "react";
import { MapPin, ExternalLink } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  parseCoordinateString,
  normalizeCoordinateString,
} from "@/lib/coordinates";

function getMappleUrl(coords: string | null): string | null {
  const parsed = coords ? parseCoordinateString(coords) : null;
  if (!parsed) return null;
  return `https://labs.mapple.com/mapplexml.html#16/${parsed.lat}/${parsed.lon}`;
}

function getGoogleMapsUrl(coords: string | null, address: string | null): string | null {
  if (coords) {
    const parsed = parseCoordinateString(coords);
    if (parsed) {
      return `https://www.google.com/maps?q=${parsed.lat},${parsed.lon}`;
    }
  }
  if (address?.trim()) {
    return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(address.trim())}`;
  }
  return null;
}

function getHazardMapUrl(coords: string | null): string | null {
  const parsed = coords ? parseCoordinateString(coords) : null;
  if (!parsed) return null;
  return `https://disaportal.gsi.go.jp/maps/?ll=${parsed.lat},${parsed.lon}&z=16&base=ort&vs=c1j0l0u0t0h0z0`;
}

export default function MapPage() {
  const [address, setAddress] = useState("");
  const [coordinates, setCoordinates] = useState("");

  const hasValidCoords = useMemo(
    () => parseCoordinateString(coordinates) !== null,
    [coordinates]
  );

  const handleCoordinatesChange = (value: string) => {
    setCoordinates(value);
  };

  const handleCoordinatesBlur = () => {
    const normalized = normalizeCoordinateString(coordinates);
    if (normalized) setCoordinates(normalized);
  };

  const mappleUrl = getMappleUrl(hasValidCoords ? coordinates : null);
  const googleMapsUrl = getGoogleMapsUrl(hasValidCoords ? coordinates : null, address.trim() ? address : null);
  const hazardMapUrl = getHazardMapUrl(hasValidCoords ? coordinates : null);

  const googleEnabled = !!googleMapsUrl;
  const coordsOnlyEnabled = hasValidCoords;

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto max-w-2xl py-10">
        <div className="space-y-6">
          <div className="flex items-center gap-2">
            <MapPin className="h-5 w-5 text-muted-foreground" />
            <h1 className="text-xl font-semibold text-foreground">マップ</h1>
          </div>
          <p className="text-sm text-muted-foreground">
            おおよその住所を入力したあと、詳しい座標を追加できます。両方入力した場合は座標で地図を開きます。
          </p>

          {/* 1. おおよその場所（現地住所） */}
          <div className="space-y-2">
            <div className="flex items-baseline gap-2">
              <span className="text-xs font-medium text-muted-foreground uppercase tracking-wider">Step 1</span>
              <Label htmlFor="map-address" className="text-base font-medium text-foreground">
                おおよその場所（現地住所）
              </Label>
            </div>
            <p className="text-xs text-muted-foreground">
              大まかな場所の把握用。ここだけ入力してもGoogle Mapで開けます。
            </p>
            <Input
              id="map-address"
              value={address}
              onChange={(e) => setAddress(e.target.value)}
              placeholder="例: 広島県広島市安佐北区..."
              className="w-full h-11 text-base"
            />
          </div>

          {/* 2. 正確な位置（座標） */}
          <div className="space-y-2 pt-2 border-t border-border">
            <div className="flex items-baseline gap-2 pt-4">
              <span className="text-xs font-medium text-muted-foreground uppercase tracking-wider">Step 2</span>
              <Label htmlFor="map-coordinates" className="text-base font-medium text-foreground">
                正確な位置（座標）
              </Label>
            </div>
            <p className="text-xs text-muted-foreground">
              詳しい座標を入力すると、MAPPLE・ハザードも開けます。住所と両方ある場合は座標で開きます。
            </p>
            <Input
              id="map-coordinates"
              value={coordinates}
              onChange={(e) => handleCoordinatesChange(e.target.value)}
              onBlur={handleCoordinatesBlur}
              placeholder="例: 34.3963, 132.4596 または 34.39/132.45"
              className="w-full font-mono text-base h-11"
            />
          </div>

          {/* 住所 or 座標で開く = Google Map のみ */}
          <div className="space-y-3">
            <h2 className="text-base font-semibold text-foreground">
              住所または座標で開く
            </h2>
            <a
              href={googleMapsUrl ?? "#"}
              target="_blank"
              rel="noopener noreferrer"
              onClick={(e) => !googleMapsUrl && e.preventDefault()}
              className={`flex items-center justify-between gap-4 w-full px-4 py-3 rounded-lg border transition-colors ${
                googleEnabled
                  ? "bg-card hover:bg-muted border-border cursor-pointer"
                  : "opacity-40 cursor-not-allowed pointer-events-none border-border"
              }`}
            >
              <span className="font-medium">Google Map</span>
              <ExternalLink className="h-4 w-4 shrink-0 text-muted-foreground" />
            </a>
          </div>

          {/* 座標で開く = MAPPLE・ハザード */}
          <div className="space-y-3">
            <h2 className="text-base font-semibold text-foreground">
              座標で開く
            </h2>
            <div className="grid gap-2 sm:grid-cols-2">
              <a
                href={mappleUrl ?? "#"}
                target="_blank"
                rel="noopener noreferrer"
                onClick={(e) => !mappleUrl && e.preventDefault()}
                className={`flex items-center justify-between gap-4 w-full px-4 py-3 rounded-lg border transition-colors ${
                  coordsOnlyEnabled
                    ? "bg-card hover:bg-muted border-border cursor-pointer"
                    : "opacity-40 cursor-not-allowed pointer-events-none border-border"
                }`}
              >
                <span className="font-medium">MAPPLE</span>
                <ExternalLink className="h-4 w-4 shrink-0 text-muted-foreground" />
              </a>
              <a
                href={hazardMapUrl ?? "#"}
                target="_blank"
                rel="noopener noreferrer"
                onClick={(e) => !hazardMapUrl && e.preventDefault()}
                className={`flex items-center justify-between gap-4 w-full px-4 py-3 rounded-lg border transition-colors ${
                  coordsOnlyEnabled
                    ? "bg-card hover:bg-muted border-border cursor-pointer"
                    : "opacity-40 cursor-not-allowed pointer-events-none border-border"
                }`}
              >
                <span className="font-medium">ハザード</span>
                <ExternalLink className="h-4 w-4 shrink-0 text-muted-foreground" />
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/meetings/[id]/MeetingMinutesSection.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Pencil, Loader2, Eye, Edit3 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";

interface MeetingMinutesSectionProps {
  meetingId: number;
  initialContent: string | null;
}

export function MeetingMinutesSection({ meetingId, initialContent }: MeetingMinutesSectionProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState(false);
  const [content, setContent] = useState(initialContent ?? "");
  const [saving, setSaving] = useState(false);
  const [showPreview, setShowPreview] = useState(false);

  const handleSave = async () => {
    setSaving(true);
    try {
      const res = await fetch(`/api/meetings/${meetingId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: content || null }),
      });
      if (!res.ok) throw new Error("保存に失敗しました");
      setIsEditing(false);
      setShowPreview(false);
      router.refresh();
    } catch (e) {
      alert(e instanceof Error ? e.message : "保存に失敗しました");
    } finally {
      setSaving(false);
    }
  };

  const handleCancel = () => {
    setContent(initialContent ?? "");
    setIsEditing(false);
    setShowPreview(false);
  };

  return (
    <div className="rounded-xl border border-border bg-card p-6">
      <div className="flex items-center justify-between gap-2 mb-3">
        <h2 className="text-sm font-medium text-muted-foreground">議事録</h2>
        {!isEditing && (
          <Button
            variant="ghost"
            size="icon"
            className="h-8 w-8 shrink-0"
            onClick={() => setIsEditing(true)}
            aria-label="議事録を編集"
          >
            <Pencil className="h-4 w-4" />
          </Button>
        )}
      </div>
      {isEditing ? (
        <div className="space-y-3">
          {/* 編集/プレビュー切り替えタブ */}
          <div className="flex items-center gap-1 border-b border-border pb-2">
            <Button
              variant={!showPreview ? "secondary" : "ghost"}
              size="sm"
              className="h-7 text-xs"
              onClick={() => setShowPreview(false)}
            >
              <Edit3 className="h-3 w-3 mr-1" />
              編集
            </Button>
            <Button
              variant={showPreview ? "secondary" : "ghost"}
              size="sm"
              className="h-7 text-xs"
              onClick={() => setShowPreview(true)}
            >
              <Eye className="h-3 w-3 mr-1" />
              プレビュー
            </Button>
          </div>

          {showPreview ? (
            <div className="min-h-[200px] p-3 border border-border rounded-md bg-muted/30">
              <div className="prose prose-sm dark:prose-invert max-w-none prose-headings:mt-4 prose-headings:mb-2 prose-p:my-2 prose-ul:my-2 prose-ol:my-2 prose-li:my-0.5 prose-pre:bg-muted prose-pre:border prose-pre:border-border prose-code:bg-muted prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none">
                {content ? (
                  <ReactMarkdown remarkPlugins={[remarkGfm]}>
                    {content}
                  </ReactMarkdown>
                ) : (
                  <span className="text-muted-foreground">（内容なし）</span>
                )}
              </div>
            </div>
          ) : (
            <>
              <Textarea
                value={content}
                onChange={(e) => setContent(e.target.value)}
                placeholder="議事録の内容を入力してください（Markdown記法対応）"
                className="min-h-[200px] resize-y font-mono text-sm"
                disabled={saving}
              />
              {/* Markdownヒント */}
              <div className="text-xs text-muted-foreground space-y-2 p-3 bg-muted/30 rounded-md">
                <p className="font-medium">Markdown記法が使えます:</p>
                <div className="grid grid-cols-2 gap-x-4 gap-y-1">
                  <span><code className="bg-muted px-1 rounded"># 見出し1</code></span>
                  <span><code className="bg-muted px-1 rounded">## 見出し2</code></span>
                  <span><code className="bg-muted px-1 rounded">### 見出し3</code></span>
                  <span><code className="bg-muted px-1 rounded">**太字**</code></span>
                  <span><code className="bg-muted px-1 rounded">*斜体*</code></span>
                  <span><code className="bg-muted px-1 rounded">~~取り消し線~~</code></span>
                  <span><code className="bg-muted px-1 rounded">- リスト</code></span>
                  <span><code className="bg-muted px-1 rounded">1. 番号付き</code></span>
                  <span><code className="bg-muted px-1 rounded">`コード`</code></span>
                  <span><code className="bg-muted px-1 rounded">[リンク](URL)</code></span>
                  <span><code className="bg-muted px-1 rounded">&gt; 引用</code></span>
                  <span><code className="bg-muted px-1 rounded">- [ ] タスク</code></span>
                </div>
                <div className="mt-2 pt-2 border-t border-border/50">
                  <p className="font-medium mb-1">テーブル記法:</p>
                  <pre className="bg-muted p-2 rounded text-xs overflow-x-auto">| 列1 | 列2 | 列3 |{"\n"}|-----|-----|-----|{"\n"}| A   | B   | C   |</pre>
                </div>
              </div>
            </>
          )}

          <div className="flex gap-2">
            <Button size="sm" onClick={handleSave} disabled={saving}>
              {saving ? <Loader2 className="h-4 w-4 animate-spin" /> : "保存"}
            </Button>
            <Button size="sm" variant="outline" onClick={handleCancel} disabled={saving}>
              キャンセル
            </Button>
          </div>
        </div>
      ) : (
        <div className="prose prose-sm dark:prose-invert max-w-none prose-headings:mt-4 prose-headings:mb-2 prose-p:my-2 prose-ul:my-2 prose-ol:my-2 prose-li:my-0.5 prose-pre:bg-muted prose-pre:border prose-pre:border-border prose-code:bg-muted prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-code:before:content-none prose-code:after:content-none">
          {content ? (
            <ReactMarkdown remarkPlugins={[remarkGfm]}>
              {content}
            </ReactMarkdown>
          ) : (
            <span className="text-muted-foreground">（内容なし）</span>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/meetings/[id]/page.tsx">
import { notFound } from "next/navigation";
import Link from "next/link";
import { eq } from "drizzle-orm";
import { db } from "@/db";
import { meetings } from "@/db/schema";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";
import { format } from "date-fns";
import { ja } from "date-fns/locale";
import { MeetingMinutesSection } from "./MeetingMinutesSection";

interface MeetingDetailPageProps {
  params: Promise<{ id: string }>;
}

export const dynamic = "force-dynamic";

export default async function MeetingDetailPage({ params }: MeetingDetailPageProps) {
  const { id } = await params;
  const idNum = parseInt(id, 10);
  if (isNaN(idNum)) notFound();

  const [meeting] = await db.select().from(meetings).where(eq(meetings.id, idNum));
  if (!meeting) notFound();

  const displayDate = meeting.meetingDate
    ? format(new Date(meeting.meetingDate + "T00:00:00"), "yyyy年M月d日", { locale: ja })
    : "-";

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto max-w-4xl py-10">
        <div className="space-y-6">
          <div className="flex items-center gap-4">
            <Button variant="ghost" size="icon" asChild>
              <Link href="/meetings">
                <ArrowLeft className="h-4 w-4" />
              </Link>
            </Button>
            <div className="flex-1">
              <h1 className="text-xl font-semibold">{meeting.title}</h1>
              <p className="text-sm text-muted-foreground mt-1">
                {displayDate} ／ {meeting.category}
              </p>
            </div>
          </div>

          <MeetingMinutesSection meetingId={meeting.id} initialContent={meeting.content} />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/todo/page.tsx">
import { db } from "@/db";
import { todos, projects } from "@/db/schema";
import { eq, asc } from "drizzle-orm";
import { HomeTodosView } from "@/components/HomeTodosView";

export const dynamic = "force-dynamic";

export default async function TodoPage() {
  const rows = await db
    .select({
      id: todos.id,
      projectId: todos.projectId,
      content: todos.content,
      dueDate: todos.dueDate,
      createdAt: todos.createdAt,
      completedAt: todos.completedAt,
      completedMemo: todos.completedMemo,
      userId: todos.userId,
      userName: todos.userName,
      managementNumber: projects.managementNumber,
    })
    .from(todos)
    .leftJoin(projects, eq(todos.projectId, projects.id))
    .orderBy(asc(todos.dueDate));

  return <HomeTodosView initialTodos={rows} showCreateForm />;
}
</file>

<file path="src/app/tools/filename/page.tsx">
"use client";

import * as React from "react";
import Link from "next/link";
import { ArrowLeft, Check, Copy, Calendar as CalendarIcon } from "lucide-react";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

const DOC_TYPES = [
  "土地売買契約書",
  "身分証明書",
  "印鑑登録証明書",
  "固定資産評価証明書",
  "登記識別情報通知",
  "登記申請書",
] as const;

const ID_TYPES = [
  "運転免許証",
  "マイナンバーカード",
] as const;

function sanitizeForFilename(s: string) {
  return s
    .trim()
    .replace(/\s+/g, "") // 空白除去
    .replace(/[\\\/:*?"<>|]/g, "_"); // Windows禁止文字対策
}

function formatYyyyMd(date: Date | undefined) {
  if (!date) return "";
  const y = date.getFullYear();
  const m = date.getMonth() + 1;
  const d = date.getDate();
  return `${y}.${m}.${d}`;
}

export default function FilenamePage() {
  const [docType, setDocType] = React.useState<string>("");
  const [name, setName] = React.useState<string>("");
  const [date, setDate] = React.useState<Date | undefined>(undefined);
  const [idType, setIdType] = React.useState<string>("");
  const [isCalendarOpen, setIsCalendarOpen] = React.useState(false);
  const [copied, setCopied] = React.useState(false);

  // 書類が変更されたら不要なステートをクリア
  React.useEffect(() => {
    if (docType === "身分証明書" || docType === "登記識別情報通知") {
      setDate(undefined);
    } else {
      setIdType("");
    }
  }, [docType]);

  const filename = React.useMemo(() => {
    const nRaw = sanitizeForFilename(name);
    const t = sanitizeForFilename(docType);
    if (!nRaw || !t) return "";
    const n = nRaw.endsWith("様") ? nRaw : `${nRaw}様`;

    // 身分証明書の場合
    if (t === "身分証明書") {
      if (!idType) return "";
      return `【${t}】${n}_${idType}`;
    }

    // 登記識別情報通知の場合（日付不要）
    if (t === "登記識別情報通知") {
      return `【${t}】${n}`;
    }

    // その他の書類の場合（日付が必要）
    const d = formatYyyyMd(date);
    if (!d) return "";
    const prefix = t === "土地売買契約書" ? "P番号_" : "";
    return `【${t}】${prefix}${n}_${d}`;
  }, [docType, name, date, idType]);

  const onCopy = async () => {
    if (!filename) return;
    await navigator.clipboard.writeText(filename);
    setCopied(true);
    setTimeout(() => setCopied(false), 1500);
  };

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto flex min-h-screen max-w-5xl flex-col items-center justify-center py-10">
        <div className="w-full space-y-4">
          <div className="flex items-center gap-3">
            <Button
              asChild
              variant="ghost"
              size="icon"
              aria-label="ツール一覧に戻る"
              title="戻る"
            >
              <Link href="/tools">
                <ArrowLeft className="h-4 w-4" />
              </Link>
            </Button>
            <div className="space-y-1">
              <h1 className="text-xl font-semibold">ファイル名生成</h1>
              <p className="text-sm text-muted-foreground">
                書類・氏名・必要項目を入力するとファイル名を生成します
              </p>
            </div>
          </div>

          {/* 条件入力（3カード横並び） */}
          <div className="grid grid-cols-1 gap-4 md:grid-cols-3">
            {/* ① 書類プルダウン */}
            <Card>
              <CardHeader>
                <CardTitle>書類</CardTitle>
              </CardHeader>
              <CardContent>
                <Select value={docType} onValueChange={setDocType}>
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="書類を選択" />
                  </SelectTrigger>
                  <SelectContent>
                    {DOC_TYPES.map((t) => (
                      <SelectItem key={t} value={t}>
                        {t}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </CardContent>
            </Card>

            {/* ② 氏名入力欄 */}
            <Card>
              <CardHeader>
                <CardTitle>氏名</CardTitle>
              </CardHeader>
              <CardContent>
                <Input
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="例: 山田太郎"
                />
              </CardContent>
            </Card>

            {/* ③ 動的カード（身分証明書の場合は証明書種類、登記識別情報通知は不要、その他は日付） */}
            {docType === "身分証明書" ? (
              <Card>
                <CardHeader>
                  <CardTitle>証明書種類</CardTitle>
                </CardHeader>
                <CardContent>
                  <Select value={idType} onValueChange={setIdType}>
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="種類を選択" />
                    </SelectTrigger>
                    <SelectContent>
                      {ID_TYPES.map((t) => (
                        <SelectItem key={t} value={t}>
                          {t}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </CardContent>
              </Card>
            ) : docType === "登記識別情報通知" ? null : (
              <Card>
                <CardHeader>
                  <CardTitle>日付</CardTitle>
                </CardHeader>
                <CardContent>
                  <Popover open={isCalendarOpen} onOpenChange={setIsCalendarOpen}>
                    <PopoverTrigger asChild>
                      <Button
                        type="button"
                        variant="outline"
                        className="w-full justify-start gap-2 font-normal"
                      >
                        <CalendarIcon className="h-4 w-4" />
                        {date ? (
                          <span className="font-mono">{formatYyyyMd(date)}</span>
                        ) : (
                          <span className="text-muted-foreground">日付を選択</span>
                        )}
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        required
                        selected={date}
                        onSelect={(d) => {
                          // 選択したら必ず閉じる（requiredなので通常undefinedにはならない）
                          if (d) setDate(d);
                          setIsCalendarOpen(false);
                        }}
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                </CardContent>
              </Card>
            )}
          </div>

          {/* 生成結果（カード無し / ファイル名＋コピーアイコンのみ） */}
          <div className="flex items-center justify-between gap-3 rounded-2xl border border-border bg-card px-4 py-3">
            <p className="min-w-0 flex-1 truncate font-mono text-sm text-card-foreground">
              {filename || "条件を入力するとここに生成されます"}
            </p>
            <Button
              type="button"
              variant="ghost"
              size="icon"
              onClick={onCopy}
              disabled={!filename}
              aria-label="ファイル名をコピー"
              title="コピー"
            >
              {copied ? (
                <Check className="h-4 w-4 text-green-500" />
              ) : (
                <Copy className="h-4 w-4" />
              )}
            </Button>
          </div>

          <p className="text-xs text-muted-foreground">
            形式:{" "}
            <span className="font-mono">
              {docType === "身分証明書"
                ? "【書類】氏名様_証明書種類"
                : docType === "登記識別情報通知"
                ? "【書類】氏名様"
                : "【書類】氏名様_YYYY.M.D"}
            </span>
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/auth.config.ts">
import type { NextAuthConfig } from "next-auth";
import Credentials from "next-auth/providers/credentials";

export const authConfig = {
  pages: {
    signIn: "/login",
  },
  callbacks: {
    authorized({ auth, request: { nextUrl } }) {
      const isLoggedIn = !!auth?.user;
      const isLoginPage = nextUrl.pathname === "/login";
      const isPublicApi = nextUrl.pathname.startsWith("/api/auth") || 
                         nextUrl.pathname.startsWith("/api/register-initial-user");

      if (isLoginPage) {
        if (isLoggedIn) return Response.redirect(new URL("/", nextUrl));
        return true;
      }

      if (!isLoggedIn && !isPublicApi) {
        return false; // Redirect to login
      }

      return true;
    },
    async session({ session, token }) {
      if (token.sub && session.user) {
        session.user.id = token.sub;
      }
      if (token.username && session.user) {
        (session.user as any).username = token.username;
      }
      return session;
    },
    async jwt({ token, user }) {
      if (user) {
        token.username = (user as any).username;
      }
      return token;
    },
  },
  providers: [], // Add providers with an empty array for now
} satisfies NextAuthConfig;
</file>

<file path="src/components/FeedbackInput.tsx">
"use client";

import { useState } from "react";
import { usePathname } from "next/navigation";
import { Send, MessageSquarePlus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";

// ページパスからタイトルを取得
function getPageTitle(path: string): string {
  if (path.startsWith("/projects/")) return "案件詳細";
  if (path === "/projects") return "案件一覧";
  if (path === "/todo") return "TODO";
  if (path === "/todos") return "タイムライン";
  if (path === "/meetings") return "会議";
  if (path.startsWith("/meetings/")) return "会議詳細";
  if (path === "/schedule") return "スケジュール";
  if (path === "/map") return "地図";
  if (path === "/legal") return "法令検索";
  if (path === "/tools") return "ツール";
  if (path === "/feedbacks") return "要望";
  return path;
}

export function FeedbackInput() {
  const pathname = usePathname();
  const [isOpen, setIsOpen] = useState(false);
  const [content, setContent] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);

  // 要望画面では表示しない
  if (pathname === "/feedbacks") {
    return null;
  }

  const handleSubmit = async () => {
    if (!content.trim()) return;

    setIsSubmitting(true);
    try {
      const res = await fetch("/api/feedbacks", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          content: content.trim(),
          pagePath: pathname,
          pageTitle: getPageTitle(pathname),
        }),
      });

      if (res.ok) {
        setContent("");
        setIsOpen(false);
        setShowSuccess(true);
        setTimeout(() => setShowSuccess(false), 3000);
      }
    } catch (error) {
      console.error("Failed to submit feedback:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <>
      {/* 成功メッセージ */}
      {showSuccess && (
        <div className="fixed bottom-20 left-1/2 -translate-x-1/2 z-50 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg text-sm animate-in fade-in slide-in-from-bottom-2">
          要望を送信しました
        </div>
      )}

      {/* フィードバック入力エリア - サイドバー(w-72)を避ける */}
      <div className="fixed bottom-0 left-72 right-0 z-40 border-t bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-4xl mx-auto px-4 py-3">
          {isOpen ? (
            <div className="space-y-3 animate-in fade-in slide-in-from-bottom-2 duration-200">
              <div className="flex items-start gap-2">
                <Textarea
                  value={content}
                  onChange={(e) => setContent(e.target.value)}
                  placeholder="この画面について改善点やご意見をお聞かせください..."
                  className="min-h-[80px] resize-none flex-1"
                  autoFocus
                />
              </div>
              <div className="flex items-center justify-between">
                <p className="text-xs text-muted-foreground">
                  送信元: {getPageTitle(pathname)}
                </p>
                <div className="flex gap-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => {
                      setIsOpen(false);
                      setContent("");
                    }}
                  >
                    キャンセル
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleSubmit}
                    disabled={!content.trim() || isSubmitting}
                  >
                    <Send className="h-4 w-4 mr-2" />
                    送信
                  </Button>
                </div>
              </div>
            </div>
          ) : (
            <button
              onClick={() => setIsOpen(true)}
              className={cn(
                "w-full flex items-center gap-3 px-4 py-3 rounded-xl",
                "bg-muted/50 hover:bg-muted transition-colors",
                "text-muted-foreground hover:text-foreground",
                "text-left text-sm"
              )}
            >
              <MessageSquarePlus className="h-5 w-5 shrink-0" />
              <span>この画面についてフィードバックを送信...</span>
            </button>
          )}
        </div>
      </div>

      {/* 下部のスペース確保 */}
      <div className="h-20" />
    </>
  );
}
</file>

<file path="src/components/HomeSearchView.tsx">
"use client";

import { useState, useCallback, useEffect, useRef, useMemo } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import {
  Search,
  ArrowRight,
  Sparkles,
  FolderKanban,
  CheckSquare,
  MessageSquare,
  Loader2,
  AlertTriangle,
  CalendarClock,
  CalendarDays,
  Activity,
  Clock,
  ChevronRight,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";

interface SearchResult {
  type: "project" | "todo" | "meeting";
  id: number;
  title: string;
  subtitle?: string;
  href: string;
}

interface DashboardTodo {
  id: number;
  content: string;
  dueDate: string;
  projectId: number;
  managementNumber: string;
}

interface DashboardProject {
  id: number;
  managementNumber: string;
  client?: string;
  alertCount?: number;
  updatedAt?: string;
}

interface DashboardData {
  overdueTodos: { count: number; items: DashboardTodo[] };
  todayTodos: { count: number; items: DashboardTodo[] };
  thisWeekTodos: { count: number; items: DashboardTodo[] };
  projectAlerts: { count: number; totalAlerts: number; items: DashboardProject[] };
  activeProjects: { count: number; items: DashboardProject[] };
  recentProjects: { items: DashboardProject[] };
}

// デバウンス用のカスタムフック
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

export function HomeSearchView() {
  const router = useRouter();
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // ダッシュボード用state
  const [dashboard, setDashboard] = useState<DashboardData | null>(null);
  const [isDashboardLoading, setIsDashboardLoading] = useState(true);

  // 300msのデバウンス
  const debouncedQuery = useDebounce(query, 300);

  // ダッシュボードデータ取得
  useEffect(() => {
    const fetchDashboard = async () => {
      try {
        const res = await fetch("/api/dashboard");
        if (res.ok) {
          const data = await res.json();
          setDashboard(data);
        }
      } catch (err) {
        console.error("ダッシュボード取得エラー:", err);
      } finally {
        setIsDashboardLoading(false);
      }
    };
    fetchDashboard();
  }, []);

  // デバウンスされたクエリで検索を実行
  useEffect(() => {
    const search = async () => {
      if (!debouncedQuery.trim()) {
        setResults([]);
        return;
      }

      setIsSearching(true);

      try {
        const res = await fetch(`/api/search?q=${encodeURIComponent(debouncedQuery.trim())}`);
        if (res.ok) {
          const data = await res.json();
          setResults(data);
        }
      } catch (err) {
        console.error("検索エラー:", err);
      } finally {
        setIsSearching(false);
      }
    };

    search();
  }, [debouncedQuery]);

  // 結果をカテゴリごとに分類
  const categorizedResults = useMemo(() => {
    const projects = results.filter(r => r.type === "project");
    const todos = results.filter(r => r.type === "todo");
    const meetings = results.filter(r => r.type === "meeting");
    return { projects, todos, meetings };
  }, [results]);

  // フラットな結果リスト（キーボードナビゲーション用）
  const flatResults = useMemo(() => {
    return [
      ...categorizedResults.projects,
      ...categorizedResults.todos,
      ...categorizedResults.meetings,
    ];
  }, [categorizedResults]);

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "ArrowDown") {
      e.preventDefault();
      setSelectedIndex(prev => Math.min(prev + 1, flatResults.length - 1));
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      setSelectedIndex(prev => Math.max(prev - 1, -1));
    } else if (e.key === "Enter" && !e.shiftKey && !e.nativeEvent.isComposing) {
      e.preventDefault();
      if (selectedIndex >= 0 && flatResults[selectedIndex]) {
        router.push(flatResults[selectedIndex].href);
      } else if (flatResults.length > 0) {
        router.push(flatResults[0].href);
      }
    } else if (e.key === "Escape") {
      setIsFocused(false);
      inputRef.current?.blur();
    }
  };

  const handleResultClick = (href: string) => {
    router.push(href);
  };

  // 選択インデックスをリセット
  useEffect(() => {
    setSelectedIndex(-1);
  }, [results]);

  const showSuggestions = isFocused && query.trim().length > 0;

  // カテゴリのレンダリング用ヘルパー
  const renderCategory = (
    title: string,
    icon: React.ReactNode,
    items: SearchResult[],
    colorClass: string,
    startIndex: number
  ) => {
    if (items.length === 0) return null;

    return (
      <div className="py-2">
        <div className={cn("flex items-center gap-2 px-4 py-2 text-xs font-semibold uppercase tracking-wider", colorClass)}>
          {icon}
          {title}
          <span className="ml-auto text-muted-foreground font-normal">{items.length}件</span>
        </div>
        <div className="space-y-0.5">
          {items.map((result, index) => {
            const globalIndex = startIndex + index;
            return (
              <button
                key={`${result.type}-${result.id}`}
                onClick={() => handleResultClick(result.href)}
                onMouseEnter={() => setSelectedIndex(globalIndex)}
                className={cn(
                  "w-full text-left px-4 py-2.5 transition-colors",
                  "hover:bg-muted/70",
                  selectedIndex === globalIndex && "bg-muted"
                )}
              >
                <div className="flex items-center gap-3">
                  <div className="min-w-0 flex-1">
                    <p className="font-medium truncate text-sm">{result.title}</p>
                    {result.subtitle && (
                      <p className="text-xs text-muted-foreground truncate">
                        {result.subtitle}
                      </p>
                    )}
                  </div>
                  <ArrowRight className="h-3.5 w-3.5 text-muted-foreground opacity-0 group-hover:opacity-100 shrink-0" />
                </div>
              </button>
            );
          })}
        </div>
      </div>
    );
  };

  return (
    <div className="min-h-screen flex flex-col items-center px-4 pt-[10vh]">
      <div className="w-full max-w-3xl space-y-6">
        {/* ブランド名 */}
        <div className="text-center space-y-2">
          <h1 className="text-5xl font-bold tracking-tight bg-gradient-to-r from-foreground to-foreground/70 bg-clip-text">
            ALAN
          </h1>
          <p className="text-muted-foreground text-sm">
            案件・TODO・あらゆる情報を検索
          </p>
        </div>

        {/* 検索フォーム */}
        <div className="relative">
          <div className={cn(
            "relative flex items-end border bg-card shadow-sm transition-all",
            showSuggestions && results.length > 0
              ? "rounded-t-2xl border-b-0"
              : "rounded-2xl",
            isFocused && "ring-2 ring-ring border-transparent"
          )}>
            <Search className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground pointer-events-none" />
            <Textarea
              ref={inputRef}
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={handleKeyDown}
              onFocus={() => setIsFocused(true)}
              onBlur={() => setTimeout(() => setIsFocused(false), 150)}
              placeholder="管理番号、地権者名、現地住所、TODOなどを検索..."
              className="min-h-[56px] max-h-[56px] resize-none border-0 bg-transparent pl-12 pr-14 py-4 focus-visible:ring-0 focus-visible:ring-offset-0 text-base placeholder:text-muted-foreground/60"
              rows={1}
            />
            {isSearching && (
              <div className="absolute right-4 top-1/2 -translate-y-1/2">
                <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />
              </div>
            )}
          </div>

          {/* サジェストドロップダウン */}
          {showSuggestions && (
            <div className={cn(
              "absolute left-0 right-0 top-full z-50 bg-card border border-t-0 rounded-b-2xl shadow-lg overflow-hidden",
              isFocused && "ring-2 ring-ring ring-t-0 border-transparent"
            )}>
              {results.length === 0 ? (
                <div className="px-4 py-6 text-center text-muted-foreground text-sm">
                  {isSearching ? (
                    <div className="flex items-center justify-center gap-2">
                      <Sparkles className="h-4 w-4 animate-pulse" />
                      検索中...
                    </div>
                  ) : (
                    <>「{query}」に一致する結果がありません</>
                  )}
                </div>
              ) : (
                <div className="max-h-[400px] overflow-y-auto divide-y divide-border">
                  {renderCategory(
                    "案件",
                    <FolderKanban className="h-3.5 w-3.5" />,
                    categorizedResults.projects,
                    "text-blue-600 dark:text-blue-400",
                    0
                  )}
                  {renderCategory(
                    "TODO",
                    <CheckSquare className="h-3.5 w-3.5" />,
                    categorizedResults.todos,
                    "text-green-600 dark:text-green-400",
                    categorizedResults.projects.length
                  )}
                  {renderCategory(
                    "会議",
                    <MessageSquare className="h-3.5 w-3.5" />,
                    categorizedResults.meetings,
                    "text-purple-600 dark:text-purple-400",
                    categorizedResults.projects.length + categorizedResults.todos.length
                  )}
                </div>
              )}

              {/* フッター */}
              {results.length > 0 && (
                <div className="px-4 py-2 border-t bg-muted/30 text-xs text-muted-foreground flex items-center justify-between">
                  <span>{results.length}件の結果</span>
                  <div className="flex items-center gap-3">
                    <span className="flex items-center gap-1">
                      <kbd className="px-1 py-0.5 rounded bg-muted text-[10px] font-mono">↑↓</kbd>
                      移動
                    </span>
                    <span className="flex items-center gap-1">
                      <kbd className="px-1 py-0.5 rounded bg-muted text-[10px] font-mono">Enter</kbd>
                      選択
                    </span>
                    <span className="flex items-center gap-1">
                      <kbd className="px-1 py-0.5 rounded bg-muted text-[10px] font-mono">Esc</kbd>
                      閉じる
                    </span>
                  </div>
                </div>
              )}
            </div>
          )}

          {/* ヒント（サジェストが表示されていない時のみ） */}
          {!showSuggestions && (
            <div className="flex items-center justify-center gap-4 mt-3 text-xs text-muted-foreground">
              <span>入力すると候補が表示されます</span>
            </div>
          )}
        </div>

        {/* ダッシュボード */}
        {!showSuggestions && (
          <div className="mt-8 w-full">
            {isDashboardLoading ? (
              <div className="flex items-center justify-center py-12">
                <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
              </div>
            ) : dashboard && (
              <div className="grid grid-cols-3 gap-4">
                {/* 期日超過TODO */}
                <Card className={cn(
                  "transition-all hover:shadow-md cursor-pointer h-[180px]",
                  dashboard.overdueTodos.count > 0 && "border-red-500/50 bg-red-500/5"
                )}>
                  <CardHeader className="pb-2">
                    <CardTitle className="flex items-center gap-2 text-sm font-medium">
                      <AlertTriangle className={cn(
                        "h-4 w-4",
                        dashboard.overdueTodos.count > 0 ? "text-red-500" : "text-muted-foreground"
                      )} />
                      期日超過TODO
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="text-3xl font-bold text-red-600 dark:text-red-400">
                      {dashboard.overdueTodos.count}
                    </div>
                    <div className="mt-2 space-y-1">
                      {dashboard.overdueTodos.items.slice(0, 2).map((todo) => (
                        <Link
                          key={todo.id}
                          href={`/projects/${todo.projectId}`}
                          className="block text-xs text-muted-foreground hover:text-foreground truncate"
                        >
                          <span className="font-medium">{todo.managementNumber}</span>: {todo.content}
                        </Link>
                      ))}
                      {dashboard.overdueTodos.count > 2 && (
                        <p className="text-xs text-muted-foreground">他{dashboard.overdueTodos.count - 2}件</p>
                      )}
                    </div>
                  </CardContent>
                </Card>

                {/* 今日期日のTODO */}
                <Card className={cn(
                  "transition-all hover:shadow-md cursor-pointer h-[180px]",
                  dashboard.todayTodos.count > 0 && "border-orange-500/50 bg-orange-500/5"
                )}>
                  <CardHeader className="pb-2">
                    <CardTitle className="flex items-center gap-2 text-sm font-medium">
                      <CalendarClock className={cn(
                        "h-4 w-4",
                        dashboard.todayTodos.count > 0 ? "text-orange-500" : "text-muted-foreground"
                      )} />
                      今日期日
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="text-3xl font-bold text-orange-600 dark:text-orange-400">
                      {dashboard.todayTodos.count}
                    </div>
                    <div className="mt-2 space-y-1">
                      {dashboard.todayTodos.items.slice(0, 2).map((todo) => (
                        <Link
                          key={todo.id}
                          href={`/projects/${todo.projectId}`}
                          className="block text-xs text-muted-foreground hover:text-foreground truncate"
                        >
                          <span className="font-medium">{todo.managementNumber}</span>: {todo.content}
                        </Link>
                      ))}
                      {dashboard.todayTodos.count > 2 && (
                        <p className="text-xs text-muted-foreground">他{dashboard.todayTodos.count - 2}件</p>
                      )}
                    </div>
                  </CardContent>
                </Card>

                {/* 今週期日のTODO */}
                <Card className="transition-all hover:shadow-md cursor-pointer h-[180px]">
                  <CardHeader className="pb-2">
                    <CardTitle className="flex items-center gap-2 text-sm font-medium">
                      <CalendarDays className="h-4 w-4 text-blue-500" />
                      今週期日
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="text-3xl font-bold text-blue-600 dark:text-blue-400">
                      {dashboard.thisWeekTodos.count}
                    </div>
                    <div className="mt-2 space-y-1">
                      {dashboard.thisWeekTodos.items.slice(0, 2).map((todo) => (
                        <Link
                          key={todo.id}
                          href={`/projects/${todo.projectId}`}
                          className="block text-xs text-muted-foreground hover:text-foreground truncate"
                        >
                          <span className="font-medium">{todo.managementNumber}</span>: {todo.content}
                        </Link>
                      ))}
                      {dashboard.thisWeekTodos.count > 2 && (
                        <p className="text-xs text-muted-foreground">他{dashboard.thisWeekTodos.count - 2}件</p>
                      )}
                    </div>
                  </CardContent>
                </Card>

                {/* 案件アラート */}
                <Link href="/todos">
                  <Card className={cn(
                    "transition-all hover:shadow-md cursor-pointer h-[180px]",
                    dashboard.projectAlerts.count > 0 && "border-red-500/50 bg-red-500/5"
                  )}>
                    <CardHeader className="pb-2">
                      <CardTitle className="flex items-center gap-2 text-sm font-medium">
                        <AlertTriangle className={cn(
                          "h-4 w-4",
                          dashboard.projectAlerts.count > 0 ? "text-red-500" : "text-muted-foreground"
                        )} />
                        案件アラート
                      </CardTitle>
                    </CardHeader>
                    <CardContent>
                      <div className="text-3xl font-bold text-red-600 dark:text-red-400">
                        {dashboard.projectAlerts.totalAlerts}
                      </div>
                      <p className="text-xs text-muted-foreground mt-1">
                        {dashboard.projectAlerts.count}件の案件
                      </p>
                      <div className="mt-2 space-y-1">
                        {dashboard.projectAlerts.items.slice(0, 2).map((project) => (
                          <div key={project.id} className="text-xs text-muted-foreground truncate">
                            <span className="font-medium">{project.managementNumber}</span>
                            <Badge variant="destructive" className="ml-1 text-[10px] px-1 py-0">
                              {project.alertCount}
                            </Badge>
                          </div>
                        ))}
                      </div>
                    </CardContent>
                  </Card>
                </Link>

                {/* 進行中案件 */}
                <Link href="/projects">
                  <Card className="transition-all hover:shadow-md cursor-pointer h-[180px]">
                    <CardHeader className="pb-2">
                      <CardTitle className="flex items-center gap-2 text-sm font-medium">
                        <Activity className="h-4 w-4 text-green-500" />
                        進行中案件
                      </CardTitle>
                    </CardHeader>
                    <CardContent>
                      <div className="text-3xl font-bold text-green-600 dark:text-green-400">
                        {dashboard.activeProjects.count}
                      </div>
                      <div className="mt-2 space-y-1">
                        {dashboard.activeProjects.items.slice(0, 2).map((project) => (
                          <div key={project.id} className="text-xs text-muted-foreground truncate">
                            <span className="font-medium">{project.managementNumber}</span>
                            {project.client && <span className="ml-1">({project.client})</span>}
                          </div>
                        ))}
                        {dashboard.activeProjects.count > 2 && (
                          <p className="text-xs text-muted-foreground">他{dashboard.activeProjects.count - 2}件</p>
                        )}
                      </div>
                    </CardContent>
                  </Card>
                </Link>

                {/* 最近更新 */}
                <Card className="transition-all hover:shadow-md h-[180px]">
                  <CardHeader className="pb-2">
                    <CardTitle className="flex items-center gap-2 text-sm font-medium">
                      <Clock className="h-4 w-4 text-purple-500" />
                      最近更新
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-2">
                      {dashboard.recentProjects.items.slice(0, 3).map((project) => (
                        <Link
                          key={project.id}
                          href={`/projects/${project.id}`}
                          className="flex items-center gap-2 text-xs hover:text-foreground group"
                        >
                          <span className="font-medium text-muted-foreground group-hover:text-foreground truncate flex-1">
                            {project.managementNumber}
                          </span>
                          <ChevronRight className="h-3 w-3 text-muted-foreground opacity-0 group-hover:opacity-100" />
                        </Link>
                      ))}
                    </div>
                  </CardContent>
                </Card>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-full text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-full gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-full px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-slot="card"
      className={cn(
        "rounded-2xl border border-border bg-card text-card-foreground shadow-sm",
        className
      )}
      {...props}
    />
  )
)
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-slot="card-header"
    className={cn("p-6 pb-3", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p ref={ref} data-slot="card-title" className={cn("text-sm font-semibold", className)} {...props} />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    data-slot="card-description"
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-slot="card-content"
    className={cn("p-6 pt-0", className)}
    {...props}
  />
))
CardContent.displayName = "CardContent"

export { Card, CardHeader, CardTitle, CardDescription, CardContent }
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// TODOメッセージの型定義
export interface TodoMessage {
  message: string;
  createdAt: string; // ISO 8601形式
}

// completedMemoからメッセージ配列を取得（後方互換性あり）
export function parseTodoMessages(completedMemo: string | null): TodoMessage[] {
  if (!completedMemo) return [];

  try {
    const parsed = JSON.parse(completedMemo);
    if (Array.isArray(parsed)) {
      return parsed;
    }
  } catch {
    // JSONではない場合、旧形式の文字列として扱う
    return [{
      message: completedMemo,
      createdAt: new Date().toISOString()
    }];
  }

  return [];
}

// メッセージ配列をJSON文字列に変換
export function stringifyTodoMessages(messages: TodoMessage[]): string | null {
  if (messages.length === 0) return null;
  return JSON.stringify(messages);
}

// 新しいメッセージを追加
export function addTodoMessage(
  completedMemo: string | null,
  newMessage: string
): string {
  const messages = parseTodoMessages(completedMemo);
  messages.push({
    message: newMessage,
    createdAt: new Date().toISOString()
  });
  return JSON.stringify(messages);
}
</file>

<file path="src/app/api/projects/[id]/comments/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { comments } from "@/db/schema";
import { eq, desc } from "drizzle-orm";
import { auth } from "@/auth";

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const allComments = await db
    .select()
    .from(comments)
    .where(eq(comments.projectId, Number(id)))
    .orderBy(desc(comments.createdAt));
  return NextResponse.json(allComments);
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  const { id } = await params;
  const body = await request.json();

  // セッションからユーザー情報を取得
  const userId = session?.user?.id ? parseInt(session.user.id) : null;
  const userName = session?.user?.name || (session?.user as any)?.username || null;

  const [result] = await db
    .insert(comments)
    .values({
      projectId: Number(id),
      content: body.content,
      createdAt: new Date().toISOString(),
      userId,
      userName,
    })
    .returning();
  return NextResponse.json(result);
}

export async function PATCH(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const body = await request.json();
  const { commentId, content } = body;
  const [result] = await db
    .update(comments)
    .set({ content })
    .where(eq(comments.id, Number(commentId)))
    .returning();
  return NextResponse.json(result);
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { searchParams } = new URL(request.url);
  const commentId = searchParams.get("commentId");
  if (!commentId) {
    return NextResponse.json({ error: "commentId is required" }, { status: 400 });
  }
  await db.delete(comments).where(eq(comments.id, Number(commentId)));
  return NextResponse.json({ success: true });
}
</file>

<file path="src/app/api/projects/[id]/progress/generate/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projects, progress } from "@/db/schema";
import { eq, and, inArray } from "drizzle-orm";
import { calculateTimeline } from "@/lib/timeline";

/**
 * タイムラインのフェーズ予定日を進捗として自動生成
 * 既存の進捗と重複しないもののみ追加
 * 重複データがあれば自動的にクリーンアップ
 */
export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  // 案件を取得
  const [project] = await db
    .select()
    .from(projects)
    .where(eq(projects.id, projectId));

  if (!project) {
    return NextResponse.json({ error: "Project not found" }, { status: 404 });
  }

  if (!project.completionMonth) {
    return NextResponse.json({ error: "Completion month not set" }, { status: 400 });
  }

  // 既存の進捗を取得
  let existingProgress = await db
    .select()
    .from(progress)
    .where(eq(progress.projectId, projectId));

  // === 重複データのクリーンアップ ===
  // 同じタイトルの重複レコードを削除（最も古いIDを残す）
  const titleGroups = new Map<string, typeof existingProgress>();
  for (const p of existingProgress) {
    const group = titleGroups.get(p.title) || [];
    group.push(p);
    titleGroups.set(p.title, group);
  }

  const idsToDelete: number[] = [];
  for (const [, group] of titleGroups) {
    if (group.length > 1) {
      // IDでソートして最小のID以外を削除対象に
      group.sort((a, b) => a.id - b.id);
      for (let i = 1; i < group.length; i++) {
        idsToDelete.push(group[i].id);
      }
    }
  }

  // 重複を削除
  if (idsToDelete.length > 0) {
    await db
      .delete(progress)
      .where(and(
        eq(progress.projectId, projectId),
        inArray(progress.id, idsToDelete)
      ));
    
    // 削除後の進捗を再取得
    existingProgress = await db
      .select()
      .from(progress)
      .where(eq(progress.projectId, projectId));
  }

  // タイムラインを計算
  const timeline = calculateTimeline(project.completionMonth, false);

  // 既存のタイトルをセットに変換（重複チェック用）
  const existingTitles = new Set(existingProgress.map((p) => p.title));

  // 古い名前から新しい名前へのマッピング（互換性のため）
  // 以前は「現地調査」「農転・地目申請」「連系（発電開始）」という名前で保存されていた
  const legacyTitleMapping: Record<string, string[]> = {
    "現調": ["現地調査"],
    "法令申請": ["農転・地目申請"],
    "連系": ["連系（発電開始）"],
  };

  // 新規追加する進捗
  const newProgress: { title: string; date: Date }[] = [];

  for (const phase of timeline) {
    // 新しいタイトルと、古い名前の両方をチェック
    const legacyTitles = legacyTitleMapping[phase.title] || [];
    const titlesToCheck = [phase.title, ...legacyTitles];

    // いずれかのタイトルが既に存在するかチェック
    const exists = titlesToCheck.some((t) => existingTitles.has(t));

    if (!exists) {
      newProgress.push({
        title: phase.title,
        date: phase.date,
      });
    }
  }

  // 新規進捗を挿入
  const insertedProgress = [];
  for (const item of newProgress) {
    const [result] = await db
      .insert(progress)
      .values({
        projectId,
        title: item.title,
        description: null,
        status: "planned",
        createdAt: item.date.toISOString(),
      })
      .returning();
    insertedProgress.push(result);
  }

  return NextResponse.json({
    generated: insertedProgress.length,
    items: insertedProgress,
    cleaned: idsToDelete.length,
  });
}
</file>

<file path="src/app/api/projects/[id]/progress/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { progress } from "@/db/schema";
import { eq, desc } from "drizzle-orm";

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const allProgress = await db
    .select()
    .from(progress)
    .where(eq(progress.projectId, Number(id)))
    .orderBy(desc(progress.createdAt));
  return NextResponse.json(allProgress);
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const body = await request.json();
  const [result] = await db
    .insert(progress)
    .values({
      projectId: Number(id),
      title: body.title,
      description: body.description || null,
      status: body.status || "planned",
      createdAt: body.createdAt || new Date().toISOString(),
    })
    .returning();
  return NextResponse.json(result);
}

export async function PATCH(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const body = await request.json();
  const { progressId, title, description, status, createdAt, completedAt } = body;

  // 更新するフィールドを構築
  const updateFields: Record<string, unknown> = {};
  if (title !== undefined) updateFields.title = title;
  if (description !== undefined) updateFields.description = description;
  if (status !== undefined) updateFields.status = status;
  if (createdAt !== undefined) updateFields.createdAt = createdAt;
  if (completedAt !== undefined) updateFields.completedAt = completedAt;

  const [result] = await db
    .update(progress)
    .set(updateFields)
    .where(eq(progress.id, Number(progressId)))
    .returning();
  return NextResponse.json(result);
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { searchParams } = new URL(request.url);
  const progressId = searchParams.get("progressId");
  if (!progressId) {
    return NextResponse.json({ error: "progressId is required" }, { status: 400 });
  }
  await db.delete(progress).where(eq(progress.id, Number(progressId)));
  return NextResponse.json({ success: true });
}
</file>

<file path="src/app/calendar/page.tsx">
"use client";

import { useState, useEffect } from "react";
import dynamic from "next/dynamic";
import { Loader2 } from "lucide-react";

const FullCalendarView = dynamic(
  () => import("@/components/FullCalendarView"),
  {
    ssr: false,
    loading: () => (
      <div className="flex items-center justify-center h-[500px]">
        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
      </div>
    ),
  }
);

interface CalendarEvent {
  id: string;
  title: string;
  start: string;
  end?: string;
  allDay?: boolean;
  backgroundColor?: string;
  borderColor?: string;
  textColor?: string;
  extendedProps?: {
    type: "todo" | "progress" | "meeting" | "custom" | "other";
    projectId?: number;
    projectName?: string;
    description?: string;
    status?: string;
    userName?: string | null;
    category?: string;
  };
}

const getEventColor = (type: string, status?: string) => {
  switch (type) {
    case "todo":
      if (status === "completed") return { bg: "#22c55e", border: "#16a34a", text: "#ffffff" };
      return { bg: "#f59e0b", border: "#d97706", text: "#ffffff" };
    case "progress":
      if (status === "completed") return { bg: "#22c55e", border: "#16a34a", text: "#ffffff" };
      return { bg: "#3b82f6", border: "#2563eb", text: "#ffffff" };
    case "meeting":
      return { bg: "#8b5cf6", border: "#7c3aed", text: "#ffffff" };
    case "other":
    case "custom":
    default:
      return { bg: "#71717a", border: "#52525b", text: "#ffffff" };
  }
};

export default function CalendarPage() {
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      try {
        // 一括取得APIを使用
        const res = await fetch("/api/calendar/events");
        if (!res.ok) throw new Error("Failed to fetch calendar events");

        const data = await res.json();
        const calendarEvents: CalendarEvent[] = data.map((event: any) => {
          const colors = getEventColor(event.type, event.status);
          return {
            id: event.id,
            title: event.title,
            start: event.start,
            end: event.end,
            allDay: true,
            backgroundColor: colors.bg,
            borderColor: colors.border,
            textColor: colors.text,
            extendedProps: {
              type: event.type,
              projectId: event.projectId,
              projectName: event.projectName,
              description: event.description,
              status: event.status,
              userName: event.userName,
              category: event.category,
            },
          };
        });

        setEvents(calendarEvents);
      } catch (error) {
        console.error("データの取得に失敗しました:", error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, []);

  return (
    <div className="min-h-screen bg-background">
      <div className="px-6 py-8">
        <div className="space-y-6">
          <div>
            <h1 className="text-lg font-semibold">カレンダー</h1>
            <p className="text-sm text-muted-foreground mt-1">
              TODO・進捗・会議の予定を確認
            </p>
          </div>

          {isLoading ? (
            <div className="flex items-center justify-center h-[500px]">
              <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
            </div>
          ) : (
            <FullCalendarView initialEvents={events} />
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/login/page.tsx">
"use client";

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

export default function LoginPage() {
  const router = useRouter();
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const [lineLoading, setLineLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError("");

    try {
      const result = await signIn("credentials", {
        username,
        password,
        redirect: false,
      });

      if (result?.error) {
        setError("ユーザー名またはパスワードが正しくありません");
      } else {
        router.push("/");
        router.refresh();
      }
    } catch (err) {
      setError("ログイン中にエラーが発生しました");
    } finally {
      setLoading(false);
    }
  };

  const handleLineLogin = async () => {
    setLineLoading(true);
    setError("");
    try {
      await signIn("line", { callbackUrl: "/" });
    } catch (err) {
      setError("LINE認証中にエラーが発生しました");
      setLineLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-muted/40 px-4">
      <Card className="w-full max-w-sm">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold">ログイン</CardTitle>
          <CardDescription>
            アカウントにログインしてください
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* LINE ログインボタン */}
          <Button
            type="button"
            variant="outline"
            className="w-full bg-[#06C755] hover:bg-[#05b04c] text-white hover:text-white border-[#06C755]"
            onClick={handleLineLogin}
            disabled={lineLoading || loading}
          >
            {lineLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                LINE認証中...
              </>
            ) : (
              <>
                <svg
                  className="mr-2 h-5 w-5"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                >
                  <path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346 0 .627.285.627.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346 0 .628.285.628.63v4.771zm-2.466.629H4.917c-.345 0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348 0 .63.285.63.63v4.141h1.756c.348 0 .629.283.629.63 0 .344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943 0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314" />
                </svg>
                LINEでログイン
              </>
            )}
          </Button>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <span className="w-full border-t" />
            </div>
            <div className="relative flex justify-center text-xs uppercase">
              <span className="bg-card px-2 text-muted-foreground">または</span>
            </div>
          </div>

          {/* 従来のログインフォーム */}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username">ユーザー名</Label>
              <Input
                id="username"
                type="text"
                placeholder="例: yamada"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                required
                disabled={loading || lineLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">パスワード</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={loading || lineLoading}
              />
            </div>
            {error && (
              <p className="text-sm text-destructive font-medium">{error}</p>
            )}
            <Button type="submit" className="w-full" disabled={loading || lineLoading}>
              {loading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  ログイン中...
                </>
              ) : (
                "ログイン"
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/todos/page.tsx">
import { db } from "@/db";
import { projects, progress } from "@/db/schema";
import TimelineView from "./TimelineView";

export const dynamic = "force-dynamic";

export default async function TimelinePage() {
  const allProjects = await db.select().from(projects);
  const allProgress = await db.select().from(progress);

  // 各プロジェクトに進捗データを紐付け
  const projectsWithProgress = allProjects.map((project) => ({
    ...project,
    progressItems: allProgress.filter((p) => p.projectId === project.id),
  }));

  return <TimelineView projects={projectsWithProgress} />;
}
</file>

<file path="src/auth.ts">
import NextAuth from "next-auth";
import Credentials from "next-auth/providers/credentials";
import Line from "next-auth/providers/line";
import { authConfig } from "./auth.config";
import { db } from "@/db";
import { users } from "@/db/schema";
import { eq } from "drizzle-orm";
import bcrypt from "bcryptjs";
import { z } from "zod";

export const { handlers, auth, signIn, signOut } = NextAuth({
  ...authConfig,
  providers: [
    // LINE認証
    Line({
      clientId: process.env.LINE_CLIENT_ID!,
      clientSecret: process.env.LINE_CLIENT_SECRET!,
    }),
    // 従来のユーザー名/パスワード認証
    Credentials({
      async authorize(credentials) {
        const parsedCredentials = z
          .object({ username: z.string(), password: z.string().min(6) })
          .safeParse(credentials);

        if (parsedCredentials.success) {
          const { username, password } = parsedCredentials.data;

          const [user] = await db
            .select()
            .from(users)
            .where(eq(users.username, username));

          if (!user) return null;

          const passwordsMatch = await bcrypt.compare(password, user.password);
          if (passwordsMatch) return user as any;
        }

        console.log("Invalid credentials");
        return null;
      },
    }),
  ],
  callbacks: {
    ...authConfig.callbacks,
    async signIn({ user, account, profile }) {
      console.log("[LINE Auth] signIn callback started", { provider: account?.provider });

      // LINE認証の場合、ユーザーをDBに登録/更新
      if (account?.provider === "line") {
        try {
          const lineId = (profile?.sub as string) || user.id || "";
          if (!lineId) {
            console.error("[LINE Auth] No lineId found");
            return false;
          }
          const name = user.name || (profile?.name as string) || "LINE User";
          const image = user.image || (profile?.picture as string);

          console.log("[LINE Auth] Processing user:", { lineId, name });

          // 既存ユーザーを検索
          const [existingUser] = await db
            .select()
            .from(users)
            .where(eq(users.lineId as any, lineId));

          if (existingUser) {
            console.log("[LINE Auth] Existing user found:", existingUser.id);
            // 既存ユーザーの情報を更新
            await db
              .update(users)
              .set({ name, image })
              .where(eq(users.lineId as any, lineId));

            // user.idを既存のDBのIDに設定
            user.id = String(existingUser.id);
            (user as any).username = existingUser.username;
          } else {
            console.log("[LINE Auth] Creating new user");
            // 新規ユーザーを作成
            const username = `line_${lineId.substring(0, 8)}`;
            const hashedPassword = await bcrypt.hash(lineId, 10); // ダミーパスワード

            const [newUser] = await db
              .insert(users)
              .values({
                username,
                name,
                password: hashedPassword,
                lineId,
                image,
                role: "user",
              })
              .returning();

            console.log("[LINE Auth] New user created:", newUser.id);
            user.id = String(newUser.id);
            (user as any).username = newUser.username;
          }
        } catch (error) {
          console.error("[LINE Auth] Error in signIn callback:", error);
          return false;
        }
      }
      return true;
    },
    async jwt({ token, user, account }) {
      if (user) {
        token.username = (user as any).username;
        token.sub = user.id;
      }
      if (account?.provider === "line") {
        token.provider = "line";
      }
      return token;
    },
    async session({ session, token }) {
      if (token.sub && session.user) {
        session.user.id = token.sub;
      }
      if (token.username && session.user) {
        (session.user as any).username = token.username;
      }
      if (token.provider && session.user) {
        (session.user as any).provider = token.provider;
      }
      return session;
    },
  },
});
</file>

<file path="src/components/FullCalendarView.tsx">
"use client";

import { useState } from "react";
import FullCalendar from "@fullcalendar/react";
import dayGridPlugin from "@fullcalendar/daygrid";
import timeGridPlugin from "@fullcalendar/timegrid";
import interactionPlugin from "@fullcalendar/interaction";
import listPlugin from "@fullcalendar/list";
import { EventClickArg, DateSelectArg, EventDropArg } from "@fullcalendar/core";
import jaLocale from "@fullcalendar/core/locales/ja";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Clock, Trash2, ExternalLink, User, Loader2 } from "lucide-react";
import { cn } from "@/lib/utils";
import Link from "next/link";
import { DeleteConfirmDialog } from "@/components/DeleteConfirmDialog";

// イベントの型定義
interface CalendarEvent {
  id: string;
  title: string;
  start: string;
  end?: string;
  allDay?: boolean;
  backgroundColor?: string;
  borderColor?: string;
  textColor?: string;
  extendedProps?: {
    type: "todo" | "progress" | "meeting" | "custom" | "other";
    projectId?: number;
    projectName?: string;
    description?: string;
    status?: string;
    userName?: string | null;
    category?: string; // 会議の種別
  };
}

// イベントタイプのオプション
const EVENT_TYPE_OPTIONS = [
  { value: "todo", label: "TODO", color: "bg-amber-500" },
  { value: "meeting", label: "会議", color: "bg-purple-500" },
  { value: "other", label: "その他", color: "bg-zinc-500" },
];

// イベントカラー（バッジ用のみカラフル、それ以外はモノトーン）
const getEventColor = (type: string, status?: string) => {
  switch (type) {
    case "todo":
      if (status === "completed") return { bg: "#22c55e", border: "#16a34a", text: "#ffffff" };
      return { bg: "#f59e0b", border: "#d97706", text: "#ffffff" };
    case "progress":
      if (status === "completed") return { bg: "#22c55e", border: "#16a34a", text: "#ffffff" };
      return { bg: "#3b82f6", border: "#2563eb", text: "#ffffff" };
    case "meeting":
      return { bg: "#8b5cf6", border: "#7c3aed", text: "#ffffff" };
    case "other":
    case "custom":
    default:
      return { bg: "#71717a", border: "#52525b", text: "#ffffff" };
  }
};

interface FullCalendarViewProps {
  initialEvents?: CalendarEvent[];
}

export default function FullCalendarView({ initialEvents = [] }: FullCalendarViewProps) {
  const [events, setEvents] = useState<CalendarEvent[]>(initialEvents);
  const [selectedEvent, setSelectedEvent] = useState<CalendarEvent | null>(null);
  const [isEventDialogOpen, setIsEventDialogOpen] = useState(false);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [newEvent, setNewEvent] = useState({
    title: "",
    start: "",
    end: "",
    allDay: true,
    description: "",
    type: "other" as "todo" | "meeting" | "other",
  });

  // 削除確認ダイアログ用
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);

  const handleEventClick = (info: EventClickArg) => {
    const event = events.find((e) => e.id === info.event.id);
    if (event) {
      setSelectedEvent(event);
      setIsEventDialogOpen(true);
    }
  };

  const handleDateSelect = (info: DateSelectArg) => {
    setNewEvent({
      title: "",
      start: info.startStr,
      end: info.endStr,
      allDay: info.allDay,
      description: "",
      type: "other",
    });
    setIsCreateDialogOpen(true);
  };

  const handleEventDrop = async (info: EventDropArg) => {
    const updatedEvents = events.map((event) => {
      if (event.id === info.event.id) {
        return {
          ...event,
          start: info.event.startStr,
          end: info.event.endStr || undefined,
        };
      }
      return event;
    });
    setEvents(updatedEvents);
  };

  const handleCreateEvent = async () => {
    if (!newEvent.title.trim()) return;

    setIsSubmitting(true);
    try {
      const res = await fetch("/api/calendar/events", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title: newEvent.title,
          eventType: newEvent.type,
          eventDate: newEvent.start,
          endDate: newEvent.end || null,
          description: newEvent.description,
        }),
      });

      if (!res.ok) throw new Error("Failed to create event");

      const data = await res.json();
      const colors = getEventColor(data.type);
      const event: CalendarEvent = {
        id: data.id,
        title: data.title,
        start: data.start,
        end: data.end || undefined,
        allDay: true,
        backgroundColor: colors.bg,
        borderColor: colors.border,
        textColor: colors.text,
        extendedProps: {
          type: data.type,
          description: data.description,
          userName: data.userName,
        },
      };

      setEvents([...events, event]);
      setIsCreateDialogOpen(false);
      setNewEvent({
        title: "",
        start: "",
        end: "",
        allDay: true,
        description: "",
        type: "other",
      });
    } catch (error) {
      console.error("イベントの作成に失敗しました:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const openDeleteDialog = () => {
    setDeleteDialogOpen(true);
  };

  const handleDeleteEvent = async () => {
    if (!selectedEvent) return;

    // カスタムイベントの場合はAPIで削除
    if (selectedEvent.id.startsWith("custom-")) {
      try {
        const res = await fetch(`/api/calendar/events/${selectedEvent.id}`, {
          method: "DELETE",
        });
        if (!res.ok) throw new Error("Failed to delete event");
      } catch (error) {
        console.error("イベントの削除に失敗しました:", error);
        return;
      }
    }

    setEvents(events.filter((e) => e.id !== selectedEvent.id));
    setDeleteDialogOpen(false);
    setIsEventDialogOpen(false);
    setSelectedEvent(null);
  };

  return (
    <div className="h-full">
      {/* 凡例 - シンプル */}
      <div className="flex flex-wrap gap-2 mb-4 text-xs text-muted-foreground">
        <span className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-sm bg-amber-500" />
          TODO
        </span>
        <span className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-sm bg-blue-500" />
          進捗
        </span>
        <span className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-sm bg-green-500" />
          完了
        </span>
        <span className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-sm bg-purple-500" />
          会議
        </span>
        <span className="flex items-center gap-1.5">
          <span className="w-2.5 h-2.5 rounded-sm bg-zinc-500" />
          その他
        </span>
      </div>

      {/* カレンダー */}
      <FullCalendar
        plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin, listPlugin]}
        initialView="dayGridMonth"
        locale={jaLocale}
        headerToolbar={{
          left: "prev,today,next",
          center: "title",
          right: "dayGridMonth,timeGridWeek,listWeek",
        }}
        buttonText={{
          today: "今日",
          month: "月",
          week: "週",
          list: "リスト",
        }}
        events={events}
        editable={true}
        selectable={true}
        selectMirror={true}
        dayMaxEvents={3}
        weekends={true}
        eventClick={handleEventClick}
        select={handleDateSelect}
        eventDrop={handleEventDrop}
        height="auto"
        contentHeight={650}
        eventDisplay="block"
        eventTimeFormat={{
          hour: "2-digit",
          minute: "2-digit",
          meridiem: false,
        }}
        slotMinTime="06:00:00"
        slotMaxTime="22:00:00"
        nowIndicator={true}
      />

      {/* イベント詳細ダイアログ */}
      <Dialog open={isEventDialogOpen} onOpenChange={setIsEventDialogOpen}>
        <DialogContent className="max-w-sm">
          <DialogHeader>
            <DialogTitle className="text-base font-medium">
              {selectedEvent?.title}
            </DialogTitle>
          </DialogHeader>
          {selectedEvent && (
            <div className="space-y-3">
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Clock className="h-3.5 w-3.5" />
                <span>
                  {new Date(selectedEvent.start).toLocaleDateString("ja-JP", {
                    month: "long",
                    day: "numeric",
                    weekday: "short",
                  })}
                </span>
              </div>

              {selectedEvent.extendedProps?.projectName && (
                <Link
                  href={`/projects/${selectedEvent.extendedProps.projectId}`}
                  className="text-sm text-muted-foreground hover:text-foreground hover:underline"
                >
                  {selectedEvent.extendedProps.projectName}
                </Link>
              )}

              {selectedEvent.extendedProps?.description && (
                <p className="text-sm text-muted-foreground">
                  {selectedEvent.extendedProps.description}
                </p>
              )}

              <div className="flex items-center gap-2 flex-wrap">
                <Badge
                  variant="secondary"
                  className={cn(
                    "text-xs",
                    selectedEvent.extendedProps?.type === "todo" && "bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200",
                    selectedEvent.extendedProps?.type === "progress" && "bg-blue-100 text-blue-800 dark:bg-blue-900/40 dark:text-blue-200",
                    selectedEvent.extendedProps?.type === "meeting" && "bg-purple-100 text-purple-800 dark:bg-purple-900/40 dark:text-purple-200",
                    selectedEvent.extendedProps?.type === "other" && "bg-zinc-100 text-zinc-800 dark:bg-zinc-900/40 dark:text-zinc-200",
                    selectedEvent.extendedProps?.status === "completed" && "bg-green-100 text-green-800 dark:bg-green-900/40 dark:text-green-200"
                  )}
                >
                  {selectedEvent.extendedProps?.status === "completed" ? "完了" :
                   selectedEvent.extendedProps?.type === "todo" ? "TODO" :
                   selectedEvent.extendedProps?.type === "progress" ? "進捗" :
                   selectedEvent.extendedProps?.type === "meeting" ? "会議" :
                   selectedEvent.extendedProps?.type === "other" ? "その他" : "予定"}
                </Badge>
                {selectedEvent.extendedProps?.userName && (
                  <span className="flex items-center gap-1 text-xs text-muted-foreground">
                    <User className="h-3 w-3" />
                    {selectedEvent.extendedProps.userName}
                  </span>
                )}
              </div>

              <div className="flex justify-between pt-3 border-t">
                {selectedEvent.extendedProps?.projectId && (
                  <Button variant="ghost" size="sm" asChild>
                    <Link href={`/projects/${selectedEvent.extendedProps.projectId}`}>
                      <ExternalLink className="h-3.5 w-3.5 mr-1.5" />
                      案件
                    </Link>
                  </Button>
                )}
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={openDeleteDialog}
                  className="text-muted-foreground hover:text-destructive ml-auto"
                >
                  <Trash2 className="h-3.5 w-3.5 mr-1.5" />
                  削除
                </Button>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* 新規イベント作成ダイアログ */}
      <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
        <DialogContent className="max-w-sm">
          <DialogHeader>
            <DialogTitle className="text-base font-medium">予定を追加</DialogTitle>
          </DialogHeader>
          <div className="space-y-3">
            <div className="space-y-1.5">
              <Label htmlFor="event-title" className="text-sm">タイトル</Label>
              <Input
                id="event-title"
                value={newEvent.title}
                onChange={(e) => setNewEvent({ ...newEvent, title: e.target.value })}
                placeholder="予定名"
                className="h-9"
              />
            </div>

            <div className="space-y-1.5">
              <Label className="text-sm">種別</Label>
              <Select
                value={newEvent.type}
                onValueChange={(value: "todo" | "meeting" | "other") => setNewEvent({ ...newEvent, type: value })}
              >
                <SelectTrigger className="h-9">
                  <SelectValue placeholder="種別を選択" />
                </SelectTrigger>
                <SelectContent>
                  {EVENT_TYPE_OPTIONS.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      <span className="flex items-center gap-2">
                        <span className={cn("w-2.5 h-2.5 rounded-sm", option.color)} />
                        {option.label}
                      </span>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="grid grid-cols-2 gap-3">
              <div className="space-y-1.5">
                <Label htmlFor="event-start" className="text-sm">開始</Label>
                <Input
                  id="event-start"
                  type="date"
                  value={newEvent.start.split("T")[0]}
                  onChange={(e) => setNewEvent({ ...newEvent, start: e.target.value })}
                  className="h-9"
                />
              </div>
              <div className="space-y-1.5">
                <Label htmlFor="event-end" className="text-sm">終了</Label>
                <Input
                  id="event-end"
                  type="date"
                  value={newEvent.end?.split("T")[0] || ""}
                  onChange={(e) => setNewEvent({ ...newEvent, end: e.target.value })}
                  className="h-9"
                />
              </div>
            </div>

            <div className="space-y-1.5">
              <Label htmlFor="event-description" className="text-sm">メモ</Label>
              <Textarea
                id="event-description"
                value={newEvent.description}
                onChange={(e) => setNewEvent({ ...newEvent, description: e.target.value })}
                placeholder="メモ（任意）"
                rows={2}
                className="resize-none"
              />
            </div>

            <div className="flex justify-end gap-2 pt-2">
              <Button variant="ghost" size="sm" onClick={() => setIsCreateDialogOpen(false)} disabled={isSubmitting}>
                キャンセル
              </Button>
              <Button size="sm" onClick={handleCreateEvent} disabled={!newEvent.title.trim() || isSubmitting}>
                {isSubmitting ? (
                  <>
                    <Loader2 className="h-3.5 w-3.5 animate-spin mr-1.5" />
                    追加中...
                  </>
                ) : (
                  "追加"
                )}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* 削除確認ダイアログ */}
      <DeleteConfirmDialog
        open={deleteDialogOpen}
        onOpenChange={setDeleteDialogOpen}
        onConfirm={handleDeleteEvent}
        title="予定の削除"
        description="この予定を削除してもよろしいですか？"
      />
    </div>
  );
}
</file>

<file path="src/components/HomeProjectSearch.tsx">
"use client";

import { useEffect, useState, useRef } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { Search, ArrowRight, FolderKanban, MessageSquare } from "lucide-react";
import { Input } from "@/components/ui/input";

const PROJECT_SEARCH_RECENT_KEY = "geo_checker_recent_project_searches";
const MAX_RECENT_SEARCHES = 3;

function getRecentSearches(): string[] {
  if (typeof window === "undefined") return [];
  try {
    const raw = localStorage.getItem(PROJECT_SEARCH_RECENT_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw) as unknown;
    return Array.isArray(arr)
      ? arr.filter((x): x is string => typeof x === "string").slice(0, MAX_RECENT_SEARCHES)
      : [];
  } catch {
    return [];
  }
}

function addRecentSearch(query: string): string[] {
  const q = query.trim();
  if (!q) return getRecentSearches();
  const prev = getRecentSearches();
  const next = [q, ...prev.filter((x) => x !== q)].slice(0, MAX_RECENT_SEARCHES);
  try {
    localStorage.setItem(PROJECT_SEARCH_RECENT_KEY, JSON.stringify(next));
  } catch {
    // ignore
  }
  return next;
}

type ProjectForSearch = {
  id: number;
  managementNumber: string;
  projectNumber: string | null;
  address: string | null;
  landowner1: string | null;
  landowner2: string | null;
  landowner3: string | null;
  commentSearchText?: string;
  todoSearchText?: string;
};

type MeetingForSearch = {
  id: number;
  title: string | null;
  meetingDate: string | null;
  category: string | null;
  content: string | null;
  agenda: string | null;
};

export function HomeProjectSearch() {
  const router = useRouter();
  const [projects, setProjects] = useState<ProjectForSearch[]>([]);
  const [meetings, setMeetings] = useState<MeetingForSearch[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [isOpen, setIsOpen] = useState(false);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    setRecentSearches(getRecentSearches());
  }, []);

  const handleSearchFocus = () => {
    setIsOpen(true);
    setShowSuggestions(true);
  };
  const handleSearchBlur = () => {
    setTimeout(() => setShowSuggestions(false), 200);
    const q = searchQuery.trim();
    if (q) setRecentSearches(addRecentSearch(q));
  };
  const handleSearchKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      const q = searchQuery.trim();
      if (q) setRecentSearches(addRecentSearch(q));
    }
  };
  const handleSuggestionClick = (text: string) => {
    setSearchQuery(text);
    setRecentSearches(addRecentSearch(text));
    setShowSuggestions(false);
  };

  useEffect(() => {
    fetch("/api/projects", { cache: "no-store" })
      .then((res) => res.json())
      .then(setProjects)
      .catch((err) => console.error("案件一覧の取得に失敗しました:", err));
    fetch("/api/meetings", { cache: "no-store" })
      .then((res) => res.json())
      .then(setMeetings)
      .catch((err) => console.error("会議一覧の取得に失敗しました:", err));
  }, []);

  const query = searchQuery.trim().toLowerCase();
  const filteredProjects = query
    ? projects.filter((project) => {
        const addr = (project.address ?? "").toLowerCase();
        const l1 = (project.landowner1 ?? "").toLowerCase();
        const l2 = (project.landowner2 ?? "").toLowerCase();
        const l3 = (project.landowner3 ?? "").toLowerCase();
        const commentText = (project.commentSearchText ?? "").toLowerCase();
        const todoText = (project.todoSearchText ?? "").toLowerCase();
        return (
          project.managementNumber.toLowerCase().includes(query) ||
          (project.projectNumber ?? "").toLowerCase().includes(query) ||
          addr.includes(query) ||
          l1.includes(query) ||
          l2.includes(query) ||
          l3.includes(query) ||
          commentText.includes(query) ||
          todoText.includes(query)
        );
      })
    : [];

  const filteredMeetings = query
    ? meetings.filter((meeting) => {
        const title = (meeting.title ?? "").toLowerCase();
        const content = (meeting.content ?? "").toLowerCase();
        const agenda = (meeting.agenda ?? "").toLowerCase();
        const category = (meeting.category ?? "").toLowerCase();
        return (
          title.includes(query) ||
          content.includes(query) ||
          agenda.includes(query) ||
          category.includes(query)
        );
      })
    : [];

  const hasResults = filteredProjects.length > 0 || filteredMeetings.length > 0;
  const totalCount = filteredProjects.length + filteredMeetings.length;

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key !== "Enter" || totalCount === 0) return;
    e.preventDefault();
    if (totalCount === 1) {
      if (filteredProjects.length === 1) {
        router.push(`/projects/${filteredProjects[0].id}`);
      } else {
        router.push(`/meetings/${filteredMeetings[0].id}`);
      }
      setSearchQuery("");
      setIsOpen(false);
    }
  };

  const maxProjects = 8;
  const maxMeetings = 8;
  const showResultsDropdown = isOpen && searchQuery.trim() !== "";
  const showRecentSuggestions = isOpen && showSuggestions && recentSearches.length > 0 && !searchQuery.trim();

  return (
    <div ref={containerRef} className="relative w-full">
      <div className="relative">
        <Search className="absolute left-4 top-1/2 h-5 w-5 -translate-y-1/2 text-zinc-400 dark:text-zinc-500 z-10 pointer-events-none" />
        <Input
          type="search"
          placeholder="管理番号・案件番号・地権者・現地住所・コメント・TODO・会議で検索"
          value={searchQuery}
          onChange={(e) => {
            setSearchQuery(e.target.value);
            setIsOpen(true);
          }}
          onFocus={handleSearchFocus}
          onBlur={handleSearchBlur}
          onKeyDown={(e) => {
            handleSearchKeyDown(e);
            handleKeyDown(e);
          }}
          className="w-full pl-12 h-12 text-base bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 focus-visible:ring-2 rounded-xl"
        />
      </div>

      {showRecentSuggestions && (
        <div
          className="absolute left-0 right-0 top-full mt-1 z-20 rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 shadow-lg overflow-hidden"
          onMouseDown={(e) => e.preventDefault()}
        >
          <p className="px-4 py-2 text-xs text-zinc-500 border-b border-zinc-100 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-800/50">
            最近の検索
          </p>
          <ul className="py-1">
            {recentSearches.map((text) => (
              <li key={text}>
                <button
                  type="button"
                  className="w-full px-4 py-2.5 text-left text-sm hover:bg-zinc-50 dark:hover:bg-zinc-800 focus:bg-zinc-50 dark:focus:bg-zinc-800 focus:outline-none"
                  onMouseDown={() => handleSuggestionClick(text)}
                >
                  {text}
                </button>
              </li>
            ))}
          </ul>
        </div>
      )}

      {showResultsDropdown && (
        <div className="absolute top-full left-0 right-0 z-50 mt-1 rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 shadow-lg overflow-hidden">
          {!hasResults ? (
            <div className="px-4 py-6 text-center">
              <p className="text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-1">
                「{searchQuery.trim()}」に該当する案件・議事録はありません
              </p>
              <p className="text-xs text-zinc-500">
                別のキーワードで検索してみてください
              </p>
            </div>
          ) : (
            <div className="max-h-[360px] overflow-y-auto">
              <div className="px-4 py-3 border-b border-zinc-100 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-800/50">
                <p className="text-sm font-medium text-zinc-800 dark:text-zinc-200">
                  「{searchQuery.trim()}」で{" "}
                  {[
                    filteredProjects.length > 0 && `案件 ${filteredProjects.length} 件`,
                    filteredMeetings.length > 0 && `議事録 ${filteredMeetings.length} 件`,
                  ]
                    .filter(Boolean)
                    .join("、")}{" "}
                  が見つかりました
                </p>
              </div>
              <div className="py-2">
              {filteredProjects.length > 0 && (
                <>
                  <div className="px-4 py-1.5 text-xs font-medium text-zinc-500 flex items-center gap-1.5">
                    <FolderKanban className="h-3.5 w-3.5" />
                    案件
                  </div>
                  <ul>
                    {filteredProjects.slice(0, maxProjects).map((project) => (
                      <li key={`p-${project.id}`}>
                        <Link
                          href={`/projects/${project.id}`}
                          onClick={() => {
                            setSearchQuery("");
                            setIsOpen(false);
                          }}
                          className="flex items-center gap-3 px-4 py-3 hover:bg-zinc-50 dark:hover:bg-zinc-800 transition-colors"
                        >
                          <span className="font-medium text-zinc-900 dark:text-zinc-100 truncate">
                            {project.managementNumber}
                          </span>
                          <span className="text-sm text-zinc-500 truncate flex-1 min-w-0">
                            {project.projectNumber ?? ""}
                          </span>
                          <ArrowRight className="h-4 w-4 text-zinc-400 shrink-0" />
                        </Link>
                      </li>
                    ))}
                  </ul>
                  {filteredProjects.length > maxProjects && (
                    <div className="px-4 py-1 text-xs text-zinc-500">
                      他 {filteredProjects.length - maxProjects} 件
                    </div>
                  )}
                </>
              )}
              {filteredMeetings.length > 0 && (
                <>
                  <div className="px-4 py-1.5 text-xs font-medium text-zinc-500 flex items-center gap-1.5 mt-1 border-t border-zinc-100 dark:border-zinc-800">
                    <MessageSquare className="h-3.5 w-3.5" />
                    会議
                  </div>
                  <ul>
                    {filteredMeetings.slice(0, maxMeetings).map((meeting) => (
                      <li key={`m-${meeting.id}`}>
                        <Link
                          href={`/meetings/${meeting.id}`}
                          onClick={() => {
                            setSearchQuery("");
                            setIsOpen(false);
                          }}
                          className="flex items-center gap-3 px-4 py-3 hover:bg-zinc-50 dark:hover:bg-zinc-800 transition-colors"
                        >
                          <span className="font-medium text-zinc-900 dark:text-zinc-100 truncate">
                            {meeting.title ?? "（無題）"}
                          </span>
                          <span className="text-sm text-zinc-500 truncate flex-1 min-w-0">
                            {meeting.meetingDate ?? ""}
                          </span>
                          <ArrowRight className="h-4 w-4 text-zinc-400 shrink-0" />
                        </Link>
                      </li>
                    ))}
                  </ul>
                  {filteredMeetings.length > maxMeetings && (
                    <div className="px-4 py-1 text-xs text-zinc-500">
                      他 {filteredMeetings.length - maxMeetings} 件
                    </div>
                  )}
                </>
              )}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/api/todos/route.ts">
import { NextResponse } from "next/server";
import { eq, asc } from "drizzle-orm";
import { db } from "@/db";
import { todos, projects } from "@/db/schema";
import { auth } from "@/auth";

export const dynamic = "force-dynamic";

export async function GET() {
  const rows = await db
    .select({
      id: todos.id,
      projectId: todos.projectId,
      content: todos.content,
      dueDate: todos.dueDate,
      createdAt: todos.createdAt,
      completedAt: todos.completedAt,
      completedMemo: todos.completedMemo,
      userId: todos.userId,
      userName: todos.userName,
      managementNumber: projects.managementNumber,
    })
    .from(todos)
    .leftJoin(projects, eq(todos.projectId, projects.id))
    .orderBy(asc(todos.dueDate));
  return NextResponse.json(rows);
}

// プレーンなTODOを作成（案件に紐づかない）
export async function POST(request: Request) {
  const session = await auth();
  const body = await request.json();
  const content = body.content?.trim() ?? "";
  const dueDate = body.dueDate ?? "";

  if (!content || !dueDate) {
    return NextResponse.json(
      { error: "content and dueDate are required" },
      { status: 400 }
    );
  }

  // セッションからユーザー情報を取得
  const userId = session?.user?.id ? parseInt(session.user.id) : null;
  const userName = session?.user?.name || (session?.user as any)?.username || null;

  const [result] = await db
    .insert(todos)
    .values({
      projectId: null, // 案件に紐づかない
      content,
      dueDate,
      createdAt: new Date().toISOString(),
      userId,
      userName,
    })
    .returning();

  return NextResponse.json(result);
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";
@plugin "@tailwindcss/typography";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* FullCalendar カスタムスタイル - シンプルモノトーン */
.fc {
  --fc-border-color: var(--border);
  --fc-button-bg-color: transparent;
  --fc-button-border-color: var(--border);
  --fc-button-text-color: var(--foreground);
  --fc-button-hover-bg-color: var(--muted);
  --fc-button-hover-border-color: var(--border);
  --fc-button-active-bg-color: var(--foreground);
  --fc-button-active-border-color: var(--foreground);
  --fc-today-bg-color: var(--muted);
  --fc-neutral-bg-color: var(--muted);
  --fc-page-bg-color: var(--background);
  --fc-event-border-color: transparent;
}

.fc .fc-toolbar-title {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--foreground);
}

.fc .fc-button {
  border-radius: var(--radius);
  font-size: 0.8125rem;
  font-weight: 500;
  padding: 0.375rem 0.75rem;
  transition: all 0.15s;
  background: transparent;
  border: 1px solid var(--border);
  color: var(--foreground);
}

.fc .fc-button:hover {
  background: var(--muted);
}

.fc .fc-button-primary:not(:disabled).fc-button-active,
.fc .fc-button-primary:not(:disabled):active {
  background-color: var(--foreground);
  border-color: var(--foreground);
  color: var(--background);
}

.fc .fc-col-header-cell {
  padding: 0.5rem 0;
  font-weight: 500;
  font-size: 0.75rem;
  color: var(--muted-foreground);
  background: transparent;
}

.fc .fc-daygrid-day-number {
  padding: 0.375rem;
  font-size: 0.8125rem;
  font-weight: 400;
  color: var(--foreground);
}

.fc .fc-daygrid-day.fc-day-today {
  background-color: var(--muted);
}

.fc .fc-daygrid-day.fc-day-today .fc-daygrid-day-number {
  font-weight: 600;
}

.fc .fc-event {
  border-radius: 3px;
  padding: 1px 4px;
  font-size: 0.6875rem;
  font-weight: 500;
  cursor: pointer;
}

.fc .fc-timegrid-slot {
  height: 2.5rem;
}

.fc .fc-timegrid-slot-label {
  font-size: 0.6875rem;
  color: var(--muted-foreground);
}

.fc .fc-list-event {
  cursor: pointer;
}

.fc .fc-list-event:hover td {
  background-color: var(--muted);
}

.fc .fc-list-day-cushion {
  background-color: var(--muted);
}

.fc .fc-scrollgrid {
  border-radius: var(--radius);
  overflow: hidden;
  border: 1px solid var(--border);
}

.fc .fc-scrollgrid-section > * {
  border-color: var(--border);
}

.fc-theme-standard td,
.fc-theme-standard th {
  border-color: var(--border);
}

.fc .fc-daygrid-day-frame {
  min-height: 80px;
}

.fc .fc-more-link {
  color: var(--muted-foreground);
  font-weight: 500;
  font-size: 0.6875rem;
}

.fc .fc-popover {
  background: var(--popover);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.fc .fc-popover-header {
  background: var(--muted);
  padding: 0.375rem 0.5rem;
  font-weight: 500;
  font-size: 0.8125rem;
}

.fc .fc-highlight {
  background-color: var(--muted);
}

/* Markdown prose スタイル強化 */
.prose ul {
  list-style-type: disc;
  padding-left: 1.5em;
}

.prose ol {
  list-style-type: decimal;
  padding-left: 1.5em;
}

.prose ul > li,
.prose ol > li {
  padding-left: 0.25em;
}

.prose ul > li::marker {
  color: var(--foreground);
}

.prose ol > li::marker {
  color: var(--foreground);
}

.prose table {
  width: 100%;
  border-collapse: collapse;
  margin: 1em 0;
}

.prose th,
.prose td {
  border: 1px solid var(--border);
  padding: 0.5em 0.75em;
  text-align: left;
}

.prose th {
  background-color: var(--muted);
  font-weight: 600;
}

.prose tr:nth-child(even) {
  background-color: var(--muted);
}

.prose blockquote {
  border-left: 3px solid var(--border);
  padding-left: 1em;
  margin-left: 0;
  color: var(--muted-foreground);
  font-style: italic;
}

.prose hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 1.5em 0;
}

.prose input[type="checkbox"] {
  margin-right: 0.5em;
  accent-color: var(--primary);
}
</file>

<file path="src/app/todos/TodosView.tsx">
"use client";

import { useState, useMemo } from "react";
import Link from "next/link";
import {
  AlertCircle,
  Calendar as CalendarIcon,
  Clock,
  Trash2,
  ArrowRight,
  Search,
  ListTodo,
  CheckCircle2,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { formatDateJp } from "@/lib/timeline";
import { parseTodoMessages } from "@/lib/utils";
import { DeleteConfirmDialog } from "@/components/DeleteConfirmDialog";

export type TodoWithProject = {
  id: number;
  projectId: number;
  content: string;
  dueDate: string;
  createdAt: string;
  completedAt: string | null;
  completedMemo: string | null;
  managementNumber: string | null;
};

interface TodosViewProps {
  initialTodos: TodoWithProject[];
}

function getDueDateInfo(dueDateStr: string) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const due = new Date(dueDateStr + "T00:00:00");
  due.setHours(0, 0, 0, 0);
  const diffMs = due.getTime() - today.getTime();
  const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return { group: "overdue" as const, label: `${Math.abs(diffDays)}日超過`, diffDays };
  if (diffDays === 0) return { group: "today" as const, label: "今日", diffDays };
  if (diffDays === 1) return { group: "upcoming" as const, label: "明日", diffDays };
  if (diffDays <= 7) return { group: "upcoming" as const, label: `あと${diffDays}日`, diffDays };
  return { group: "later" as const, label: `あと${diffDays}日`, diffDays };
}

export default function TodosView({ initialTodos }: TodosViewProps) {
  const [todos, setTodos] = useState<TodoWithProject[]>(initialTodos);
  const [searchQuery, setSearchQuery] = useState("");
  const [projectFilter, setProjectFilter] = useState<string>("all");

  // 削除確認ダイアログ用
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [todoToDelete, setTodoToDelete] = useState<number | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  const fetchTodos = () => {
    fetch("/api/todos", { cache: "no-store" })
      .then((res) => res.json())
      .then(setTodos)
      .catch((err) => console.error("TODO一覧の取得に失敗しました:", err));
  };

  const openDeleteDialog = (todoId: number) => {
    setTodoToDelete(todoId);
    setDeleteDialogOpen(true);
  };

  const handleDelete = async () => {
    if (!todoToDelete) return;
    setIsDeleting(true);
    try {
      await fetch(`/api/todos/${todoToDelete}`, { method: "DELETE" });
      fetchTodos();
    } finally {
      setIsDeleting(false);
      setDeleteDialogOpen(false);
      setTodoToDelete(null);
    }
  };

  const projectOptions = useMemo(() => {
    const set = new Set(todos.map((t) => t.managementNumber).filter(Boolean));
    return Array.from(set) as string[];
  }, [todos]);

  const filteredTodos = useMemo(() => {
    let list = todos;
    if (searchQuery.trim()) {
      const q = searchQuery.toLowerCase();
      list = list.filter((t) => t.content.toLowerCase().includes(q));
    }
    if (projectFilter !== "all") {
      list = list.filter((t) => t.managementNumber === projectFilter);
    }
    return list;
  }, [todos, searchQuery, projectFilter]);

  const grouped = useMemo(() => {
    const overdue: TodoWithProject[] = [];
    const today: TodoWithProject[] = [];
    const upcoming: TodoWithProject[] = [];
    const later: TodoWithProject[] = [];
    const completed: TodoWithProject[] = [];
    for (const t of filteredTodos) {
      if (t.completedAt) {
        completed.push(t);
        continue;
      }
      const info = getDueDateInfo(t.dueDate);
      if (info.group === "overdue") overdue.push(t);
      else if (info.group === "today") today.push(t);
      else if (info.group === "upcoming") upcoming.push(t);
      else later.push(t);
    }
    overdue.sort((a, b) => a.dueDate.localeCompare(b.dueDate));
    today.sort((a, b) => (a.managementNumber ?? "").localeCompare(b.managementNumber ?? ""));
    upcoming.sort((a, b) => a.dueDate.localeCompare(b.dueDate));
    later.sort((a, b) => a.dueDate.localeCompare(b.dueDate));
    completed.sort((a, b) => (b.completedAt ?? "").localeCompare(a.completedAt ?? ""));
    return { overdue, today, upcoming, later, completed };
  }, [filteredTodos]);

  const handleReopen = async (todo: TodoWithProject) => {
    // 再開時はメッセージを保持（completedAtのみクリア）
    await fetch(`/api/todos/${todo.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ completedAt: null }),
    });
    fetchTodos();
  };

  const TodoItem = ({ todo }: { todo: TodoWithProject }) => {
    const info = getDueDateInfo(todo.dueDate);
    const dueDateFormatted = formatDateJp(new Date(todo.dueDate + "T00:00:00"));
    const isCompleted = !!todo.completedAt;
    return (
      <div className="flex items-start justify-between gap-3 p-3 rounded-xl border border-border bg-card hover:bg-muted/30 transition-colors">
        <Link
          href={`/projects/${todo.projectId}`}
          className="flex-1 min-w-0 group"
        >
          <p className={`text-sm font-medium group-hover:underline truncate ${isCompleted ? "line-through text-muted-foreground" : "text-foreground"}`}>
            {todo.content}
          </p>
          <div className="flex items-center gap-2 mt-1 flex-wrap">
            <span className="text-xs text-muted-foreground">
              {dueDateFormatted}
              {!isCompleted && <span className="ml-1">({info.label})</span>}
              {isCompleted && todo.completedAt && (
                <span className="ml-1">· 完了: {formatDateJp(new Date(todo.completedAt))}</span>
              )}
            </span>
            {todo.managementNumber && (
              <span className="text-xs text-primary font-medium">
                {todo.managementNumber}
              </span>
            )}
          </div>
          {/* メッセージツリー表示 */}
          {todo.completedMemo && (
            <div className="mt-2 space-y-1">
              {parseTodoMessages(todo.completedMemo).map((msg, idx, arr) => (
                <div key={idx} className="flex items-start gap-2 text-xs text-muted-foreground">
                  <div className="flex flex-col items-center">
                    <div className="w-2 h-2 rounded-full bg-zinc-400 dark:bg-zinc-600 mt-1.5"></div>
                    {idx < arr.length - 1 && (
                      <div className="w-0.5 h-full bg-zinc-300 dark:bg-zinc-700 min-h-[16px]"></div>
                    )}
                  </div>
                  <div className="flex-1 p-2 rounded bg-muted/50 border border-border/50">
                    <p className="text-xs">{msg.message}</p>
                    <p className="text-[10px] text-muted-foreground/70 mt-0.5">
                      {formatDateJp(new Date(msg.createdAt))}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          )}
        </Link>
        <div className="flex items-center gap-1 shrink-0">
          {isCompleted ? (
            <Button
              variant="ghost"
              size="sm"
              className="h-8 text-xs"
              onClick={(e) => {
                e.preventDefault();
                handleReopen(todo);
              }}
            >
              再開
            </Button>
          ) : (
            <>
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8 text-destructive hover:text-destructive"
                onClick={(e) => {
                  e.preventDefault();
                  openDeleteDialog(todo.id);
                }}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
              <Button variant="ghost" size="icon" className="h-8 w-8" asChild>
                <Link href={`/projects/${todo.projectId}`}>
                  <ArrowRight className="h-4 w-4" />
                </Link>
              </Button>
            </>
          )}
        </div>
      </div>
    );
  };

  const Section = ({
    title,
    description,
    icon: Icon,
    items,
    emptyMessage,
    badge,
  }: {
    title: string;
    description: string;
    icon: React.ElementType;
    items: TodoWithProject[];
    emptyMessage: string;
    badge?: React.ReactNode;
  }) => (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <div className="space-y-1">
          <CardTitle className="text-base flex items-center gap-2">
            <Icon className="h-4 w-4" />
            {title}
          </CardTitle>
          <CardDescription className="text-xs">{description}</CardDescription>
        </div>
        {badge}
      </CardHeader>
      <CardContent>
        {items.length === 0 ? (
          <p className="text-sm text-muted-foreground py-4 text-center">{emptyMessage}</p>
        ) : (
          <div className="space-y-2">
            {items.map((todo) => (
              <TodoItem key={todo.id} todo={todo} />
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto max-w-5xl py-10">
        <div className="space-y-6">
          <div className="flex flex-col gap-4">
            <div className="flex items-center gap-2">
              <ListTodo className="h-5 w-5 text-muted-foreground" />
              <h1 className="text-xl font-semibold">TODO</h1>
            </div>
            <p className="text-sm text-muted-foreground">
              今日やること・近日中のTODOを整理して確認できます
            </p>

            <div className="flex flex-wrap items-center gap-3">
              <div className="relative flex-1 min-w-[200px] max-w-sm">
                <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
                <Input
                  placeholder="内容で検索"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="pl-9"
                />
              </div>
              <Select value={projectFilter} onValueChange={setProjectFilter}>
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="案件で絞り込み" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">すべての案件</SelectItem>
                  {projectOptions.map((mn) => (
                    <SelectItem key={mn} value={mn}>
                      {mn}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <div className="grid gap-6 lg:grid-cols-3">
            <Section
              title="超過"
              description="期限を過ぎたTODO"
              icon={AlertCircle}
              items={grouped.overdue}
              emptyMessage="超過したTODOはありません"
              badge={
                grouped.overdue.length > 0 ? (
                  <span className="text-xs font-bold text-destructive">優先</span>
                ) : undefined
              }
            />
            <Section
              title="今日"
              description="本日期限のTODO"
              icon={CalendarIcon}
              items={grouped.today}
              emptyMessage="本日のTODOはありません"
            />
            <Section
              title="近日中"
              description="7日以内に期限のTODO"
              icon={Clock}
              items={grouped.upcoming}
              emptyMessage="近日中のTODOはありません"
            />
          </div>

          {grouped.later.length > 0 && (
            <Section
              title="それ以降"
              description="8日以降に期限のTODO"
              icon={ListTodo}
              items={grouped.later}
              emptyMessage=""
            />
          )}

          {grouped.completed.length > 0 && (
            <Section
              title="完了済み"
              description="完了したTODO"
              icon={CheckCircle2}
              items={grouped.completed}
              emptyMessage=""
            />
          )}
        </div>
      </div>

      {/* 削除確認ダイアログ */}
      <DeleteConfirmDialog
        open={deleteDialogOpen}
        onOpenChange={setDeleteDialogOpen}
        onConfirm={handleDelete}
        title="TODOの削除"
        description="このTODOを削除してもよろしいですか？"
        isLoading={isDeleting}
      />
    </div>
  );
}
</file>

<file path="src/components/HomeTodosView.tsx">
"use client";

import { useState, useMemo } from "react";
import Link from "next/link";
import {
  AlertCircle,
  Calendar as CalendarIcon,
  Clock,
  Trash2,
  ArrowRight,
  Search,
  ListTodo,
  CheckCircle2,
  LayoutDashboard,
  Plus,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { formatDateJp } from "@/lib/timeline";
import { parseTodoMessages, cn } from "@/lib/utils";
import { HomeProjectSearch } from "@/components/HomeProjectSearch";
import { DeleteConfirmDialog } from "@/components/DeleteConfirmDialog";

export type TodoWithProject = {
  id: number;
  projectId: number | null; // nullの場合は案件に紐づかないプレーンTODO
  content: string;
  dueDate: string;
  createdAt: string;
  completedAt: string | null;
  completedMemo: string | null;
  userId: number | null;
  userName: string | null;
  managementNumber: string | null;
};

interface HomeTodosViewProps {
  initialTodos: TodoWithProject[];
  showCreateForm?: boolean; // プレーンTODO作成フォームを表示するか（TODO画面のみ）
}

function getDueDateInfo(dueDateStr: string) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const due = new Date(dueDateStr + "T00:00:00");
  due.setHours(0, 0, 0, 0);
  const diffMs = due.getTime() - today.getTime();
  const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return { group: "overdue" as const, label: `${Math.abs(diffDays)}日超過`, diffDays };
  if (diffDays === 0) return { group: "today" as const, label: "今日", diffDays };
  if (diffDays === 1) return { group: "upcoming" as const, label: "明日", diffDays };
  if (diffDays <= 3) return { group: "upcoming" as const, label: `あと${diffDays}日`, diffDays };
  return { group: "later" as const, label: `あと${diffDays}日`, diffDays };
}

export function HomeTodosView({ initialTodos, showCreateForm = false }: HomeTodosViewProps) {
  const [todos, setTodos] = useState<TodoWithProject[]>(initialTodos);
  const [searchQuery, setSearchQuery] = useState("");
  const [projectFilter, setProjectFilter] = useState<string>("all");

  // プレーンTODO作成フォーム用のstate
  const [newTodoContent, setNewTodoContent] = useState("");
  const [newTodoDueDate, setNewTodoDueDate] = useState("");
  const [newTodoSelectedDate, setNewTodoSelectedDate] = useState<Date | undefined>(undefined);
  const [newTodoCalendarOpen, setNewTodoCalendarOpen] = useState(false);
  const [isCreating, setIsCreating] = useState(false);

  // 削除確認ダイアログ用
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [todoToDelete, setTodoToDelete] = useState<number | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  // 日本時間で現在日時を取得
  const nowJst = new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Tokyo' }));

  const fetchTodos = () => {
    fetch("/api/todos", { cache: "no-store" })
      .then((res) => res.json())
      .then(setTodos)
      .catch((err) => console.error("TODO一覧の取得に失敗しました:", err));
  };

  const openDeleteDialog = (todoId: number) => {
    setTodoToDelete(todoId);
    setDeleteDialogOpen(true);
  };

  const handleDelete = async () => {
    if (!todoToDelete) return;
    setIsDeleting(true);
    try {
      await fetch(`/api/todos/${todoToDelete}`, { method: "DELETE" });
      fetchTodos();
    } finally {
      setIsDeleting(false);
      setDeleteDialogOpen(false);
      setTodoToDelete(null);
    }
  };

  const projectOptions = useMemo(() => {
    const set = new Set(todos.map((t) => t.managementNumber).filter(Boolean));
    return Array.from(set) as string[];
  }, [todos]);

  const filteredTodos = useMemo(() => {
    let list = todos;
    if (searchQuery.trim()) {
      const q = searchQuery.toLowerCase();
      list = list.filter((t) => t.content.toLowerCase().includes(q));
    }
    if (projectFilter !== "all") {
      list = list.filter((t) => t.managementNumber === projectFilter);
    }
    return list;
  }, [todos, searchQuery, projectFilter]);

  const grouped = useMemo(() => {
    const overdue: TodoWithProject[] = [];
    const today: TodoWithProject[] = [];
    const upcoming: TodoWithProject[] = [];
    const later: TodoWithProject[] = [];
    const completed: TodoWithProject[] = [];
    for (const t of filteredTodos) {
      if (t.completedAt) {
        completed.push(t);
        continue;
      }
      const info = getDueDateInfo(t.dueDate);
      if (info.group === "overdue") overdue.push(t);
      else if (info.group === "today") today.push(t);
      else if (info.group === "upcoming") upcoming.push(t);
      else later.push(t);
    }
    overdue.sort((a, b) => a.dueDate.localeCompare(b.dueDate));
    today.sort((a, b) => (a.managementNumber ?? "").localeCompare(b.managementNumber ?? ""));
    upcoming.sort((a, b) => a.dueDate.localeCompare(b.dueDate));
    later.sort((a, b) => a.dueDate.localeCompare(b.dueDate));
    completed.sort((a, b) => (b.completedAt ?? "").localeCompare(a.completedAt ?? ""));
    return { overdue, today, upcoming, later, completed };
  }, [filteredTodos]);

  const handleReopen = async (todo: TodoWithProject) => {
    await fetch(`/api/todos/${todo.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ completedAt: null }),
    });
    fetchTodos();
  };

  // プレーンTODOを作成
  const handleCreatePlainTodo = async () => {
    if (!newTodoContent.trim() || !newTodoDueDate) return;
    setIsCreating(true);
    try {
      await fetch("/api/todos", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          content: newTodoContent.trim(),
          dueDate: newTodoDueDate,
        }),
      });
      setNewTodoContent("");
      setNewTodoDueDate("");
      setNewTodoSelectedDate(undefined);
      fetchTodos();
    } catch (err) {
      console.error("TODO作成に失敗しました:", err);
    } finally {
      setIsCreating(false);
    }
  };

  const TodoItem = ({ todo }: { todo: TodoWithProject }) => {
    const info = getDueDateInfo(todo.dueDate);
    const dueDateFormatted = formatDateJp(new Date(todo.dueDate + "T00:00:00"));
    const isCompleted = !!todo.completedAt;
    const hasProject = todo.projectId !== null;

    const innerContent = (
      <>
        <p className={`text-sm font-medium ${hasProject ? "group-hover:underline" : ""} truncate ${isCompleted ? "line-through text-muted-foreground" : "text-foreground"}`}>
          {todo.content}
        </p>
        <div className="flex items-center gap-2 mt-1 flex-wrap">
          <span className="text-xs text-muted-foreground">
            {dueDateFormatted}
            {!isCompleted && <span className="ml-1">({info.label})</span>}
            {isCompleted && todo.completedAt && (
              <span className="ml-1">· 完了: {formatDateJp(new Date(todo.completedAt))}</span>
            )}
          </span>
          {todo.managementNumber ? (
            <span className="text-xs text-primary font-medium">
              {todo.managementNumber}
            </span>
          ) : (
            <span className="text-xs text-muted-foreground/70 italic">
              個人TODO
            </span>
          )}
          {todo.userName && (
            <span className="text-xs text-muted-foreground">
              · {todo.userName}
            </span>
          )}
        </div>
        {todo.completedMemo && (
          <div className="mt-2 space-y-1">
            {parseTodoMessages(todo.completedMemo).map((msg, idx, arr) => (
              <div key={idx} className="flex items-start gap-2 text-xs text-muted-foreground">
                <div className="flex flex-col items-center">
                  <div className="w-2 h-2 rounded-full bg-zinc-400 dark:bg-zinc-600 mt-1.5"></div>
                  {idx < arr.length - 1 && (
                    <div className="w-0.5 h-full bg-zinc-300 dark:bg-zinc-700 min-h-[16px]"></div>
                  )}
                </div>
                <div className="flex-1 p-2 rounded bg-muted/50 border border-border/50">
                  <p className="text-xs">{msg.message}</p>
                  <p className="text-[10px] text-muted-foreground/70 mt-0.5">
                    {formatDateJp(new Date(msg.createdAt))}
                  </p>
                </div>
              </div>
            ))}
          </div>
        )}
      </>
    );

    return (
      <div className="flex items-start justify-between gap-3 p-3 rounded-xl border border-border bg-card hover:bg-muted/30 transition-colors">
        {hasProject ? (
          <Link href={`/projects/${todo.projectId}`} className="flex-1 min-w-0 group">
            {innerContent}
          </Link>
        ) : (
          <div className="flex-1 min-w-0">
            {innerContent}
          </div>
        )}
        <div className="flex items-center gap-1 shrink-0">
          {isCompleted ? (
            <Button
              variant="ghost"
              size="sm"
              className="h-8 text-xs"
              onClick={(e) => {
                e.preventDefault();
                handleReopen(todo);
              }}
            >
              再開
            </Button>
          ) : (
            <>
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8 text-destructive hover:text-destructive"
                onClick={(e) => {
                  e.preventDefault();
                  openDeleteDialog(todo.id);
                }}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
              {hasProject && (
                <Button variant="ghost" size="icon" className="h-8 w-8" asChild>
                  <Link href={`/projects/${todo.projectId}`}>
                    <ArrowRight className="h-4 w-4" />
                  </Link>
                </Button>
              )}
            </>
          )}
        </div>
      </div>
    );
  };

  const Section = ({
    title,
    description,
    icon: Icon,
    items,
    emptyMessage,
    badge,
  }: {
    title: string;
    description: string;
    icon: React.ElementType;
    items: TodoWithProject[];
    emptyMessage: string;
    badge?: React.ReactNode;
  }) => (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <div className="space-y-1">
          <CardTitle className="text-base flex items-center gap-2">
            <Icon className="h-4 w-4" />
            {title}
          </CardTitle>
          <CardDescription className="text-xs">{description}</CardDescription>
        </div>
        {badge}
      </CardHeader>
      <CardContent>
        {items.length === 0 ? (
          <p className="text-sm text-muted-foreground py-4 text-center">{emptyMessage}</p>
        ) : (
          <div className="space-y-2">
            {items.map((todo) => (
              <TodoItem key={todo.id} todo={todo} />
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  );

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto max-w-6xl py-8 md:py-12">
        <div className="flex flex-col gap-8">
          {/* 案件検索バー */}
          <div className="w-full">
            <HomeProjectSearch />
          </div>

          {/* Header Section */}
          <div className="flex flex-col md:flex-row md:items-end justify-between gap-4">
            <div className="space-y-1">
              <div className="flex items-center gap-2 text-foreground">
                <LayoutDashboard className="h-5 w-5" />
                <span className="text-sm font-semibold uppercase tracking-wider">ダッシュボード</span>
              </div>
              <h1 className="text-3xl font-bold tracking-tight">TODO</h1>
              <p className="text-muted-foreground text-sm">
                {nowJst.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long', timeZone: 'Asia/Tokyo' })}
              </p>
            </div>
            <Button asChild variant="default">
              <Link href="/projects">
                案件一覧を確認
                <ArrowRight className="ml-2 h-4 w-4" />
              </Link>
            </Button>
          </div>

          <Separator />

          {/* Stats Summary */}
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
            <Card>
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-muted-foreground">超過</p>
                    <p className="text-2xl font-bold">{grouped.overdue.length}</p>
                  </div>
                  <AlertCircle className="h-5 w-5 text-muted-foreground" />
                </div>
              </CardContent>
            </Card>
            <Card>
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-muted-foreground">今日</p>
                    <p className="text-2xl font-bold">{grouped.today.length}</p>
                  </div>
                  <CalendarIcon className="h-5 w-5 text-muted-foreground" />
                </div>
              </CardContent>
            </Card>
            <Card>
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-muted-foreground">３日以内</p>
                    <p className="text-2xl font-bold">{grouped.upcoming.length}</p>
                  </div>
                  <Clock className="h-5 w-5 text-muted-foreground" />
                </div>
              </CardContent>
            </Card>
            <Card>
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-muted-foreground">完了</p>
                    <p className="text-2xl font-bold">{grouped.completed.length}</p>
                  </div>
                  <CheckCircle2 className="h-5 w-5 text-muted-foreground" />
                </div>
              </CardContent>
            </Card>
          </div>

          {/* プレーンTODO作成フォーム（TODO画面のみ） */}
          {showCreateForm && (
            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="text-base flex items-center gap-2">
                  <Plus className="h-4 w-4" />
                  TODOを追加
                </CardTitle>
                <CardDescription className="text-xs">
                  案件に紐づかないTODOを作成できます
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="flex flex-col sm:flex-row gap-3">
                  <Input
                    placeholder="TODOの内容を入力"
                    value={newTodoContent}
                    onChange={(e) => setNewTodoContent(e.target.value)}
                    className="flex-1"
                    onKeyDown={(e) => {
                      if (e.key === "Enter" && !e.nativeEvent.isComposing) {
                        handleCreatePlainTodo();
                      }
                    }}
                  />
                  <Popover open={newTodoCalendarOpen} onOpenChange={setNewTodoCalendarOpen}>
                    <PopoverTrigger asChild>
                      <Button
                        type="button"
                        variant="outline"
                        className={cn(
                          "w-full sm:w-[180px] justify-start text-left font-normal",
                          !newTodoSelectedDate && "text-muted-foreground"
                        )}
                      >
                        <CalendarIcon className="mr-2 h-4 w-4" />
                        {newTodoSelectedDate
                          ? formatDateJp(newTodoSelectedDate)
                          : "期日を選択"}
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={newTodoSelectedDate}
                        onSelect={(date) => {
                          setNewTodoSelectedDate(date);
                          if (date) {
                            const y = date.getFullYear();
                            const m = String(date.getMonth() + 1).padStart(2, "0");
                            const d = String(date.getDate()).padStart(2, "0");
                            setNewTodoDueDate(`${y}-${m}-${d}`);
                            setNewTodoCalendarOpen(false);
                          }
                        }}
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                  <Button
                    onClick={handleCreatePlainTodo}
                    disabled={!newTodoContent.trim() || !newTodoDueDate || isCreating}
                  >
                    {isCreating ? "作成中..." : "追加"}
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Filters */}
          <div className="flex flex-wrap items-center gap-3">
            <div className="relative flex-1 min-w-[200px] max-w-sm">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
              <Input
                placeholder="内容で検索"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
              />
            </div>
            <Select value={projectFilter} onValueChange={setProjectFilter}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="案件で絞り込み" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">すべての案件</SelectItem>
                {projectOptions.map((mn) => (
                  <SelectItem key={mn} value={mn}>
                    {mn}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* TODO Grid */}
          <div className="grid gap-6 lg:grid-cols-3">
            <Section
              title="超過"
              description="期限を過ぎたTODO"
              icon={AlertCircle}
              items={grouped.overdue}
              emptyMessage="超過したTODOはありません"
              badge={
                grouped.overdue.length > 0 ? (
                  <span className="text-xs font-bold text-destructive">優先</span>
                ) : undefined
              }
            />
            <Section
              title="今日"
              description="本日期限のTODO"
              icon={CalendarIcon}
              items={grouped.today}
              emptyMessage="本日のTODOはありません"
            />
            <Section
              title="３日以内"
              description="3日以内に期限のTODO"
              icon={Clock}
              items={grouped.upcoming}
              emptyMessage="３日以内のTODOはありません"
            />
          </div>

          {grouped.later.length > 0 && (
            <Section
              title="それ以降"
              description="4日以降に期限のTODO"
              icon={ListTodo}
              items={grouped.later}
              emptyMessage=""
            />
          )}

          {grouped.completed.length > 0 && (
            <Section
              title="完了済み"
              description="完了したTODO"
              icon={CheckCircle2}
              items={grouped.completed}
              emptyMessage=""
            />
          )}
        </div>
      </div>

      {/* 削除確認ダイアログ */}
      <DeleteConfirmDialog
        open={deleteDialogOpen}
        onOpenChange={setDeleteDialogOpen}
        onConfirm={handleDelete}
        title="TODOの削除"
        description="このTODOを削除してもよろしいですか？"
        isLoading={isDeleting}
      />
    </div>
  );
}
</file>

<file path="src/app/api/projects/[id]/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projects, progress, comments } from "@/db/schema";
import { eq } from "drizzle-orm";

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const [project] = await db.select().from(projects).where(eq(projects.id, Number(id)));
  if (!project) {
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }
  return NextResponse.json(project);
}

export async function PUT(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const body = await request.json();
  const [result] = await db
    .update(projects)
    .set({
      managementNumber: body.managementNumber,
      manager: body.manager,
      client: body.client,
      projectNumber: body.projectNumber,
      completionMonth: body.completionMonth || null,
      address: body.address || null,
      coordinates: body.coordinates || null,
      landowner1: body.landowner1 || null,
      landowner2: body.landowner2 || null,
      landowner3: body.landowner3 || null,
      landCategory1: body.landCategory1 || null,
      landCategory2: body.landCategory2 || null,
      landCategory3: body.landCategory3 || null,
      landArea1: body.landArea1 || null,
      landArea2: body.landArea2 || null,
      landArea3: body.landArea3 || null,
    })
    .where(eq(projects.id, Number(id)))
    .returning();
  return NextResponse.json(result);
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const projectId = Number(id);

  // 関連するコメントを先に削除
  await db.delete(comments).where(eq(comments.projectId, projectId));

  // 関連する進捗を削除
  await db.delete(progress).where(eq(progress.projectId, projectId));

  // 案件を削除
  await db.delete(projects).where(eq(projects.id, projectId));

  return NextResponse.json({ success: true });
}
</file>

<file path="src/app/api/projects/route.ts">
import { NextResponse } from "next/server";
import { db } from "@/db";
import { projects, progress, comments, todos } from "@/db/schema";
import { calculateTimeline } from "@/lib/timeline";

// 一覧は常に最新を返すためキャッシュしない
export const dynamic = "force-dynamic";

// 全件取得（超過情報・コメント・TODO検索用テキスト付き）
export async function GET() {
  const allProjects = await db.select().from(projects);
  const allProgress = await db.select().from(progress);
  const allComments = await db.select().from(comments);
  const allTodos = await db.select().from(todos);

  const now = new Date();

  // 各案件に超過情報・コメント・TODO検索用テキストを追加
  const projectsWithOverdue = allProjects.map((project) => {
    const projectProgress = allProgress.filter((p) => p.projectId === project.id);
    const projectComments = allComments.filter((c) => c.projectId === project.id);
    const projectTodos = allTodos.filter((t) => t.projectId === project.id);
    const commentSearchText = projectComments.map((c) => c.content).join(" ");
    const todoSearchText = projectTodos.map((t) => t.content).join(" ");

    let hasOverdue = false;

    if (projectProgress.length > 0) {
      // 進捗データがある場合: 未完了かつ予定日が過去の進捗があるかチェック
      hasOverdue = projectProgress.some((p) => {
        if (p.status === "completed") return false;
        const dueDate = new Date(p.createdAt);
        const daysUntilDue = Math.ceil((dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        return daysUntilDue < 0;
      });
    } else if (project.completionMonth) {
      // 進捗データがない場合: calculateTimelineで計算して超過判定
      const timeline = calculateTimeline(project.completionMonth, false);
      hasOverdue = timeline.some((phase) => {
        const daysUntilDue = Math.ceil((phase.date.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        return daysUntilDue < 0;
      });
    }

    return {
      ...project,
      hasOverdue,
      commentSearchText,
      todoSearchText,
    };
  });

  return NextResponse.json(projectsWithOverdue);
}

// 新規追加
export async function POST(request: Request) {
  const body = await request.json();
  const [result] = await db.insert(projects).values(body).returning();
  return NextResponse.json(result);
}
</file>

<file path="src/app/projects/page.tsx">
import { db } from "@/db";
import { projects, progress, comments, todos } from "@/db/schema";
import { calculateTimeline } from "@/lib/timeline";
import ProjectsView from "./ProjectsView";

// 他画面から戻ったときに常に最新一覧を表示するためキャッシュしない
export const dynamic = "force-dynamic";

export default async function ProjectsPage() {
  const allProjects = await db.select().from(projects);
  const allProgress = await db.select().from(progress);
  const allComments = await db.select().from(comments);
  const allTodos = await db.select().from(todos);

  const now = new Date();

  // 各案件に超過情報・コメント・TODO検索用テキストを追加
  const projectsWithOverdue = allProjects.map((project) => {
    const projectProgress = allProgress.filter((p) => p.projectId === project.id);
    const projectComments = allComments.filter((c) => c.projectId === project.id);
    const projectTodos = allTodos.filter((t) => t.projectId === project.id);
    const commentSearchText = projectComments.map((c) => c.content).join(" ");
    const todoSearchText = projectTodos.map((t) => t.content).join(" ");

    let hasOverdue = false;

    if (projectProgress.length > 0) {
      // 進捗データがある場合: 未完了かつ予定日が過去の進捗があるかチェック
      hasOverdue = projectProgress.some((p) => {
        if (p.status === "completed") return false;
        const dueDate = new Date(p.createdAt);
        const daysUntilDue = Math.ceil((dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        return daysUntilDue < 0;
      });
    } else if (project.completionMonth) {
      // 進捗データがない場合: calculateTimelineで計算して超過判定
      const timeline = calculateTimeline(project.completionMonth, false);
      hasOverdue = timeline.some((phase) => {
        const daysUntilDue = Math.ceil((phase.date.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        return daysUntilDue < 0;
      });
    }

    return {
      ...project,
      hasOverdue,
      commentSearchText,
      todoSearchText,
    };
  });

  return <ProjectsView initialProjects={projectsWithOverdue} />;
}
</file>

<file path="src/app/schedule/page.tsx">
"use client";

import { useState } from "react";
import { Calendar as CalendarIcon, Clock, Check, Circle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Card, CardContent } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { calculateWorkflowTimeline, formatDateJp, type WorkflowTimelinePhase, WORKFLOW_PHASES, type ResponsibleType } from "@/lib/timeline";
import { cn } from "@/lib/utils";

function formatStartDate(date: Date): string {
  const y = date.getFullYear();
  const m = date.getMonth() + 1;
  const d = date.getDate();
  return `${y}-${String(m).padStart(2, "0")}-${String(d).padStart(2, "0")}`;
}

// 担当者バッジの色定義
const responsibleColors: Record<ResponsibleType, string> = {
  '事務': 'bg-blue-600',
  '工務': 'bg-green-600',
  '設計': 'bg-purple-600',
  '営業': 'bg-orange-600',
};

// 担当者バッジコンポーネント
function ResponsibleBadges({ responsibles }: { responsibles?: ReadonlyArray<ResponsibleType> }) {
  if (!responsibles || responsibles.length === 0) return null;

  return (
    <div className="flex items-center gap-1.5 shrink-0">
      {responsibles.map((responsible, index) => (
        <div key={index} className="flex items-center gap-1.5">
          <span className={cn(
            "px-2 py-0.5 rounded text-xs font-medium text-white",
            responsibleColors[responsible]
          )}>
            {responsible}
          </span>
          {index < responsibles.length - 1 && (
            <span className="text-muted-foreground text-xs">→</span>
          )}
        </div>
      ))}
    </div>
  );
}


export default function SchedulePage() {
  const [client, setClient] = useState("");
  const [completionDate, setCompletionDate] = useState<Date | undefined>(undefined);
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const [dateText, setDateText] = useState("");
  const [timeline, setTimeline] = useState<WorkflowTimelinePhase[]>([]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!completionDate) return;

    const calculatedTimeline = calculateWorkflowTimeline(completionDate);
    setTimeline(calculatedTimeline);
  };

  // サブフェーズがあるフェーズのみ抽出
  const phasesWithSubPhases = timeline.filter(item => item.subPhases && item.subPhases.length > 0);

  const hasTimeline = timeline.length > 0;

  return (
    <div className={cn(
      "min-h-screen flex flex-col items-center bg-background px-4 py-8",
      !hasTimeline && "justify-center"
    )}>
      {/* タイトル */}
      <div className="mb-8">
        <h1 className="text-4xl font-normal tracking-tight text-foreground">
          スケジュール
        </h1>
      </div>

      {/* 入力フォーム */}
      <div className={cn(
        "w-full space-y-6",
        hasTimeline ? "max-w-6xl" : "max-w-2xl"
      )}>
        <div className={cn(
          "bg-card rounded-[2rem] border border-border shadow-lg p-8 space-y-6",
          hasTimeline && "max-w-2xl mx-auto"
        )}>
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* 販売先 */}
            <div className="space-y-2">
              <Label htmlFor="client" className="text-sm font-medium text-foreground">
                販売先
              </Label>
              <Select value={client} onValueChange={setClient} required>
                <SelectTrigger id="client" className="w-full">
                  <SelectValue placeholder="選択してください" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="双日">双日</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* 開始日 */}
            <div className="space-y-2">
              <Label htmlFor="start-date" className="text-sm font-medium text-foreground">
                開始日
              </Label>
              <div className="flex gap-2">
                <Input
                  id="start-date"
                  value={dateText}
                  onChange={(e) => {
                    const value = e.target.value;
                    setDateText(value);
                    const match = value.match(/^(\d{4})[./-](\d{1,2})[./-](\d{1,2})$/);
                    if (match) {
                      const [, y, m, d] = match;
                      const year = Number(y);
                      const month = Number(m);
                      const day = Number(d);
                      if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                        const parsed = new Date(year, month - 1, day);
                        if (!isNaN(parsed.getTime())) {
                          setCompletionDate(parsed);
                        }
                      }
                    } else if (value === "") {
                      setCompletionDate(undefined);
                    }
                  }}
                  placeholder="例: 2026-03-15"
                  className="flex-1"
                  required
                />
                <Popover open={isCalendarOpen} onOpenChange={setIsCalendarOpen}>
                  <PopoverTrigger asChild>
                    <Button type="button" variant="outline" size="icon" className="shrink-0">
                      <CalendarIcon className="h-4 w-4" />
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="end">
                    <Calendar
                      mode="single"
                      selected={completionDate}
                      onSelect={(d) => {
                        if (d) {
                          setCompletionDate(d);
                          setDateText(formatStartDate(d));
                        }
                        setIsCalendarOpen(false);
                      }}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              </div>
              <p className="text-xs text-muted-foreground">
                年月日をハイフン、スラッシュ、またはドット区切りで入力してください
              </p>
            </div>

            {/* 生成ボタン */}
            <div className="pt-2">
              <Button
                type="submit"
                size="lg"
                className="w-full"
                disabled={!client || !completionDate}
              >
                スケジュールを生成
              </Button>
            </div>
          </form>
        </div>

        {/* 横型タイムライン表示 */}
        {timeline.length > 0 && (
          <div className="bg-card rounded-[2rem] border border-border shadow-lg p-6 space-y-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <div className="flex items-center gap-3">
              <Clock className="h-5 w-5 text-primary" />
              <h2 className="text-xl font-semibold">{client}様のスケジュール</h2>
            </div>

            {/* 横型タイムライン（スクロールなし・大きなサークル） */}
            <div className="w-full py-6">
              {/* ノード行 */}
              <div className="flex items-center">
                {timeline.map((item, index) => {
                  const now = new Date();
                  const isPast = item.date ? item.date < now : false;
                  const hasDate = item.date !== undefined || (item.startDate !== undefined && item.endDate !== undefined);

                  return (
                    <div key={item.key} className="flex items-center flex-1">
                      {/* ノード */}
                      <div className="flex flex-col items-center flex-1">
                        <div
                          className={cn(
                            "flex h-14 w-14 shrink-0 items-center justify-center rounded-full border-3 shadow-md transition-all",
                            item.key === "waiting_period"
                              ? "border-secondary bg-secondary"
                              : !hasDate
                              ? "border-gray-300 bg-gray-100 dark:border-gray-600 dark:bg-gray-800"
                              : isPast
                              ? "border-green-500 bg-green-500"
                              : "border-primary/50 bg-primary/10"
                          )}
                        >
                          {item.key === "waiting_period" ? (
                            <Clock className="h-6 w-6 text-white" />
                          ) : !hasDate ? (
                            <span className="text-lg font-bold text-gray-400">{index + 1}</span>
                          ) : isPast ? (
                            <Check className="h-6 w-6 text-white" />
                          ) : (
                            <span className="text-lg font-bold text-primary">{index + 1}</span>
                          )}
                        </div>
                      </div>

                      {/* 接続線 */}
                      {index < timeline.length - 1 && (
                        <div
                          className={cn(
                            "h-1 w-4 -mx-2 z-10",
                            isPast
                              ? "bg-green-500"
                              : "bg-muted-foreground/30"
                          )}
                        />
                      )}
                    </div>
                  );
                })}
              </div>

              {/* タイトル・日付行 */}
              <div className="flex items-stretch mt-4">
                {timeline.map((item) => {
                  const now = new Date();
                  const isPast = item.date ? item.date < now : false;
                  const hasDate = item.date !== undefined || (item.startDate !== undefined && item.endDate !== undefined);
                  const weekdays = ['日', '月', '火', '水', '木', '金', '土'];

                  return (
                    <div key={`label-${item.key}`} className="flex-1 flex flex-col items-center px-1">
                      {/* タイトル（高さ固定） */}
                      <div className="h-8 flex items-center justify-center mb-2">
                        <p className={cn(
                          "text-xs font-semibold leading-tight text-center line-clamp-2",
                          !hasDate || !isPast ? "text-muted-foreground" : "text-foreground"
                        )}>
                          {item.title}
                        </p>
                      </div>

                      {/* 日付カード */}
                      {item.startDate ? (
                        <div className={cn(
                          "flex flex-col items-center rounded-lg border overflow-hidden min-w-[52px] shadow-sm",
                          isPast
                            ? "border-green-500 bg-green-50 dark:bg-green-950"
                            : "border-primary/30 bg-card"
                        )}>
                          {/* 月ヘッダー */}
                          <div className={cn(
                            "w-full text-center py-0.5 text-[10px] font-bold text-white",
                            isPast ? "bg-green-500" : "bg-primary"
                          )}>
                            {item.startDate.getMonth() + 1}月
                          </div>
                          {/* 日 */}
                          <div className="py-1 px-2 text-center">
                            <span className={cn(
                              "text-xl font-bold",
                              isPast ? "text-green-600 dark:text-green-400" : "text-foreground"
                            )}>
                              {item.startDate.getDate()}
                            </span>
                            <span className={cn(
                              "text-[10px] ml-0.5",
                              item.startDate.getDay() === 0 ? "text-red-500" :
                              item.startDate.getDay() === 6 ? "text-blue-500" :
                              "text-muted-foreground"
                            )}>
                              ({weekdays[item.startDate.getDay()]})
                            </span>
                          </div>
                        </div>
                      ) : (
                        <div className="flex flex-col items-center rounded-lg border-2 border-dashed border-muted-foreground/30 bg-muted/50 min-w-[52px]">
                          {/* 未定ヘッダー */}
                          <div className="w-full text-center py-0.5 text-[10px] font-bold text-muted-foreground bg-muted">
                            --月
                          </div>
                          {/* 未定本体 */}
                          <div className="py-1 px-2 text-center">
                            <span className="text-lg font-bold text-muted-foreground">--</span>
                            <span className="text-[10px] ml-0.5 text-muted-foreground/70">(-)</span>
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>

            {/* 各フェーズの詳細タスク（アコーディオン形式・展開状態） */}
            {phasesWithSubPhases.length > 0 && (
              <Accordion
                type="multiple"
                className="w-full space-y-3"
                defaultValue={phasesWithSubPhases.map((item) => item.key)}
              >
                  {phasesWithSubPhases.map((item) => {
                    const now = new Date();
                    const isPast = item.date ? item.date < now : false;
                    const hasDate = item.date !== undefined || (item.startDate !== undefined && item.endDate !== undefined);
                    const workflowPhase = WORKFLOW_PHASES.find(phase => phase.key === item.key);
                    const originalIndex = timeline.findIndex(t => t.key === item.key);

                    return (
                      <AccordionItem
                        key={item.key}
                        value={item.key}
                        className={cn(
                          "border rounded-lg overflow-hidden",
                          item.key === "waiting_period" && "bg-secondary/10"
                        )}
                      >
                        <AccordionTrigger className="hover:no-underline px-5 py-4 hover:bg-muted/50">
                          <div className="flex items-center gap-4 w-full">
                            {/* 順番号 */}
                            <div className="flex items-center justify-center w-8 h-8 rounded-full bg-muted text-muted-foreground text-sm font-semibold shrink-0">
                              {originalIndex + 1}
                            </div>

                            {/* ステータスノード */}
                            <div
                              className={cn(
                                "flex h-10 w-10 shrink-0 items-center justify-center rounded-full border-2",
                                item.key === "waiting_period"
                                  ? "border-secondary bg-secondary"
                                  : !hasDate
                                  ? "border-gray-400 bg-background"
                                  : isPast
                                  ? "border-green-500 bg-green-500"
                                  : "border-muted-foreground bg-background"
                              )}
                            >
                              {item.key === "waiting_period" ? (
                                <Clock className="h-5 w-5 text-white" />
                              ) : !hasDate ? (
                                <Circle className="h-5 w-5 text-gray-400" />
                              ) : isPast ? (
                                <Check className="h-5 w-5 text-white" />
                              ) : (
                                <Circle className="h-5 w-5 text-muted-foreground" />
                              )}
                            </div>

                            {/* タイトルと期間 */}
                            <div className="flex-1 text-left min-w-0">
                              <div className="flex items-center gap-3 flex-wrap">
                                <p className={cn(
                                  "text-base font-semibold",
                                  !hasDate || !isPast ? "text-muted-foreground" : "text-foreground"
                                )}>
                                  {item.title}
                                </p>
                                <span className={cn(
                                  "text-xs px-2 py-1 rounded",
                                  item.key === "waiting_period"
                                    ? "bg-secondary text-secondary-foreground"
                                    : "bg-muted text-muted-foreground"
                                )}>
                                  {item.phase}
                                </span>
                              </div>
                              {item.startDate && item.endDate && (
                                <p className="text-sm text-primary mt-1">
                                  {formatDateJp(item.startDate)}
                                  {item.key !== "initial_acquisition" && item.key !== "submission_decision" && (
                                    <span className="text-muted-foreground"> ～ {formatDateJp(item.endDate)}</span>
                                  )}
                                  {workflowPhase && workflowPhase.duration !== undefined && workflowPhase.duration > 0 && (
                                    <span className="text-muted-foreground ml-2">({workflowPhase.duration}営業日)</span>
                                  )}
                                </p>
                              )}
                            </div>

                            {/* サブタスク数 */}
                            <span className="text-xs text-muted-foreground bg-muted px-2 py-1 rounded shrink-0">
                              {item.subPhases!.length}件のタスク
                            </span>
                          </div>
                        </AccordionTrigger>

                        <AccordionContent className="px-5 pb-5">
                          <div className="ml-[72px] space-y-3 border-l-2 border-muted pl-6">
                            {item.subPhases!.map((subPhase, subIndex) => (
                              <div
                                key={subPhase.key}
                                className="flex items-start gap-4 p-4 rounded-lg border bg-card hover:bg-muted/30 transition-colors"
                              >
                                {/* サブタスク番号 */}
                                <div className="flex items-center justify-center w-6 h-6 rounded-full bg-primary/10 text-primary text-xs font-semibold shrink-0 mt-0.5">
                                  {subIndex + 1}
                                </div>

                                <div className="flex-1 min-w-0">
                                  <div className="space-y-2">
                                    <div className="flex items-center gap-3 flex-wrap">
                                      <span className="text-sm font-medium">{subPhase.title}</span>
                                      <ResponsibleBadges responsibles={subPhase.responsibles} />
                                    </div>
                                    {subPhase.note && (
                                      <p className="text-sm text-amber-600 dark:text-amber-400 font-medium bg-amber-50 dark:bg-amber-950 px-3 py-1.5 rounded-lg">
                                        {subPhase.note}
                                      </p>
                                    )}
                                    {subPhase.date && (
                                      <p className="text-sm">
                                        <span className="text-primary font-medium">予定: {formatDateJp(subPhase.date)}</span>
                                        {subPhase.duration !== undefined && subPhase.duration > 0 && (
                                          <span className="text-muted-foreground ml-2">
                                            ({subPhase.duration}営業日)
                                          </span>
                                        )}
                                      </p>
                                    )}
                                  </div>
                                </div>
                              </div>
                            ))}
                          </div>
                        </AccordionContent>
                      </AccordionItem>
                    );
                  })}
                </Accordion>
              )}
          </div>
        )}

        {/* 説明テキスト（タイムライン未表示時のみ） */}
        {!hasTimeline && (
          <p className="text-center text-sm text-muted-foreground">
            販売先と開始日を入力して「スケジュールを生成」ボタンを押してください
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/todos/TimelineView.tsx">
"use client";

import { useState, useMemo, useCallback, memo } from "react";
import Link from "next/link";
import {
  GitBranch,
  Search,
  ChevronRight,
  ChevronLeft,
  Calendar as CalendarIcon,
  Check,
  Clock,
  Pencil,
  Filter,
  X,
  ChevronDown,
  Loader2,
  AlertTriangle,
  Flame,
  Plus,
  ListTodo,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Label } from "@/components/ui/label";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Checkbox } from "@/components/ui/checkbox";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { cn } from "@/lib/utils";
import type { Project, Progress, NewProject } from "@/db/schema";

const MONTHS = ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"];
const MANAGER_OPTIONS = ["吉國", "刎本", "松下", "佐東", "川田", "近永", "その他"];

// フェーズ定義
const PHASES = [
  { key: "agreement", title: "合意書", order: 1 },
  { key: "submission", title: "案件提出", order: 2 },
  { key: "survey", title: "現調", order: 3 },
  { key: "land_sale_contract", title: "土地売買契約", order: 4 },
  { key: "land_contract", title: "土地契約", order: 5 },
  { key: "legal_application", title: "法令申請", order: 6 },
  { key: "legal_approval", title: "法令許可", order: 7 },
  { key: "power_application", title: "電力申請", order: 8 },
  { key: "power_response", title: "電力回答", order: 9 },
  { key: "ss_request", title: "SS依頼", order: 10 },
  { key: "ss_execution", title: "SS実施", order: 11 },
  { key: "land_settlement", title: "土地決済", order: 12 },
  { key: "order", title: "発注", order: 13 },
  { key: "construction_start", title: "着工", order: 14 },
  { key: "grid_connection", title: "連系", order: 15 },
  { key: "completion", title: "完工", order: 16 },
] as const;

type PhaseKey = (typeof PHASES)[number]["key"];

interface ProjectWithProgress extends Project {
  progressItems: Progress[];
}

interface TimelineViewProps {
  projects: ProjectWithProgress[];
}

function formatDateShort(date: Date | null): string {
  if (!date) return "-";
  const m = date.getMonth() + 1;
  const d = date.getDate();
  return `${m}/${d}`;
}

function formatDateFull(date: Date | null): string {
  if (!date) return "-";
  const y = date.getFullYear();
  const m = date.getMonth() + 1;
  const d = date.getDate();
  return `${y}.${m}.${d}`;
}

export default function TimelineView({ projects: initialProjects }: TimelineViewProps) {
  const [projects, setProjects] = useState<ProjectWithProgress[]>(initialProjects);
  const [searchQuery, setSearchQuery] = useState("");
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [editingProject, setEditingProject] = useState<ProjectWithProgress | null>(null);
  const [editingPhase, setEditingPhase] = useState<(typeof PHASES)[number] | null>(null);
  const [plannedDate, setPlannedDate] = useState<Date | undefined>(undefined);
  const [completedDate, setCompletedDate] = useState<Date | undefined>(undefined);
  const [phaseMemo, setPhaseMemo] = useState("");
  const [plannedCalendarOpen, setPlannedCalendarOpen] = useState(false);
  const [completedCalendarOpen, setCompletedCalendarOpen] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // 案件登録用のstate
  const [projectDialogOpen, setProjectDialogOpen] = useState(false);
  const [projectForm, setProjectForm] = useState<NewProject>({
    managementNumber: "",
    manager: "",
    client: "",
    projectNumber: "",
    completionMonth: "",
  });
  const [projectCalendarOpen, setProjectCalendarOpen] = useState(false);
  const [projectCalendarYear, setProjectCalendarYear] = useState(new Date().getFullYear());
  const [isProjectSubmitting, setIsProjectSubmitting] = useState(false);

  // アラートダイアログ用のstate
  const [alertDialogOpen, setAlertDialogOpen] = useState(false);
  const [alertDialogTitle, setAlertDialogTitle] = useState("");
  const [alertDialogMessage, setAlertDialogMessage] = useState("");

  // フィルター機能用のstate
  const [filterOpen, setFilterOpen] = useState(false);
  const [selectedProjectIds, setSelectedProjectIds] = useState<Set<number>>(new Set());
  const [filterSearchQuery, setFilterSearchQuery] = useState("");

  // フィルター内の検索でフィルタリングされた案件リスト
  const filterableProjects = useMemo(() => {
    if (!filterSearchQuery.trim()) return projects;
    const q = filterSearchQuery.toLowerCase();
    return projects.filter(
      (p) =>
        p.managementNumber.toLowerCase().includes(q) ||
        p.client.toLowerCase().includes(q)
    );
  }, [projects, filterSearchQuery]);

  // チェックボックスの選択/解除
  const toggleProjectSelection = (projectId: number) => {
    setSelectedProjectIds((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(projectId)) {
        newSet.delete(projectId);
      } else {
        newSet.add(projectId);
      }
      return newSet;
    });
  };

  // 全選択/全解除
  const selectAll = () => {
    setSelectedProjectIds(new Set(filterableProjects.map((p) => p.id)));
  };

  const clearAll = () => {
    setSelectedProjectIds(new Set());
  };

  // フィルターをクリア
  const clearFilter = () => {
    setSelectedProjectIds(new Set());
    setFilterSearchQuery("");
  };

  // フィルタリングされた案件リスト（テキスト検索 + チェックボックス選択）
  const filteredProjects = useMemo(() => {
    let result = projects;

    // テキスト検索フィルター
    if (searchQuery.trim()) {
      const q = searchQuery.toLowerCase();
      result = result.filter(
        (p) =>
          p.managementNumber.toLowerCase().includes(q) ||
          p.client.toLowerCase().includes(q)
      );
    }

    // チェックボックス選択フィルター
    if (selectedProjectIds.size > 0) {
      result = result.filter((p) => selectedProjectIds.has(p.id));
    }

    return result;
  }, [projects, searchQuery, selectedProjectIds]);

  const isFiltered = selectedProjectIds.size > 0;

  // 今日の日付（時刻を除去）
  const today = useMemo(() => {
    const d = new Date();
    d.setHours(0, 0, 0, 0);
    return d;
  }, []);

  // プロジェクトのフェーズ状況を取得
  const getPhaseStatus = (project: ProjectWithProgress, phaseTitle: string) => {
    const progressItem = project.progressItems.find((p) => p.title === phaseTitle);
    if (!progressItem) return { status: "pending", date: null };

    if (progressItem.status === "completed" && progressItem.completedAt) {
      return { status: "completed", date: new Date(progressItem.completedAt) };
    }
    if (progressItem.createdAt) {
      return { status: "planned", date: new Date(progressItem.createdAt) };
    }
    return { status: "pending", date: null };
  };

  // 現在のフェーズを特定
  const getCurrentPhaseIndex = (project: ProjectWithProgress): number => {
    for (let i = PHASES.length - 1; i >= 0; i--) {
      const status = getPhaseStatus(project, PHASES[i].title);
      if (status.status === "completed") {
        return i + 1; // 完了したフェーズの次
      }
    }
    return 0;
  };

  // アラート判定: 未完了フェーズで期日未設定または期日超過
  const isPhaseAlert = (project: ProjectWithProgress, phaseIndex: number): boolean => {
    const phase = PHASES[phaseIndex];
    const phaseStatus = getPhaseStatus(project, phase.title);

    // 完了済みはアラートなし
    if (phaseStatus.status === "completed") return false;

    // 期日未設定は無条件でアラート
    if (!phaseStatus.date) return true;

    // 期日超過（未完了で期日を過ぎているもの）
    const dueDate = new Date(phaseStatus.date);
    dueDate.setHours(0, 0, 0, 0);
    return dueDate < today;
  };

  // アラート数を計算（表示中の案件のすべてのアラートフェーズをカウント）
  const alertCount = useMemo(() => {
    let count = 0;
    for (const project of filteredProjects) {
      for (let i = 0; i < PHASES.length; i++) {
        if (isPhaseAlert(project, i)) {
          count++;
        }
      }
    }
    return count;
  }, [filteredProjects, today]);

  const openEditDialog = (project: ProjectWithProgress, phase: (typeof PHASES)[number]) => {
    setEditingProject(project);
    setEditingPhase(phase);
    const progressItem = project.progressItems.find((p) => p.title === phase.title);
    // 予定日（createdAt）と完了日（completedAt）を個別に設定
    setPlannedDate(progressItem?.createdAt ? new Date(progressItem.createdAt) : undefined);
    setCompletedDate(progressItem?.completedAt ? new Date(progressItem.completedAt) : undefined);
    setPhaseMemo(progressItem?.description || "");
    setEditDialogOpen(true);
  };

  // アラートダイアログを表示するヘルパー
  const showAlert = useCallback((title: string, message: string) => {
    setAlertDialogTitle(title);
    setAlertDialogMessage(message);
    setAlertDialogOpen(true);
  }, []);

  // 保存処理（予定日・完了日・メモを保存）
  const handleSave = useCallback(async () => {
    if (!editingProject || !editingPhase) {
      setEditDialogOpen(false);
      return;
    }

    // 予定日も完了日も未設定の場合は保存しない
    if (!plannedDate && !completedDate) {
      setEditDialogOpen(false);
      return;
    }

    setIsSaving(true);
    try {
      const existingProgress = editingProject.progressItems.find(
        (p) => p.title === editingPhase.title
      );

      const plannedDateStr = plannedDate ? plannedDate.toISOString() : null;
      const completedDateStr = completedDate ? completedDate.toISOString() : null;
      const newStatus = completedDate ? "completed" : "planned";

      if (existingProgress) {
        await fetch(`/api/projects/${editingProject.id}/progress`, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            progressId: existingProgress.id,
            status: newStatus,
            createdAt: plannedDateStr,
            completedAt: completedDateStr,
            description: phaseMemo || null,
          }),
        });
      } else {
        await fetch(`/api/projects/${editingProject.id}/progress`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            title: editingPhase.title,
            status: newStatus,
            createdAt: plannedDateStr || new Date().toISOString(),
            completedAt: completedDateStr,
            description: phaseMemo || null,
          }),
        });
      }

      // ローカル状態を更新
      setProjects((prev) =>
        prev.map((p) => {
          if (p.id !== editingProject.id) return p;
          const updatedProgressItems = existingProgress
            ? p.progressItems.map((item) =>
                item.id === existingProgress.id
                  ? {
                      ...item,
                      status: newStatus as "planned" | "completed",
                      createdAt: plannedDateStr || item.createdAt,
                      completedAt: completedDateStr,
                      description: phaseMemo || null,
                    }
                  : item
              )
            : [
                ...p.progressItems,
                {
                  id: Date.now(),
                  projectId: p.id,
                  title: editingPhase.title,
                  description: phaseMemo || null,
                  status: newStatus as "planned" | "completed",
                  createdAt: plannedDateStr || new Date().toISOString(),
                  completedAt: completedDateStr,
                },
              ];
          return { ...p, progressItems: updatedProgressItems };
        })
      );

      setEditDialogOpen(false);
    } catch (error) {
      console.error("保存に失敗しました:", error);
      showAlert("エラー", "保存に失敗しました。もう一度お試しください。");
    } finally {
      setIsSaving(false);
    }
  }, [editingProject, editingPhase, plannedDate, completedDate, phaseMemo, showAlert]);

  // 完了ボタン処理（完了日を今日に設定して保存）
  const handleMarkComplete = useCallback(async () => {
    if (!editingProject || !editingPhase) return;

    const now = new Date();
    setCompletedDate(now);

    setIsSaving(true);
    try {
      const existingProgress = editingProject.progressItems.find(
        (p) => p.title === editingPhase.title
      );

      const plannedDateStr = plannedDate ? plannedDate.toISOString() : new Date().toISOString();
      const completedDateStr = now.toISOString();

      if (existingProgress) {
        await fetch(`/api/projects/${editingProject.id}/progress`, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            progressId: existingProgress.id,
            status: "completed",
            createdAt: plannedDateStr,
            completedAt: completedDateStr,
            description: phaseMemo || null,
          }),
        });
      } else {
        await fetch(`/api/projects/${editingProject.id}/progress`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            title: editingPhase.title,
            status: "completed",
            createdAt: plannedDateStr,
            completedAt: completedDateStr,
            description: phaseMemo || null,
          }),
        });
      }

      setProjects((prev) =>
        prev.map((p) => {
          if (p.id !== editingProject.id) return p;
          const updatedProgressItems = existingProgress
            ? p.progressItems.map((item) =>
                item.id === existingProgress.id
                  ? {
                      ...item,
                      status: "completed" as const,
                      createdAt: plannedDateStr,
                      completedAt: completedDateStr,
                      description: phaseMemo || null,
                    }
                  : item
              )
            : [
                ...p.progressItems,
                {
                  id: Date.now(),
                  projectId: p.id,
                  title: editingPhase.title,
                  description: phaseMemo || null,
                  status: "completed" as const,
                  createdAt: plannedDateStr,
                  completedAt: completedDateStr,
                },
              ];
          return { ...p, progressItems: updatedProgressItems };
        })
      );

      setEditDialogOpen(false);
    } catch (error) {
      console.error("完了処理に失敗しました:", error);
      showAlert("エラー", "完了処理に失敗しました。もう一度お試しください。");
    } finally {
      setIsSaving(false);
    }
  }, [editingProject, editingPhase, plannedDate, phaseMemo, showAlert]);

  // 未完了に戻す処理
  const handleMarkIncomplete = useCallback(async () => {
    if (!editingProject || !editingPhase) return;

    setCompletedDate(undefined);

    setIsSaving(true);
    try {
      const existingProgress = editingProject.progressItems.find(
        (p) => p.title === editingPhase.title
      );

      if (!existingProgress) {
        setIsSaving(false);
        return;
      }

      const plannedDateStr = plannedDate ? plannedDate.toISOString() : existingProgress.createdAt;

      await fetch(`/api/projects/${editingProject.id}/progress`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          progressId: existingProgress.id,
          status: "planned",
          createdAt: plannedDateStr,
          completedAt: null,
          description: phaseMemo || null,
        }),
      });

      setProjects((prev) =>
        prev.map((p) => {
          if (p.id !== editingProject.id) return p;
          const updatedProgressItems = p.progressItems.map((item) =>
            item.id === existingProgress.id
              ? {
                  ...item,
                  status: "planned" as const,
                  createdAt: plannedDateStr,
                  completedAt: null,
                  description: phaseMemo || null,
                }
              : item
          );
          return { ...p, progressItems: updatedProgressItems };
        })
      );

      setEditDialogOpen(false);
    } catch (error) {
      console.error("未完了処理に失敗しました:", error);
      showAlert("エラー", "未完了処理に失敗しました。もう一度お試しください。");
    } finally {
      setIsSaving(false);
    }
  }, [editingProject, editingPhase, plannedDate, phaseMemo, showAlert]);

  // TODOに追加処理
  const handleAddTodo = useCallback(async () => {
    if (!editingProject || !editingPhase || !plannedDate) {
      showAlert("入力エラー", "予定日を設定してください");
      return;
    }

    setIsSaving(true);
    try {
      const dueDateStr = `${plannedDate.getFullYear()}-${String(plannedDate.getMonth() + 1).padStart(2, "0")}-${String(plannedDate.getDate()).padStart(2, "0")}`;
      const content = `【${editingPhase.title}】${phaseMemo || editingPhase.title}`;

      await fetch(`/api/projects/${editingProject.id}/todos`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          content,
          dueDate: dueDateStr,
        }),
      });

      showAlert("完了", "TODOに追加しました");
    } catch (error) {
      console.error("TODO追加に失敗しました:", error);
      showAlert("エラー", "TODO追加に失敗しました。もう一度お試しください。");
    } finally {
      setIsSaving(false);
    }
  }, [editingProject, editingPhase, plannedDate, phaseMemo, showAlert]);

  // 案件登録処理
  const handleProjectSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!projectForm.manager?.trim()) {
      showAlert("入力エラー", "担当を選択してください");
      return;
    }
    setIsProjectSubmitting(true);
    try {
      const res = await fetch("/api/projects", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(projectForm),
      });
      if (res.ok) {
        const newProject = await res.json();
        // 新しいプロジェクトをリストに追加
        setProjects((prev) => [...prev, { ...newProject, progressItems: [] }]);
        setProjectForm({ managementNumber: "", manager: "", client: "", projectNumber: "", completionMonth: "" });
        setProjectDialogOpen(false);
      }
    } catch (error) {
      console.error("案件登録に失敗しました:", error);
      showAlert("エラー", "案件登録に失敗しました。もう一度お試しください。");
    } finally {
      setIsProjectSubmitting(false);
    }
  };

  const formatCompletionMonth = (value: string | null | undefined) => {
    if (!value) return "";
    const [year, month] = value.split("-");
    return `${year}年${parseInt(month, 10)}月`;
  };

  const selectProjectMonth = (monthIndex: number) => {
    const monthStr = `${projectCalendarYear}-${String(monthIndex + 1).padStart(2, "0")}`;
    setProjectForm({ ...projectForm, completionMonth: monthStr });
    setProjectCalendarOpen(false);
  };

  return (
    <div className="min-h-screen bg-background">
      <div className="px-6 py-8">
        <div className="space-y-6">
          {/* Header */}
          <div className="flex flex-col gap-4">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <GitBranch className="h-5 w-5 text-muted-foreground" />
                <h1 className="text-xl font-semibold">タイムライン</h1>
              </div>
              <div className="flex items-center gap-3">
                {/* アラートサマリー */}
                {alertCount > 0 && (
                  <div className="flex items-center gap-2 px-4 py-2 rounded-lg bg-red-500/10 border border-red-500/30">
                    <Flame className="h-5 w-5 text-red-500" />
                    <span className="text-sm font-bold text-red-600 dark:text-red-400">
                      {alertCount}件のアラート
                    </span>
                  </div>
                )}
                {/* 新規登録ボタン */}
                <Button size="sm" onClick={() => setProjectDialogOpen(true)}>
                  <Plus className="h-4 w-4" />
                  新規登録
                </Button>
              </div>
            </div>

            {/* テーマメッセージ */}
            <div className={cn(
              "flex items-center gap-3 p-4 rounded-xl border",
              alertCount > 0
                ? "bg-red-500/5 border-red-500/30"
                : "bg-green-500/5 border-green-500/30"
            )}>
              {alertCount > 0 ? (
                <>
                  <AlertTriangle className="h-6 w-6 text-red-500 shrink-0" />
                  <div>
                    <p className="font-bold text-red-600 dark:text-red-400">
                      真っ赤をなくす作業
                    </p>
                    <p className="text-sm text-muted-foreground">
                      期日超過・期日未設定のフェーズを解消してください
                    </p>
                  </div>
                </>
              ) : (
                <>
                  <Check className="h-6 w-6 text-green-500 shrink-0" />
                  <div>
                    <p className="font-bold text-green-600 dark:text-green-400">
                      すべてのフェーズが正常です
                    </p>
                    <p className="text-sm text-muted-foreground">
                      期日超過・期日未設定のフェーズはありません
                    </p>
                  </div>
                </>
              )}
            </div>

            <div className="flex items-center gap-3">
              <div className="relative flex-1 max-w-sm">
                <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
                <Input
                  placeholder="管理番号・クライアントで検索"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="pl-9"
                />
              </div>
            </div>
          </div>

          {/* Legend */}
          <div className="flex items-center gap-4 text-xs text-muted-foreground">
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded-full bg-red-500"></div>
              <span className="font-medium text-red-600 dark:text-red-400">アラート</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded-full bg-green-500"></div>
              <span>完了</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded-full bg-blue-500"></div>
              <span>進行中</span>
            </div>
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded-full bg-zinc-300 dark:bg-zinc-700"></div>
              <span>予定</span>
            </div>
          </div>

          {/* Filter indicator */}
          {isFiltered && (
            <div className="flex items-center gap-2 text-sm">
              <Badge variant="secondary" className="gap-1">
                <Filter className="h-3 w-3" />
                {selectedProjectIds.size}件を表示中
              </Badge>
              <Button
                variant="ghost"
                size="sm"
                onClick={clearFilter}
                className="h-7 text-xs"
              >
                <X className="h-3 w-3 mr-1" />
                フィルターを解除
              </Button>
            </div>
          )}

          {/* Timeline Table */}
          <Card>
            <CardContent className="p-0">
              <div className="w-full overflow-hidden">
                <table className="w-full table-fixed">
                  <thead>
                    <tr className="border-b">
                      <th className="sticky left-0 bg-card z-10 px-2 py-3 text-left font-medium text-muted-foreground w-[140px]">
                        <Popover open={filterOpen} onOpenChange={setFilterOpen}>
                          <PopoverTrigger asChild>
                            <Button
                              variant="ghost"
                              className={cn(
                                "h-auto p-2 font-semibold text-muted-foreground hover:text-foreground justify-start gap-2 text-sm",
                                isFiltered && "text-primary"
                              )}
                            >
                              <Filter className={cn("h-4 w-4", isFiltered && "text-primary")} />
                              案件
                              <ChevronDown className="h-3 w-3" />
                              {isFiltered && (
                                <Badge variant="secondary" className="ml-1 h-5 px-1.5 text-xs">
                                  {selectedProjectIds.size}
                                </Badge>
                              )}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-80 p-0" align="start">
                            <div className="p-3 border-b">
                              <div className="flex items-center gap-2 mb-2">
                                <Search className="h-4 w-4 text-muted-foreground" />
                                <Input
                                  placeholder="案件を検索..."
                                  value={filterSearchQuery}
                                  onChange={(e) => setFilterSearchQuery(e.target.value)}
                                  className="h-8"
                                />
                              </div>
                              <div className="flex items-center gap-2">
                                <Button
                                  variant="outline"
                                  size="sm"
                                  onClick={selectAll}
                                  className="h-7 text-xs flex-1"
                                >
                                  全選択
                                </Button>
                                <Button
                                  variant="outline"
                                  size="sm"
                                  onClick={clearAll}
                                  className="h-7 text-xs flex-1"
                                >
                                  全解除
                                </Button>
                              </div>
                            </div>
                            <ScrollArea className="h-[300px]">
                              <div className="p-2">
                                {filterableProjects.length === 0 ? (
                                  <p className="text-sm text-muted-foreground text-center py-4">
                                    案件が見つかりません
                                  </p>
                                ) : (
                                  filterableProjects.map((project) => (
                                    <div
                                      key={project.id}
                                      className="flex items-center gap-3 px-2 py-2 rounded hover:bg-muted/50 cursor-pointer"
                                      onClick={() => toggleProjectSelection(project.id)}
                                    >
                                      <Checkbox
                                        checked={selectedProjectIds.has(project.id)}
                                        onCheckedChange={() => toggleProjectSelection(project.id)}
                                      />
                                      <div className="flex-1 min-w-0">
                                        <p className="text-sm font-medium truncate">
                                          {project.managementNumber}
                                        </p>
                                        <p className="text-xs text-muted-foreground truncate">
                                          {project.client}
                                        </p>
                                      </div>
                                    </div>
                                  ))
                                )}
                              </div>
                            </ScrollArea>
                            <div className="p-2 border-t">
                              <Button
                                variant="default"
                                size="sm"
                                onClick={() => setFilterOpen(false)}
                                className="w-full h-8"
                              >
                                適用 ({selectedProjectIds.size}件選択中)
                              </Button>
                            </div>
                          </PopoverContent>
                        </Popover>
                      </th>
                      {PHASES.map((phase) => (
                        <th
                          key={phase.key}
                          className="px-0 py-3 text-center font-semibold text-muted-foreground text-xs"
                          title={phase.title}
                        >
                          <span className="block truncate leading-tight">{phase.title}</span>
                        </th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {filteredProjects.length === 0 ? (
                      <tr>
                        <td
                          colSpan={PHASES.length + 1}
                          className="px-4 py-8 text-center text-muted-foreground text-base"
                        >
                          案件が見つかりません
                        </td>
                      </tr>
                    ) : (
                      filteredProjects.map((project) => {
                        const currentPhaseIndex = getCurrentPhaseIndex(project);
                        // 行にアラートがあるかどうか（全フェーズをチェック）
                        const hasAlert = PHASES.some((_, i) => isPhaseAlert(project, i));
                        return (
                          <tr
                            key={project.id}
                            className={cn(
                              "border-b hover:bg-muted/30 transition-colors",
                              hasAlert && "bg-red-500/5"
                            )}
                          >
                            <td className={cn(
                              "sticky left-0 z-10 px-2 py-3 w-[140px]",
                              hasAlert ? "bg-red-500/10" : "bg-card"
                            )}>
                              <Link
                                href={`/projects/${project.id}`}
                                className="group flex items-center gap-1"
                              >
                                {hasAlert && (
                                  <AlertTriangle className="h-4 w-4 text-red-500 shrink-0 mr-1" />
                                )}
                                <div className="min-w-0 flex-1">
                                  <p className={cn(
                                    "text-sm font-bold group-hover:underline truncate",
                                    hasAlert && "text-red-600 dark:text-red-400"
                                  )}>
                                    {project.managementNumber}
                                  </p>
                                  <p className="text-xs text-muted-foreground truncate">
                                    {project.client}
                                  </p>
                                </div>
                                <ChevronRight className="h-4 w-4 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity shrink-0" />
                              </Link>
                            </td>
                            {PHASES.map((phase, index) => {
                              const phaseStatus = getPhaseStatus(project, phase.title);
                              const isCompleted = phaseStatus.status === "completed";
                              const isCurrent = index === currentPhaseIndex;
                              const isAlert = isPhaseAlert(project, index);

                              return (
                                <td
                                  key={phase.key}
                                  className={cn(
                                    "px-0 py-2 text-center",
                                    isAlert && "bg-red-500/10"
                                  )}
                                >
                                  <button
                                    onClick={() => openEditDialog(project, phase)}
                                    className={cn(
                                      "group relative w-full flex flex-col items-center gap-1 p-1 rounded hover:bg-muted/50 transition-colors",
                                    )}
                                  >
                                    {/* Progress indicator */}
                                    <div
                                      className={cn(
                                        "w-7 h-7 rounded-full flex items-center justify-center transition-colors",
                                        isCompleted && "bg-green-500 text-white",
                                        isAlert && "bg-red-500 text-white",
                                        isCurrent && !isCompleted && !isAlert && "bg-blue-500 text-white",
                                        !isCompleted && !isCurrent && !isAlert && "bg-zinc-200 dark:bg-zinc-700"
                                      )}
                                    >
                                      {isCompleted ? (
                                        <Check className="h-4 w-4" />
                                      ) : isAlert ? (
                                        <AlertTriangle className="h-4 w-4" />
                                      ) : isCurrent ? (
                                        <Clock className="h-4 w-4" />
                                      ) : (
                                        <span className="text-xs text-muted-foreground font-bold">
                                          {index + 1}
                                        </span>
                                      )}
                                    </div>
                                    {/* Date */}
                                    <span
                                      className={cn(
                                        "text-xs font-semibold truncate w-full",
                                        isCompleted
                                          ? "text-green-600 dark:text-green-400"
                                          : isAlert
                                          ? "text-red-600 dark:text-red-400"
                                          : "text-muted-foreground"
                                      )}
                                    >
                                      {phaseStatus.date ? formatDateShort(phaseStatus.date) : "-"}
                                    </span>
                                    {/* Edit icon on hover */}
                                    <Pencil className="absolute top-0 right-0 h-3 w-3 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity" />
                                  </button>
                                </td>
                              );
                            })}
                          </tr>
                        );
                      })
                    )}
                  </tbody>
                </table>
              </div>
            </CardContent>
          </Card>

          {/* Progress Bar View (Alternative) */}
          <div className="space-y-4">
            <h2 className="text-sm font-medium text-muted-foreground">進捗バー表示</h2>
            {filteredProjects.slice(0, 5).map((project) => {
              const currentPhaseIndex = getCurrentPhaseIndex(project);
              const progressPercent = Math.round((currentPhaseIndex / PHASES.length) * 100);

              return (
                <Card key={project.id}>
                  <CardContent className="p-4">
                    <div className="flex items-center justify-between mb-2">
                      <Link
                        href={`/projects/${project.id}`}
                        className="font-medium hover:underline"
                      >
                        {project.managementNumber}
                      </Link>
                      <Badge variant="outline" className="text-xs">
                        {progressPercent}%
                      </Badge>
                    </div>
                    <div className="relative">
                      {/* Progress bar background */}
                      <div className="h-2 bg-zinc-200 dark:bg-zinc-700 rounded-full overflow-hidden">
                        <div
                          className="h-full bg-gradient-to-r from-blue-500 to-green-500 transition-all duration-500"
                          style={{ width: `${progressPercent}%` }}
                        />
                      </div>
                      {/* Phase markers */}
                      <div className="flex justify-between mt-1">
                        {PHASES.filter((_, i) => i % 4 === 0 || i === PHASES.length - 1).map(
                          (phase, i) => (
                            <span
                              key={phase.key}
                              className="text-[10px] text-muted-foreground"
                            >
                              {phase.title}
                            </span>
                          )
                        )}
                      </div>
                    </div>
                    <p className="text-xs text-muted-foreground mt-2">
                      現在のフェーズ:{" "}
                      <span className="font-medium text-foreground">
                        {currentPhaseIndex < PHASES.length
                          ? PHASES[currentPhaseIndex].title
                          : "完了"}
                      </span>
                    </p>
                  </CardContent>
                </Card>
              );
            })}
          </div>
        </div>
      </div>

      {/* Edit Dialog */}
      <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>フェーズを編集</DialogTitle>
          </DialogHeader>
          {editingProject && editingPhase && (
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-sm text-muted-foreground">案件</p>
                  <p className="font-medium">{editingProject.managementNumber}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">フェーズ</p>
                  <p className="font-medium">{editingPhase.title}</p>
                </div>
              </div>
              <div className="space-y-2">
                <Label>予定日</Label>
                <Popover open={plannedCalendarOpen} onOpenChange={setPlannedCalendarOpen}>
                  <PopoverTrigger asChild>
                    <Button
                      variant="outline"
                      className={cn(
                        "w-full justify-start text-left font-normal",
                        !plannedDate && "text-muted-foreground"
                      )}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {plannedDate ? formatDateFull(plannedDate) : "予定日を選択"}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={plannedDate}
                      onSelect={(date) => {
                        setPlannedDate(date);
                        setPlannedCalendarOpen(false);
                      }}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              </div>
              <div className="space-y-2">
                <Label>完了日</Label>
                <Popover open={completedCalendarOpen} onOpenChange={setCompletedCalendarOpen}>
                  <PopoverTrigger asChild>
                    <Button
                      variant="outline"
                      className={cn(
                        "w-full justify-start text-left font-normal",
                        !completedDate && "text-muted-foreground"
                      )}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {completedDate ? formatDateFull(completedDate) : "完了日を選択"}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={completedDate}
                      onSelect={(date) => {
                        setCompletedDate(date);
                        setCompletedCalendarOpen(false);
                      }}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              </div>
              <div className="space-y-2">
                <Label>メモ</Label>
                <Textarea
                  value={phaseMemo}
                  onChange={(e) => setPhaseMemo(e.target.value)}
                  placeholder="メモを入力..."
                  rows={3}
                />
              </div>
              <div className="flex justify-between pt-4">
                <div className="flex gap-2">
                  {completedDate ? (
                    <Button
                      variant="outline"
                      className="border-orange-500 text-orange-600 hover:bg-orange-50 dark:hover:bg-orange-950"
                      onClick={handleMarkIncomplete}
                      disabled={isSaving}
                    >
                      <X className="h-4 w-4 mr-2" />
                      未完了に戻す
                    </Button>
                  ) : (
                    <Button
                      variant="default"
                      className="bg-green-600 hover:bg-green-700"
                      onClick={handleMarkComplete}
                      disabled={isSaving}
                    >
                      <Check className="h-4 w-4 mr-2" />
                      完了にする
                    </Button>
                  )}
                  <Button
                    variant="outline"
                    className="border-blue-500 text-blue-600 hover:bg-blue-50 dark:hover:bg-blue-950"
                    onClick={handleAddTodo}
                    disabled={isSaving}
                  >
                    <ListTodo className="h-4 w-4 mr-2" />
                    TODOに追加
                  </Button>
                </div>
                <div className="flex gap-2">
                  <Button variant="outline" onClick={() => setEditDialogOpen(false)} disabled={isSaving}>
                    キャンセル
                  </Button>
                  <Button onClick={handleSave} disabled={isSaving || (!plannedDate && !completedDate)}>
                    {isSaving ? (
                      <>
                        <Loader2 className="h-4 w-4 animate-spin mr-2" />
                        保存中...
                      </>
                    ) : (
                      "保存"
                    )}
                  </Button>
                </div>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* 案件登録ダイアログ */}
      <Dialog open={projectDialogOpen} onOpenChange={setProjectDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>案件を新規登録</DialogTitle>
          </DialogHeader>
          <form onSubmit={handleProjectSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="managementNumber">管理番号</Label>
              <Input
                id="managementNumber"
                value={projectForm.managementNumber}
                onChange={(e) => setProjectForm({ ...projectForm, managementNumber: e.target.value })}
                placeholder="例: P-001"
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="manager">担当</Label>
              <Select
                value={projectForm.manager || undefined}
                onValueChange={(value) => setProjectForm({ ...projectForm, manager: value })}
              >
                <SelectTrigger id="manager" className="w-full">
                  <SelectValue placeholder="選択してください" />
                </SelectTrigger>
                <SelectContent>
                  {MANAGER_OPTIONS.map((name) => (
                    <SelectItem key={name} value={name}>
                      {name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="client">販売先</Label>
              <Input
                id="client"
                value={projectForm.client}
                onChange={(e) => setProjectForm({ ...projectForm, client: e.target.value })}
                placeholder="例: 〇〇不動産"
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="projectNumber">案件番号</Label>
              <Input
                id="projectNumber"
                value={projectForm.projectNumber}
                onChange={(e) => setProjectForm({ ...projectForm, projectNumber: e.target.value })}
                placeholder="例: 2026-0001"
                required
              />
            </div>
            <div className="space-y-2">
              <Label>完成月</Label>
              <Popover open={projectCalendarOpen} onOpenChange={setProjectCalendarOpen}>
                <PopoverTrigger asChild>
                  <Button
                    type="button"
                    variant="outline"
                    className="w-full justify-start text-left font-normal"
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {projectForm.completionMonth ? formatCompletionMonth(projectForm.completionMonth) : "選択してください"}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-64 p-3">
                  <div className="flex items-center justify-between mb-3">
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      onClick={() => setProjectCalendarYear(projectCalendarYear - 1)}
                    >
                      <ChevronLeft className="h-4 w-4" />
                    </Button>
                    <span className="font-medium">{projectCalendarYear}年</span>
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      onClick={() => setProjectCalendarYear(projectCalendarYear + 1)}
                    >
                      <ChevronRight className="h-4 w-4" />
                    </Button>
                  </div>
                  <div className="grid grid-cols-3 gap-2">
                    {MONTHS.map((month, index) => (
                      <Button
                        key={month}
                        type="button"
                        variant="ghost"
                        size="sm"
                        className="h-9"
                        onClick={() => selectProjectMonth(index)}
                      >
                        {month}
                      </Button>
                    ))}
                  </div>
                </PopoverContent>
              </Popover>
            </div>
            <div className="flex justify-end gap-2">
              <Button type="button" variant="outline" onClick={() => setProjectDialogOpen(false)} disabled={isProjectSubmitting}>
                キャンセル
              </Button>
              <Button type="submit" disabled={isProjectSubmitting}>
                {isProjectSubmitting ? (
                  <>
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    登録中...
                  </>
                ) : (
                  "登録"
                )}
              </Button>
            </div>
          </form>
        </DialogContent>
      </Dialog>

      {/* アラートダイアログ */}
      <AlertDialog open={alertDialogOpen} onOpenChange={setAlertDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{alertDialogTitle}</AlertDialogTitle>
            <AlertDialogDescription>{alertDialogMessage}</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogAction onClick={() => setAlertDialogOpen(false)}>
              OK
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="src/middleware.ts">
import NextAuth from "next-auth";
import { authConfig } from "./auth.config";
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

// 許可するIPアドレスのリスト（環境変数から読み込み + ローカル開発用 + 固定許可）
const ALLOWED_IPS = [
  ...(process.env.ALLOWED_IPS?.split(",").map((ip) => ip.trim()) || []),
  "127.0.0.1",
  "::1",
  "153.175.16.12",
  "1.73.154.231",
  "210.155.18.80",
];

function getClientIp(request: NextRequest): string | null {
  // Vercel/Cloudflareなどのプロキシ経由の場合
  const forwardedFor = request.headers.get("x-forwarded-for");
  if (forwardedFor) {
    return forwardedFor.split(",")[0].trim();
  }

  // 直接接続の場合
  const realIp = request.headers.get("x-real-ip");
  if (realIp) {
    return realIp;
  }

  return null;
}

const authMiddleware = NextAuth(authConfig).auth;

export default async function middleware(request: NextRequest) {
  const clientIp = getClientIp(request);

  // ローカル開発時はIP制限をスキップ
  const isLocalDev = process.env.NODE_ENV === "development";

  // IP制限チェック（一時的に無効化）
  // if (!isLocalDev && clientIp && !ALLOWED_IPS.includes(clientIp)) {
  //   console.log(`Access denied for IP: ${clientIp}`);
  //   return new NextResponse("Access Denied", { status: 403 });
  // }

  // 既存のNextAuth認証処理
  // @ts-expect-error NextAuth middleware type compatibility
  return authMiddleware(request);
}

export const config = {
  // https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher
  matcher: ["/((?!api|_next/static|_next/image|.*\\.png$).*)"],
};
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { SideNav } from "@/components/SideNav";
import { ThemeProvider } from "@/components/ThemeProvider";
import { SessionProvider } from "@/components/SessionProvider";
import { FeedbackInput } from "@/components/FeedbackInput";
import { Header } from "@/components/Header";
import { initDb } from "@/db";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "ALAN - 建設業界向けアプリ",
  description: "建設業界向けの案件管理・TODO管理・法令検索アプリケーション",
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  await initDb();
  return (
    <html lang="ja" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <SessionProvider>
          <ThemeProvider
            attribute="class"
            defaultTheme="light"
            enableSystem={false}
            disableTransitionOnChange
          >
            <div className="min-h-screen bg-background">
              <div className="flex">
                <SideNav />
                <div className="min-w-0 flex-1 flex flex-col">
                  <Header />
                  <main className="flex-1">
                    {children}
                    <FeedbackInput />
                  </main>
                </div>
              </div>
            </div>
          </ThemeProvider>
        </SessionProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/components/GeoSearchView.tsx">
"use client";

import { useState, useEffect, useRef } from "react";
import { useSearchParams } from "next/navigation";
import {
  parseCoordinateString,
  normalizeCoordinateString,
} from "@/lib/coordinates";
import { parsePrefectureAndCity } from "@/lib/address";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { ContactDeptAlertCard } from "@/components/ContactDeptAlertCard";
import { LawAlertCard } from "@/components/LawAlertCard";
import { CheckCircle2, XCircle, Copy, Check, Loader2, ExternalLink } from "lucide-react";

interface JudgmentResult {
  宅地造成等工事規制区域: boolean;
  特定盛土等規制区域: boolean;
}

const TEMPLATES = {
  宅地造成等工事規制区域: "宅地造成規制区域。造成の規模によっては許可申請が必要。現調結果次第で判断いたします。",
  特定盛土等規制区域: "特定盛土規制区域。造成の規模によっては届出 / 許可申請が必要。現調結果次第で判断いたします。",
};

// 追加ボタンの型定義
interface AdditionalButton {
  label: string;
  url: string;
}

// 法律検索カードコンポーネント
interface LawSearchCardProps {
  lawName: string;
  onSearch: (lawName: string, lawId?: number) => void;
  lawId?: number;
  fixedText?: string;
  copiedText: string | null;
  onCopy: (text: string) => void;
  prefecture?: string;
  additionalButtons?: AdditionalButton[];
  badges?: string[];
  caption?: string;
  /** 注意書き（コピーアイコンなしで表示） */
  note?: string;
  /** 地目に農地（田・畑）が含まれる場合の小さなアラート表示 */
  farmlandAlert?: boolean;
}

const LawSearchCard: React.FC<LawSearchCardProps> = ({
  lawName,
  onSearch,
  lawId,
  fixedText,
  copiedText,
  onCopy,
  prefecture,
  additionalButtons = [],
  badges = [],
  caption,
  note,
  farmlandAlert,
}) => {
  return (
    <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
      <div className="flex items-center justify-between">
        <div className="flex-1">
          <p className="font-medium text-foreground">{lawName}</p>
          {farmlandAlert && (
            <p className="text-xs text-amber-700 dark:text-amber-400 mt-2 px-2.5 py-1.5 rounded-lg bg-amber-50 dark:bg-amber-950/40 border border-amber-200 dark:border-amber-800">
              地目に農地が含まれています
            </p>
          )}
          {caption && (
            <p className="text-sm text-muted-foreground mt-2">{caption}</p>
          )}
          {fixedText && (
            <div className="flex items-start gap-2 mt-3 p-3 rounded-xl bg-muted/50 border border-border">
              <p className="flex-1 text-sm text-foreground leading-relaxed">{fixedText}</p>
              <button
                onClick={() => onCopy(fixedText)}
                className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                title="コピー"
              >
                {copiedText === fixedText ? (
                  <Check className="w-4 h-4 text-green-500" />
                ) : (
                  <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                )}
              </button>
            </div>
          )}
          {note && (
            <p className="text-xs text-muted-foreground mt-2">{note}</p>
          )}
          {badges.length > 0 && (
            <div className="flex flex-wrap gap-2 mt-3">
              {badges.map((badge, index) => (
                <span
                  key={index}
                  className="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-primary/10 text-primary border border-primary/20"
                >
                  {badge}
                </span>
              ))}
            </div>
          )}
        </div>
        <div className="flex flex-col gap-2 shrink-0 ml-4">
          <Button onClick={() => onSearch(lawName, lawId)} className="w-full">
            Googleで検索
          </Button>
          {additionalButtons.map((button, index) => (
            <Button
              key={index}
              variant="outline"
              size="sm"
              onClick={() => window.open(button.url, '_blank')}
              className="w-full"
            >
              <ExternalLink className="h-3 w-3 mr-2" />
              {button.label}
            </Button>
          ))}
        </div>
      </div>
    </div>
  );
};

// 法律リスト
interface Law {
  id: number;
  name: string;
  fixedText?: string;
}

const laws: Law[] = [
  { id: 1, name: "国土利用計画法" },
  { id: 2, name: "都市計画法" },
  { id: 3, name: "河川法" },
  { id: 4, name: "港湾法" },
  { id: 5, name: "海岸法" },
  { id: 6, name: "急傾斜地の崩壊による災害の防止に関する法律" },
  { id: 7, name: "砂防法" },
  { id: 8, name: "地すべり等防止法" },
  { id: 9, name: "景観法" },
  { id: 10, name: "農業振興地域の整備に関する法律" },
  { id: 11, name: "農地法" },
  { id: 12, name: "森林法" },
  { id: 13, name: "文化財保護法" },
  { id: 14, name: "土壌汚染対策法" },
  { id: 15, name: "自然公園法" },
  { id: 16, name: "自然環境保全法" },
  { id: 17, name: "絶滅の恐れがある野生動植物の種の保存に関する法律" },
  { id: 18, name: "鳥獣の保護及び管理並びに狩猟の適正化に関する法律" },
  { id: 19, name: "環境影響評価法・条例" },
  { id: 20, name: "消防法", fixedText: "低圧の為、消防署への届出が必要な機器設置なく、該当しません。" },
  { id: 21, name: "振動規制法", fixedText: "特定施設を設置しないため、該当しません。" },
  { id: 22, name: "道路法", fixedText: "工事区域に道路が無い為、道路使用許可が占用許可の必要な行為は予定されていません。" },
  { id: 23, name: "廃棄物の処理及び清掃に関する法律", fixedText: "敷地内の残置物及び工事で発生した産廃物については適正に処理します。" },
];

// 担当部署にお問い合わせのアラートを表示し、検索クエリに「担当部署」を追加する法律（河川法・急傾斜地・砂防・地すべり・森林法）
const CONTACT_DEPT_LAW_IDS = [3, 6, 7, 8, 12] as const;
const CONTACT_DEPT_MESSAGE = "担当部署にお問い合わせください";

// 鳥獣の保護及び管理並びに狩猟の適正化に関する法律：赤アラート表示対象（広島県内）
const HIROSHIMA_BIRD_PROTECTION_AREAS = [
  "庄原市口和町",
  "東広島市志和町",
  "福山市走島町",
  "福山市赤坂町",
  "福山市沼隈町",
  "福山市千田町",
  "三原市",
] as const;
const HIROSHIMA_BIRD_PROTECTION_URL =
  "https://www.pref.hiroshima.lg.jp/site/huntinglicense/hunter-map.html";

function isHiroshimaBirdProtectionArea(address: string | null): boolean {
  if (!address || !address.includes("広島県")) return false;
  return HIROSHIMA_BIRD_PROTECTION_AREAS.some((area) => address.includes(area));
}

export function GeoSearchView() {
  const [coordinateInput, setCoordinateInput] = useState("");
  const [latitude, setLatitude] = useState("");
  const [longitude, setLongitude] = useState("");
  const [prefecture, setPrefecture] = useState("");
  const [result, setResult] = useState<JudgmentResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);
  const [copiedText, setCopiedText] = useState<string | null>(null);
  const [locationInfo, setLocationInfo] = useState<{
    prefecture: string;
    city: string;
    fullAddress: string;
    shortAddress: string;
  } | null>(null);

  // 座標入力を解析（カンマ・スラッシュ・空白区切りに対応）し、有効なら正規化表示
  const handleCoordinateInput = (value: string) => {
    setCoordinateInput(value);
    const parsed = parseCoordinateString(value);
    if (parsed) {
      setLatitude(parsed.lat);
      setLongitude(parsed.lon);
      setCoordinateInput(normalizeCoordinateString(value));
    } else {
      setLatitude("");
      setLongitude("");
    }
  };

  const getLocationFromCoordinates = async (lat: number, lon: number) => {
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&accept-language=ja&addressdetails=1&zoom=18`
      );
      const data = await response.json();
      
      // デバッグ用（開発中のみ）
      console.log('Nominatim APIレスポンス:', data);
      
      const address = data.address || {};
      
      // 市名を取得（複数の階層から判定）
      const fullCityName =
        address.city ||
        address.town ||
        address.village ||
        address.municipality ||
        "";

      // 区名を取得（suburbやneighbourhoodから）
      const wardName =
        address.suburb ||
        address.neighbourhood ||
        "";

      // 市名の処理：区名が含まれている場合はそのまま、含まれていない場合は区名を追加
      let cityName = fullCityName;
      if (fullCityName.includes("市")) {
        // 既に区名が含まれている場合（例：「広島市安佐北区」）はそのまま使用
        if (fullCityName.includes("区")) {
          cityName = fullCityName;
        } else {
          // 「市」で終わっている場合（例：「広島市」）、区名があれば追加
          if (wardName && wardName.includes("区")) {
            cityName = fullCityName + wardName;
          } else {
            // 区名がない場合は、市名のみ（「市」で終わる部分まで）
            cityName = fullCityName.split("市")[0] + "市";
          }
        }
      }
      
      // 都道府県名を取得
      const prefectureName = address.state || address.prefecture || "";

      // 町名・エリア名（区名以外。neighbourhood/suburb に町名が入る場合がある）
      const area =
        (address.neighbourhood && !address.neighbourhood.includes("区")
          ? address.neighbourhood
          : "") ||
        (address.suburb && !address.suburb.includes("区") ? address.suburb : "") ||
        address.quarter ||
        address.hamlet ||
        address.village ||
        "";

      // 通り名・番地（Nominatimのaddressから取得）
      const road = address.road || "";
      const houseNumber = address.house_number || "";

      // 表示用の住所：address の全要素を順に結合（都道府県→市区町村→町名→通り→番地）
      const shortAddress = [prefectureName, cityName, area, road, houseNumber]
        .filter(Boolean)
        .join("");

      const fullAddress = (data.display_name || "").trim();
      
      return {
        prefecture: prefectureName,
        city: cityName,
        fullAddress,
        shortAddress,
      };
    } catch (error) {
      console.error('逆ジオコーディングエラー:', error);
      return null;
    }
  };

  // 検索実行（座標・都道府県を指定可能。未指定時は state を使用）
  const runSearch = async (override?: { lat: number; lon: number; prefecture: string }) => {
    const lat = override ? override.lat : parseFloat(latitude);
    const lon = override ? override.lon : parseFloat(longitude);
    const pref = override ? override.prefecture : prefecture;
    if (isNaN(lat) || isNaN(lon) || !pref) return;

    setHasSearched(true);
    setResult(null);
    setIsLoading(true);

    try {
      const location = await getLocationFromCoordinates(lat, lon);
      if (location) setLocationInfo(location);

      const response = await fetch("https://geo-checker-backend-aj4j.onrender.com/api/v1/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ latitude: lat, longitude: lon, prefecture: pref }),
      });
      const data: JudgmentResult = await response.json();
      setResult(data);
    } catch (error) {
      console.error("判定エラー:", error);
      alert("判定に失敗しました。もう一度お試しください。");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSearch = () => runSearch();

  // URL パラメータ（案件画面から遷移時）で座標・都道府県があれば自動検索
  const searchParams = useSearchParams();
  const initialSearchDone = useRef(false);
  useEffect(() => {
    const latParam = searchParams.get("lat");
    const lonParam = searchParams.get("lon");
    const prefectureParam = searchParams.get("prefecture");
    if (!latParam || !lonParam || !prefectureParam || initialSearchDone.current) return;
    const lat = parseFloat(latParam);
    const lon = parseFloat(lonParam);
    if (isNaN(lat) || isNaN(lon)) return;

    initialSearchDone.current = true;
    setCoordinateInput(`${latParam},${lonParam}`);
    setLatitude(latParam);
    setLongitude(lonParam);
    setPrefecture(prefectureParam);
    runSearch({ lat, lon, prefecture: prefectureParam });
  }, [searchParams]);

  const handleCopy = async (text: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedText(text);
      setTimeout(() => setCopiedText(null), 2000);
    } catch (error) {
      console.error("コピーに失敗しました:", error);
    }
  };

  // Mapple URL（座標をパラメータとして渡す・案件画面と同様）
  const getMappleUrl = () => {
    if (!latitude || !longitude) return null;
    const lat = latitude.trim();
    const lng = longitude.trim();
    if (!lat || !lng || isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) return null;
    return `https://labs.mapple.com/mapplexml.html#16/${lat}/${lng}`;
  };

  // Google検索関数（都道府県＋市区町村＋法律。担当部署系の法律には「担当部署」を追加）
  const handleGoogleSearch = (lawName: string, lawId?: number) => {
    const prefectureName =
      locationInfo?.prefecture ||
      (prefecture === "hiroshima" ? "広島県" : prefecture === "okayama" ? "岡山県" : "");
    const cityName = locationInfo?.city ?? "";
    const parts = [prefectureName, cityName, lawName];
    if (lawId != null && CONTACT_DEPT_LAW_IDS.includes(lawId as (typeof CONTACT_DEPT_LAW_IDS)[number])) {
      parts.push("担当部署");
    }
    const keyword = parts.filter(Boolean).join(" ");
    const encodedKeyword = encodeURIComponent(keyword);
    const searchUrl = `https://www.google.com/search?q=${encodedKeyword}`;
    window.open(searchUrl, "_blank");
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-background px-4 py-8">
      {/* 法令確認タイトル */}
      <div className="mb-8">
        <h1 className="text-4xl font-normal tracking-tight text-white">
          法令確認
        </h1>
      </div>

      {/* 検索フォーム */}
      <div className="w-full max-w-2xl space-y-4">
        {/* 入力フィールドコンテナ */}
        <div className="bg-card rounded-4xl border border-border shadow-lg p-8 space-y-6">
          {/* 座標入力（カンマ区切り） */}
          <div className="space-y-2">
            <label htmlFor="coordinate" className="text-sm font-medium text-foreground">
              座標（緯度,経度 または 緯度/経度）
            </label>
            <Input
              id="coordinate"
              type="text"
              placeholder="例: 34.580590,133.457655"
              value={coordinateInput}
              onChange={(e) => handleCoordinateInput(e.target.value)}
              className="w-full"
            />
            <p className="text-xs text-muted-foreground">
              緯度と経度をカンマまたはスラッシュ区切りで入力してください
            </p>
          </div>

          {/* 都道府県選択 */}
          <div className="space-y-2">
            <label htmlFor="prefecture" className="text-sm font-medium text-foreground">
              都道府県
            </label>
            <Select value={prefecture} onValueChange={setPrefecture}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="都道府県を選択してください" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="hiroshima">広島県</SelectItem>
                <SelectItem value="okayama">岡山県</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* 検索ボタン */}
          <div className="pt-2">
            <Button
              onClick={handleSearch}
              size="lg"
              className="w-full"
              disabled={!latitude || !longitude || !prefecture || isLoading}
            >
              {isLoading ? "検索中..." : "検索"}
            </Button>
          </div>
        </div>

        {/* 現地住所表示 */}
        {locationInfo?.shortAddress && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">現地住所</h2>
            <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
              <p className="flex-1 text-sm text-foreground leading-relaxed">
                {locationInfo.shortAddress}
              </p>
              <button
                onClick={() => handleCopy(locationInfo.shortAddress)}
                className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                title="コピー"
              >
                {copiedText === locationInfo.shortAddress ? (
                  <Check className="w-4 h-4 text-green-500" />
                ) : (
                  <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                )}
              </button>
            </div>
            {/* 地図確認ボタン */}
            <div className="flex flex-wrap gap-2">
              {getMappleUrl() && (
                <Button variant="outline" size="sm" asChild className="h-9">
                  <a
                    href={getMappleUrl() ?? ""}
                    target="_blank"
                    rel="noopener noreferrer"
                  >
                    <ExternalLink className="h-3 w-3 mr-2" />
                    MAPPLE
                  </a>
                </Button>
              )}
              <Button
                onClick={() => window.open(
                  `https://www.google.com/maps?q=${latitude},${longitude}`,
                  '_blank'
                )}
                className="flex-1"
              >
                Google Mapで確認
              </Button>
              {/* 岡山県の場合のみGISリンクを表示 */}
              {prefecture === "okayama" && (
                <Button
                  onClick={() => window.open('https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7', '_blank')}
                  className="flex-1"
                >
                  おかやま全県統合型GIS
                </Button>
              )}
            </div>
          </div>
        )}

        {/* 法律検索カード一覧 */}
        {hasSearched && laws.map((law) => {
          // 各法律ごとの条件分岐
          const isOkayama = prefecture === "okayama";
          const isHiroshima = prefecture === "hiroshima";
          let additionalButtons: AdditionalButton[] = [];
          let badges: string[] = [];
          let caption: string | undefined;
          let fixedTextWithCopy = law.fixedText;
          let noteForCard: string | undefined;

          // 1. 国土利用計画法
          if (law.id === 1 && isOkayama) {
            additionalButtons.push({
              label: "おかやま全県統合型GIS",
              url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
            });
          }
          const addressForHiroshimaCity = locationInfo?.fullAddress ?? locationInfo?.shortAddress ?? null;
          if (law.id === 1 && isHiroshima && addressForHiroshimaCity?.includes("広島市")) {
            additionalButtons.push({
              label: "ひろしま地図ナビ",
              url: "https://www2.wagmap.jp/hiroshimacity/Portal?mid=4"
            });
          }

          // 2. 港湾法
          if (law.id === 4) {
            fixedTextWithCopy = "対象地区ではありません。";
          }

          // 3. 海岸法
          if (law.id === 5) {
            fixedTextWithCopy = "対象地区ではありません。";
          }
          if (law.id === 4) {
            noteForCard = "港湾区域に関する法規制です。港湾区域の開発でない場合は該当しません。";
          }
          if (law.id === 5) {
            noteForCard = "海岸保全区域に関する法規制です。海岸保全区域の開発でない場合は該当しません。";
          }

          // 4. 景観法
          const addressForLandscape = locationInfo?.fullAddress ?? locationInfo?.shortAddress ?? null;
          if (law.id === 9 && isOkayama && !addressForLandscape?.includes("井原市")) {
            caption = "岡山県は全域が景観区域です。届出対象行為はこちらで確認してください。";
          }
          if (law.id === 9) {
            const { cityName: landscapeCityName } = parsePrefectureAndCity(addressForLandscape ?? null);
            if (landscapeCityName) {
              const landscapeButtonUrl = isOkayama
                ? "https://www.pref.okayama.jp/uploaded/attachment/325065.pdf"
                : "https://www.city.fukuyama.hiroshima.jp/uploaded/attachment/130060.pdf";
              additionalButtons.push({
                label: `${landscapeCityName}の届出対象行為`,
                url: landscapeButtonUrl
              });
            }
          }
          if (law.id === 9) {
            fixedTextWithCopy = "要件に該当しないため、届出不要です。";
            noteForCard = "開発面積や工作物の高さが一般的な要件です。各都道府県の法令を確認してください。";
          }

          // 5. 文化財保護法
          if (law.id === 13 && isOkayama) {
            additionalButtons.push({
              label: "おかやま全県統合型GIS",
              url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
            });
          }
          if (law.id === 13 && isHiroshima) {
            additionalButtons.push({
              label: "広島県埋蔵文化財地図",
              url: "https://www.pref.hiroshima.lg.jp/site/bunkazai/bunkazai-map-map.html"
            });
          }
          if (law.id === 13) {
            noteForCard = "地図で確認してください。";
          }

          // 6. 自然公園法
          if (law.id === 15 && isOkayama) {
            additionalButtons.push({
              label: "おかやま全県統合型GIS",
              url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
            });
          }
          if (law.id === 15 && isHiroshima) {
            additionalButtons.push({
              label: "広島県の自然公園",
              url: "https://www.pref.hiroshima.lg.jp/soshiki/47/kouikisei.html"
            });
          }
          if (law.id === 15) {
            fixedTextWithCopy = "対象地区ではありません。";
            noteForCard = "自然公園区域に関する法規制です。自然公園内の開発でない場合は該当しません。";
          }

          // 7. 自然環境保全法
          if (law.id === 16 && isOkayama) {
            additionalButtons.push({
              label: "自然環境保全地域",
              url: "https://www.pref.okayama.jp/page/573469.html"
            });
          }
          if (law.id === 16 && isHiroshima) {
            additionalButtons.push({
              label: "広島県の保全地域一覧",
              url: "https://www.pref.hiroshima.lg.jp/site/hiroshima-shizenkankyouhozen/"
            });
            fixedTextWithCopy = "対象地区ではありません。";
          }

          // 8. 絶滅の恐れがある野生動植物の種の保存に関する法律（常時表示）
          if (law.id === 17) {
            // 中国四国地方の県かどうか判定
            const chushikokuPrefectures = ["岡山県", "広島県", "山口県", "鳥取県", "島根県", "香川県", "愛媛県", "徳島県", "高知県"];
            const isChushikoku = locationInfo?.prefecture && chushikokuPrefectures.includes(locationInfo.prefecture);

            if (isChushikoku) {
              fixedTextWithCopy = "中国四国地方環境事務所管内には、種の保存法に基づき指定された生息地等保護区はありません。";
              additionalButtons.push({
                label: "参照リンク",
                url: "https://chushikoku.env.go.jp/procure/page_00068.html"
              });
            } else {
              fixedTextWithCopy = "対象地区ではありません。";
            }
            additionalButtons.push({
              label: "生息地等保護区",
              url: "https://www.env.go.jp/nature/kisho/hogoku/list.html"
            });
          }

          // 9. 鳥獣の保護及び管理並びに狩猟の適正化に関する法律
          const addressForBird = locationInfo?.fullAddress ?? locationInfo?.shortAddress ?? null;
          if (law.id === 18 && addressForBird && isHiroshimaBirdProtectionArea(addressForBird)) {
            return (
              <LawAlertCard
                key={law.id}
                title={law.name}
                message="鳥獣保護区に該当する可能性があります"
                detailUrl={HIROSHIMA_BIRD_PROTECTION_URL}
                variant="red"
              />
            );
          }
          if (law.id === 18 && isOkayama) {
            additionalButtons.push({
              label: "鳥獣保護区等位置図",
              url: "https://www.pref.okayama.jp/uploaded/life/1011233_9758897_misc.pdf"
            });
          }
          if (law.id === 18 && isHiroshima) {
            additionalButtons.push({
              label: "広島県の鳥獣保護区",
              url: HIROSHIMA_BIRD_PROTECTION_URL
            });
          }
          if (law.id === 18) {
            fixedTextWithCopy = "対象地区ではありません。";
            noteForCard = "鳥獣保護区に関する法規制です。";
          }

          // 10. 環境影響評価法・条例
          const addressForAssessment = locationInfo?.fullAddress ?? locationInfo?.shortAddress ?? null;
          if (law.id === 19 && isHiroshima) {
            fixedTextWithCopy = "対象の面積要件は○○ha以上のため、今回は該当しません。";
            noteForCard = "上記は例文です。各都道府県の条例に沿って記入してください。";
            const { prefectureName: assessmentPrefecture } = parsePrefectureAndCity(addressForAssessment ?? null);
            additionalButtons.push({
              label: `${assessmentPrefecture || "広島県"}の対象事業`,
              url: "https://www.pref.hiroshima.lg.jp/site/eco/h-h2-assessment-panhu-03.html"
            });
          }
          if (law.id === 19 && isOkayama) {
            fixedTextWithCopy = "対象の面積要件は20ha以上のため、今回は該当しません。";
            noteForCard = "上記は例文です。各都道府県の条例に沿って記入してください。";
            const { prefectureName: assessmentPrefecture } = parsePrefectureAndCity(addressForAssessment ?? null);
            additionalButtons.push({
              label: `${assessmentPrefecture || "岡山県"}の対象事業`,
              url: "https://www.pref.okayama.jp/uploaded/life/1005026_9692062_misc.pdf"
            });
          }

          // 農業振興地域法・農地法：井原・笠岡・矢掛の場合は非農地リストの案内
          const addressForFarmland = locationInfo?.fullAddress ?? locationInfo?.shortAddress ?? null;
          if (law.id === 10 || law.id === 11) {
            const isOkayamaNonFarmlandArea =
              addressForFarmland?.includes("井原市") ||
              addressForFarmland?.includes("笠岡市") ||
              addressForFarmland?.includes("矢掛");
            if (isOkayamaNonFarmlandArea) {
              fixedTextWithCopy = "非農地認定済みのため不要。地目変更登記を行います。";
              caption = "井原・笠岡・矢掛の場合は非農地リストがあるので、農地であっても手続きが地目変更のみになります。";
            }
          }

          // 河川法・急傾斜地・砂防・地すべり・森林法：担当部署アラートカード（黄色）
          if (CONTACT_DEPT_LAW_IDS.includes(law.id as (typeof CONTACT_DEPT_LAW_IDS)[number])) {
            return (
              <ContactDeptAlertCard
                key={law.id}
                title={law.name}
                message={CONTACT_DEPT_MESSAGE}
                onSearch={handleGoogleSearch}
                lawName={law.name}
                lawId={law.id}
              />
            );
          }

          return (
            <LawSearchCard
              key={law.id}
              lawName={law.name}
              lawId={law.id}
              onSearch={handleGoogleSearch}
              fixedText={fixedTextWithCopy}
              copiedText={copiedText}
              onCopy={handleCopy}
              prefecture={prefecture}
              additionalButtons={additionalButtons}
              badges={badges}
              caption={caption}
              note={noteForCard}
            />
          );
        })}

        {/* ○○県の太陽光に関する条例 */}
        {hasSearched && locationInfo?.prefecture && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">{locationInfo.prefecture}の太陽光に関する条例</h2>
            <div className="flex items-center justify-between">
              <div className="flex-1">
                <p className="font-medium text-foreground">{locationInfo.prefecture}の太陽光発電に関する条例を検索</p>
              </div>
              <Button
                onClick={() => {
                  const query = encodeURIComponent(`${locationInfo.prefecture}　太陽光　条例`);
                  window.open(`https://www.google.com/search?q=${query}`, "_blank");
                }}
                className="shrink-0 ml-4"
              >
                Googleで検索
              </Button>
            </div>
          </div>
        )}

        {/* 都道府県条例カード（岡山県） */}
        {hasSearched && prefecture === "okayama" && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">都道府県条例</h2>
            <div className="flex items-center justify-between">
              <div className="flex-1">
                <p className="font-medium text-foreground">岡山県太陽光発電施設の安全な導入を促進する条例</p>
              </div>
              <Button
                onClick={() => window.open("https://www.pref.okayama.jp/page/619095.html", "_blank")}
                className="shrink-0 ml-4"
              >
                Googleで検索
              </Button>
            </div>
          </div>
        )}

        {/* 市区町村条例カード（井原市） */}
        {hasSearched && locationInfo?.city?.includes("井原市") && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">市区町村条例</h2>
            <div className="flex items-center justify-between">
              <div className="flex-1">
                <p className="font-medium text-foreground">井原市開発事業の調整に関する条例</p>
              </div>
              <Button
                onClick={() => window.open("https://www.city.ibara.okayama.jp/soshiki/3/1214.html", "_blank")}
                className="shrink-0 ml-4"
              >
                Googleで検索
              </Button>
            </div>
          </div>
        )}

        {/* 判定結果表示 */}
        {hasSearched && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">判定結果</h2>
            
            {isLoading ? (
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Loader2 className="h-4 w-4 animate-spin" />
                判定中...
              </div>
            ) : result ? (
              <>
                {/* 宅地造成等工事規制区域 */}
                <div className="space-y-3">
                  <div className="flex items-center justify-between p-4 rounded-2xl bg-muted/50 border border-border">
                    <div className="flex-1">
                      <p className="font-medium text-foreground">宅地造成等工事規制区域</p>
                    </div>
                    <div className="flex items-center gap-2">
                      {result.宅地造成等工事規制区域 ? (
                        <>
                          <CheckCircle2 className="w-6 h-6 text-green-500" />
                          <span className="font-semibold text-green-500">該当します</span>
                        </>
                      ) : (
                        <>
                          <XCircle className="w-6 h-6 text-red-500" />
                          <span className="font-semibold text-muted-foreground">該当しません</span>
                        </>
                      )}
                    </div>
                  </div>
                  
                  {/* テンプレート文言（該当する場合のみ表示） */}
                  {result.宅地造成等工事規制区域 && (
                    <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                      <p className="flex-1 text-sm text-foreground leading-relaxed">
                        {TEMPLATES.宅地造成等工事規制区域}
                      </p>
                      <button
                        onClick={() => handleCopy(TEMPLATES.宅地造成等工事規制区域)}
                        className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                        title="コピー"
                      >
                        {copiedText === TEMPLATES.宅地造成等工事規制区域 ? (
                          <Check className="w-4 h-4 text-green-500" />
                        ) : (
                          <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                        )}
                      </button>
                    </div>
                  )}
                </div>

                {/* 特定盛土等規制区域 */}
                <div className="space-y-3">
                  {prefecture === "hiroshima" && (
                    <div className="rounded-2xl border-2 border-amber-400 bg-amber-50 dark:bg-amber-950/50 dark:border-amber-600 p-4">
                      <p className="text-sm font-semibold text-amber-800 dark:text-amber-200">
                        広島県は未対応です
                      </p>
                      <p className="text-xs text-amber-700 dark:text-amber-300 mt-1">
                        特定盛土等規制区域の判定は広島県では提供しておりません。
                      </p>
                    </div>
                  )}
                  <div className="flex items-center justify-between p-4 rounded-2xl bg-muted/50 border border-border">
                    <div className="flex-1">
                      <p className="font-medium text-foreground">特定盛土等規制区域</p>
                    </div>
                    <div className="flex items-center gap-2">
                      {result.特定盛土等規制区域 ? (
                        <>
                          <CheckCircle2 className="w-6 h-6 text-green-500" />
                          <span className="font-semibold text-green-500">該当します</span>
                        </>
                      ) : (
                        <>
                          <XCircle className="w-6 h-6 text-red-500" />
                          <span className="font-semibold text-muted-foreground">該当しません</span>
                        </>
                      )}
                    </div>
                  </div>
                  
                  {/* テンプレート文言（該当する場合のみ表示） */}
                  {result.特定盛土等規制区域 && (
                    <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                      <p className="flex-1 text-sm text-foreground leading-relaxed">
                        {TEMPLATES.特定盛土等規制区域}
                      </p>
                      <button
                        onClick={() => handleCopy(TEMPLATES.特定盛土等規制区域)}
                        className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                        title="コピー"
                      >
                        {copiedText === TEMPLATES.特定盛土等規制区域 ? (
                          <Check className="w-4 h-4 text-green-500" />
                        ) : (
                          <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                        )}
                      </button>
                    </div>
                  )}
                </div>

                {/* 入力情報表示 */}
                <div className="pt-2 border-t border-border mt-4">
                  <p className="text-sm text-muted-foreground">
                    判定座標: {locationInfo?.city && `${locationInfo.city}, `}緯度 {latitude}, 経度 {longitude}
                    {locationInfo?.prefecture && ` (${locationInfo.prefecture})`}
                  </p>
                </div>
              </>
            ) : (
              <div className="text-sm text-muted-foreground">
                判定結果がありません
              </div>
            )}
          </div>
        )}


        {/* 説明テキスト */}
        <p className="text-center text-sm text-muted-foreground">
          座標と都道府県を入力して、工事に関連する法令を検索します。
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/timeline.ts">
// フェーズ定義（完工からの相対月数）
// タイトルは PROGRESS_TITLES と統一（重複防止のため）
export const PHASE_OFFSETS = [
  { key: "noushin", title: "農振申請", monthsOffset: -10.1, optional: true },
  { key: "denryoku", title: "電力申請", monthsOffset: -5.8 },
  { key: "genchi", title: "現調", monthsOffset: -5.5 },
  { key: "teishutsu", title: "案件提出", monthsOffset: -5.0 },
  { key: "ss_irai", title: "SS依頼", monthsOffset: -2.7 },
  { key: "denryoku_kaito", title: "電力回答", monthsOffset: -2.5 },
  { key: "nouten", title: "法令申請", monthsOffset: -2.5 },
  { key: "tochi_keiyaku", title: "土地契約", monthsOffset: -2.4 },
  { key: "chakko", title: "着工", monthsOffset: -1.9 },
  { key: "ss_jisshi", title: "SS実施", monthsOffset: -1.8 },
  { key: "tochi_kessai", title: "土地決済", monthsOffset: -1.1 },
  { key: "kanko", title: "完工", monthsOffset: 0 },
  { key: "renkei", title: "連系", monthsOffset: 2.7 },
] as const;

// 新しいワークフロー工程定義（開始日からの順方向計算）
export const WORKFLOW_PHASES = [
  {
    key: "initial_acquisition",
    title: "案件スタート",
    duration: 0,
    unit: "business_days",
    phase: "01 開始",
    subPhases: [
      { key: "project_acquisition", title: "案件取得", date: new Date("2026-01-25"), responsibles: ['営業'] as const },
      { key: "initial_photography", title: "初期撮影", date: new Date("2026-01-25"), responsibles: ['工務'] as const }
    ]
  },
  {
    key: "initial_survey",
    title: "初期調査・設計（法令チェック等）",
    duration: 5,
    unit: "business_days",
    phase: "01 開始",
    subPhases: [
      { key: "site_guide_map", title: "現場案内図作成", date: new Date("2026-01-28"), responsibles: ['事務'] as const },
      { key: "legal_check", title: "法令チェック", date: new Date("2026-01-29"), responsibles: ['事務'] as const },
      { key: "hazard_map_check", title: "ハザードマップ確認", date: new Date("2026-01-30"), responsibles: ['事務'] as const },
      { key: "rough_drawing", title: "ラフ図面作成", date: new Date("2026-01-31"), responsibles: ['設計'] as const }
    ]
  },
  {
    key: "site_confirmation",
    title: "現地詳細確認（造成要否判断）",
    duration: 3,
    unit: "business_days",
    phase: "02 判断",
    subPhases: [
      { key: "site_survey_photos", title: "現調（不足分の写真撮影）", date: new Date("2026-02-05"), responsibles: ['工務', '設計'] as const }
    ]
  },
  {
    key: "submission_decision",
    title: "提出可否の判断",
    duration: 0,
    unit: "business_days",
    phase: "02 判断",
    subPhases: [
      {
        key: "decision_check",
        title: "提出可否チェック",
        note: "大規模造成が必要な場合はこの時点でNG",
        responsibles: ['事務', '設計'] as const
      }
    ]
  },
  {
    key: "application_contract",
    title: "契約・詳細設計",
    duration: 5,
    unit: "business_days",
    phase: "03 申請",
    subPhases: [
      { key: "drawing_revision", title: "図面修正", date: new Date("2026-02-10"), responsibles: ['設計'] as const },
      { key: "power_simulation", title: "電力シミュレーション", date: new Date("2026-02-12"), responsibles: ['設計'] as const },
      { key: "neighbor_greeting", title: "近隣挨拶・伐採範囲の許可取得", date: new Date("2026-02-14"), responsibles: ['営業', '工務'] as const },
      { key: "land_contract", title: "土地契約", date: new Date("2026-02-17"), responsibles: ['事務', '営業'] as const },
      { key: "land_category_change", title: "地目変更", date: new Date("2026-02-19"), responsibles: ['事務'] as const }
    ]
  },
  {
    key: "application",
    title: "申請",
    duration: 0,
    unit: "business_days",
    phase: "03 申請",
    subPhases: [
      { key: "dd", title: "DD", date: new Date("2026-02-10"), responsibles: ['事務', '設計'] as const },
      { key: "power_application", title: "電力申請", date: new Date("2026-02-10"), responsibles: ['事務'] as const },
      { key: "legal_application", title: "法令申請", date: new Date("2026-02-10"), responsibles: ['事務'] as const }
    ]
  },
  {
    key: "waiting_period",
    title: "法令・電力回答待ち（待機期間）",
    duration: 45,
    unit: "calendar_days",
    phase: "03 申請",
    subPhases: [
      { key: "legal_response", title: "法令回答", date: new Date("2026-02-20"), responsibles: ['事務'] as const },
      { key: "power_response", title: "電力回答", date: new Date("2026-02-22"), responsibles: ['事務'] as const }
    ]
  },
  {
    key: "final_design",
    title: "最終調整",
    duration: 3,
    unit: "business_days",
    phase: "03 申請",
    subPhases: [
      { key: "final_design_simulation", title: "本設計（再シミュレーション実施）", date: new Date("2026-03-10"), responsibles: ['設計'] as const }
    ]
  },
  {
    key: "final_decision",
    title: "最終判断と決済",
    duration: 5,
    unit: "business_days",
    phase: "04 決済",
    subPhases: [
      { key: "ground_survey_request", title: "地盤調査依頼", date: new Date("2026-03-15"), responsibles: ['事務', '工務'] as const },
      { key: "settlement_name_change", title: "決済（名義変更）", date: new Date("2026-03-20"), responsibles: ['事務'] as const }
    ]
  },
  {
    key: "construction",
    title: "工事着工～完了",
    duration: 90,
    unit: "calendar_days",
    phase: "05 完了"
  },
] as const;

export type PhaseKey = (typeof PHASE_OFFSETS)[number]["key"];

export interface TimelinePhase {
  key: PhaseKey;
  title: string;
  date: Date;
  optional?: boolean;
}

// 担当者タイプ
export type ResponsibleType = '事務' | '工務' | '設計' | '営業';

// サブフェーズ定義
export interface WorkflowSubPhase {
  key: string;
  title: string;
  date?: Date;
  type?: 'normal' | 'branch'; // 通常項目か分岐ノードか
  branchCriteria?: string; // 分岐基準
  branches?: ReadonlyArray<{
    name: string;
    condition: string;
  }>; // 分岐先
  duration?: number; // 工数
  unit?: 'business_days' | 'calendar_days'; // 工数の単位
  responsibles?: ReadonlyArray<ResponsibleType>; // 担当者
  note?: string; // 注記（警告テキストなど）
}

// ワークフロー用TimelinePhase（フェーズ情報付き）
export interface WorkflowTimelinePhase {
  key: string;
  title: string;
  date?: Date; // 日付がない工程も許容
  startDate?: Date; // 期間開始日（待機期間などの場合）
  endDate?: Date; // 期間終了日（待機期間などの場合）
  phase: string; // "01 開始" などのフェーズ情報
  subPhases?: WorkflowSubPhase[]; // サブ項目
}

/**
 * 月を加算（小数対応）
 * 例: -5.8ヶ月 → 5ヶ月と約24日前
 */
function addMonths(date: Date, months: number): Date {
  const result = new Date(date);
  const wholeMonths = Math.floor(months);
  const fractionalDays = (months - wholeMonths) * 30;

  result.setMonth(result.getMonth() + wholeMonths);
  result.setDate(result.getDate() + Math.round(fractionalDays));

  return result;
}

/**
 * 営業日を加算（土日を除く）
 */
function addBusinessDays(date: Date, businessDays: number): Date {
  const result = new Date(date);
  let added = 0;

  while (added < businessDays) {
    result.setDate(result.getDate() + 1);
    const dayOfWeek = result.getDay();
    // 0 = 日曜日, 6 = 土曜日
    if (dayOfWeek !== 0 && dayOfWeek !== 6) {
      added++;
    }
  }

  return result;
}

/**
 * 暦日を加算
 */
function addCalendarDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

/**
 * 完成月から各フェーズの予定日を計算
 *
 * @param completionMonth 完成月（例: "2026-03"）
 * @param includeNoushin 農振申請を含めるか（農振除外が必要な案件のみtrue）
 */
export function calculateTimeline(
  completionMonth: string,
  includeNoushin: boolean = false
): TimelinePhase[] {
  const [year, month] = completionMonth.split("-").map(Number);
  const baseDate = new Date(year, month - 1, 15); // 完成月の15日を基準とする

  return PHASE_OFFSETS.filter((phase) => !("optional" in phase) || includeNoushin).map(
    (phase) => ({
      key: phase.key,
      title: phase.title,
      date: addMonths(baseDate, phase.monthsOffset),
      optional: "optional" in phase ? phase.optional : undefined,
    })
  );
}

/**
 * サブ項目の日付を計算
 */
function calculateSubPhaseDates(
  phaseKey: string,
  phaseStart: Date,
  subPhases?: readonly WorkflowSubPhase[]
): WorkflowSubPhase[] | undefined {
  if (!subPhases) return undefined;

  return subPhases.map((subPhase) => {
    // 分岐ノードの場合は日付を設定しない
    if (subPhase.type === 'branch') {
      return subPhase;
    }

    let calculatedDate: Date | undefined;

    let duration: number | undefined;
    let unit: 'business_days' | 'calendar_days' | undefined;

    switch (phaseKey) {
      case "initial_acquisition":
        // 案件スタート内の項目は案件スタートの日付と同じ
        calculatedDate = new Date(phaseStart);
        duration = 1; // 各サブ項目は1営業日と仮定
        unit = "business_days";
        break;

      case "initial_survey":
        // 現場案内図、法令チェック、ハザードマップ確認：+2営業日、ラフ図面：+3営業日
        if (subPhase.key === "rough_drawing") {
          calculatedDate = addBusinessDays(phaseStart, 3);
          duration = 3;
        } else {
          calculatedDate = addBusinessDays(phaseStart, 2);
          duration = 2;
        }
        unit = "business_days";
        break;

      case "site_confirmation":
        // 現調：+3営業日
        calculatedDate = addBusinessDays(phaseStart, 3);
        duration = 3;
        unit = "business_days";
        break;

      case "submission_decision":
        // 提出先の判断：期間スタートの日付
        calculatedDate = new Date(phaseStart);
        duration = 1; // 各サブ項目は1営業日と仮定
        unit = "business_days";
        break;

      case "application_contract":
        // すべての項目：+5営業日
        calculatedDate = addBusinessDays(phaseStart, 5);
        duration = 1; // 各サブ項目は1営業日と仮定
        unit = "business_days";
        break;

      case "application":
        // 申請フェーズの項目はすべて契約・詳細設計の開始日から5営業日後
        calculatedDate = addBusinessDays(phaseStart, 5);
        duration = 1; // 各サブ項目は1営業日と仮定
        unit = "business_days";
        break;

      case "waiting_period":
        // 法令回答：+1か月、電力回答：+1.5ヶ月
        if (subPhase.key === "legal_response") {
          calculatedDate = addMonths(phaseStart, 1);
          duration = 30; // 約1ヶ月
          unit = "calendar_days";
        } else if (subPhase.key === "power_response") {
          calculatedDate = addMonths(phaseStart, 1.5);
          duration = 45; // 約1.5ヶ月
          unit = "calendar_days";
        } else {
          // その他のサブ項目
          duration = 1;
          unit = "calendar_days";
        }
        break;

      case "final_design":
        // 本設計：+3日（暦日）
        calculatedDate = addCalendarDays(phaseStart, 3);
        duration = 3;
        unit = "calendar_days";
        break;

      case "final_decision":
        // 地盤調査依頼と決済：+5日（暦日）
        calculatedDate = addCalendarDays(phaseStart, 5);
        duration = 1; // 各サブ項目は1暦日と仮定
        unit = "calendar_days";
        break;

      default:
        calculatedDate = undefined;
        // デフォルトでは工数を設定しない（元のsubPhaseの工数を使用）
        if (duration === undefined) {
          duration = subPhase.duration;
        }
        if (!unit) {
          unit = subPhase.unit || "business_days";
        }
    }

    // durationがundefinedの場合は1営業日をデフォルトとする
    const finalDuration = duration !== undefined ? duration : (subPhase.duration !== undefined ? subPhase.duration : 1);
    const finalUnit = unit || subPhase.unit || "business_days";

    return {
      ...subPhase,
      date: calculatedDate,
      duration: finalDuration,
      unit: finalUnit,
    };
  });
}

/**
 * 開始日を起点としたワークフロー式スケジュール計算
 *
 * @param startDate 開始日
 * @returns 各工程の予定日リスト
 */
export function calculateWorkflowTimeline(startDate: Date): WorkflowTimelinePhase[] {
  const phases: WorkflowTimelinePhase[] = [];
  let currentDate = new Date(startDate);
  let applicationContractStartDate: Date | undefined = undefined;

  for (const workflowPhase of WORKFLOW_PHASES) {
    // 工事着工～完了の場合は日付計算をスキップ
    if (workflowPhase.key === "construction") {
      phases.push({
        key: workflowPhase.key,
        title: workflowPhase.title,
        phase: workflowPhase.phase,
        // construction には subPhases なし / dateは設定しない
      });
      continue;
    }

    // 各フェーズの開始日と終了日を計算
    const phaseStart = new Date(currentDate);
    let phaseEnd: Date;

    // application_contractの開始日を保持（申請フェーズの日付計算に使用）
    if (workflowPhase.key === "application_contract") {
      applicationContractStartDate = new Date(phaseStart);
    }

    // 開始日の場合はそのまま使用（案件スタートなど）
    if (workflowPhase.duration === 0) {
      phaseEnd = new Date(currentDate);
      
      // 申請フェーズの場合は、契約・詳細設計の開始日から5営業日後を日付として使用
      let calculatedSubPhases;
      if (workflowPhase.key === "application" && applicationContractStartDate) {
        calculatedSubPhases = calculateSubPhaseDates(workflowPhase.key, applicationContractStartDate, workflowPhase.subPhases);
      } else {
        calculatedSubPhases = calculateSubPhaseDates(workflowPhase.key, phaseStart, workflowPhase.subPhases);
      }
      
      phases.push({
        key: workflowPhase.key,
        title: workflowPhase.title,
        date: new Date(currentDate), // 案件スタート用にdateも保持
        startDate: phaseStart,
        endDate: phaseEnd,
        phase: workflowPhase.phase,
        subPhases: calculatedSubPhases,
      });
      continue;
    }

    // 営業日または暦日で終了日を計算
    if (workflowPhase.unit === "business_days") {
      phaseEnd = addBusinessDays(currentDate, workflowPhase.duration);
    } else {
      phaseEnd = addCalendarDays(currentDate, workflowPhase.duration);
    }

    // 次のフェーズのためにcurrentDateを更新
    currentDate = new Date(phaseEnd);

    // サブ項目の日付を計算
    const calculatedSubPhases = calculateSubPhaseDates(workflowPhase.key, phaseStart, workflowPhase.subPhases);

    phases.push({
      key: workflowPhase.key,
      title: workflowPhase.title,
      startDate: phaseStart,
      endDate: phaseEnd,
      phase: workflowPhase.phase,
      subPhases: calculatedSubPhases,
    });
  }

  return phases;
}

/**
 * 日付を YYYY.M.D 形式でフォーマット
 */
export function formatDateJp(date: Date): string {
  const y = date.getFullYear();
  const m = date.getMonth() + 1;
  const d = date.getDate();
  return `${y}.${m}.${d}`;
}
</file>

<file path="src/app/page.tsx">
import { HomeSearchView } from "@/components/HomeSearchView";

export default function HomePage() {
  return <HomeSearchView />;
}
</file>

<file path="package.json">
{
  "name": "geo_checker_nextjs",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@fullcalendar/core": "^6.1.20",
    "@fullcalendar/daygrid": "^6.1.20",
    "@fullcalendar/interaction": "^6.1.20",
    "@fullcalendar/list": "^6.1.20",
    "@fullcalendar/react": "^6.1.20",
    "@fullcalendar/timegrid": "^6.1.20",
    "@libsql/client": "^0.17.0",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.13",
    "@supabase/supabase-js": "^2.93.3",
    "@tailwindcss/typography": "^0.5.19",
    "@types/bcryptjs": "^2.4.6",
    "@vercel/blob": "^0.27.1",
    "bcryptjs": "^3.0.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "drizzle-orm": "^0.45.1",
    "lucide-react": "^0.562.0",
    "next": "16.1.2",
    "next-auth": "^5.0.0-beta.30",
    "next-themes": "^0.4.6",
    "pdfjs-dist": "^5.4.624",
    "radix-ui": "^1.4.3",
    "react": "19.2.3",
    "react-day-picker": "^9.13.0",
    "react-dom": "19.2.3",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "drizzle-kit": "^0.31.8",
    "eslint": "^9",
    "eslint-config-next": "16.1.2",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}
</file>

<file path="src/app/projects/ProjectsView.tsx">
"use client";

import { useEffect, useState, useMemo, useRef, useCallback } from "react";
import { useRouter } from "next/navigation";
import { Plus, Pencil, Trash2, Calendar as CalendarIcon, ChevronLeft, ChevronRight, AlertCircle, Search, Loader2, Filter, X, ChevronDown, Check } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";
import type { Project, NewProject } from "@/db/schema";

const MONTHS = ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"];

const MANAGER_OPTIONS = ["吉國", "刎本", "松下", "佐東", "川田", "近永", "その他"];

const PROJECT_SEARCH_RECENT_KEY = "geo_checker_recent_project_searches";
const MAX_RECENT_SEARCHES = 3;

// テーブルカラム定義
const TABLE_COLUMNS: { key: keyof Project | string; label: string; width?: string }[] = [
  { key: "managementNumber", label: "管理番号", width: "120px" },
  { key: "manager", label: "担当", width: "80px" },
  { key: "client", label: "販売先", width: "120px" },
  { key: "projectNumber", label: "販売店 案件番号", width: "140px" },
  { key: "availability", label: "可否", width: "60px" },
  { key: "businessType", label: "業務", width: "80px" },
  { key: "designPower", label: "設計/電力", width: "100px" },
  { key: "sales", label: "営業", width: "80px" },
  { key: "parcelCount", label: "筆数", width: "60px" },
  { key: "prefecture", label: "都道府県", width: "100px" },
  { key: "blank1", label: "(空白)", width: "60px" },
  { key: "link", label: "リンク", width: "80px" },
  { key: "agreementMonth", label: "合意書 計上月", width: "120px" },
  { key: "projectSubmissionScheduled", label: "案件提出 予定日", width: "130px" },
  { key: "projectSubmissionDate", label: "案件提出日", width: "110px" },
  { key: "fellingConsentRequest", label: "伐採/工事 承諾書依頼", width: "160px" },
  { key: "fellingConsentComplete", label: "伐採/工事 承諾書揃う", width: "160px" },
  { key: "siteInvestigation", label: "現調", width: "80px" },
  { key: "level", label: "レベル", width: "80px" },
  { key: "landContractRequestScheduled", label: "土地売契 依頼予定日", width: "150px" },
  { key: "landContractRequest", label: "土地売契 依頼", width: "120px" },
  { key: "landContractScheduled", label: "土地契約 締結予定日", width: "150px" },
  { key: "landContractDate", label: "土地契約 締結日", width: "130px" },
  { key: "landPrice", label: "土地代", width: "100px" },
  { key: "landowner", label: "地権者", width: "120px" },
  { key: "landownerAddress", label: "地権者住所", width: "200px" },
  { key: "landAreaTotal", label: "土地 ㎡数", width: "100px" },
  { key: "correctionStatus", label: "更正 有無", width: "90px" },
  { key: "inheritanceStatus", label: "相続 有無", width: "90px" },
  { key: "mortgageStatus", label: "抵当権 有無", width: "100px" },
  { key: "hazardAtHome", label: "ハザード（アットホーム）", width: "170px" },
  { key: "photo", label: "写真", width: "60px" },
  { key: "snowfall", label: "積雪", width: "60px" },
  { key: "windSpeedValue", label: "風速", width: "60px" },
  { key: "neighborhoodFelling", label: "近隣伐採", width: "90px" },
  { key: "landRemarks", label: "土地備考", width: "150px" },
  { key: "landCategory", label: "地目", width: "80px" },
  { key: "nourinStatus", label: "農振 有無", width: "90px" },
  { key: "nourinScrivenerRequest", label: "農振 行政書士依頼", width: "150px" },
  { key: "nourinApplicationScheduled", label: "農振 申請予定日", width: "130px" },
  { key: "nourinApplicationDate", label: "農振 申請日", width: "110px" },
  { key: "nourinCompletionScheduled", label: "農振 完了予定日", width: "130px" },
  { key: "nourinCompletionDate", label: "農振 完了日", width: "110px" },
  { key: "noutenStatus", label: "農転 有無", width: "90px" },
  { key: "landCategoryChangeRequest", label: "地目変更 営業への依頼", width: "170px" },
  { key: "noutenScrivenerRequest", label: "農転 行政書士依頼", width: "150px" },
  { key: "noutenApplicationScheduled", label: "農転/地目 申請予定日", width: "160px" },
  { key: "noutenApplicationDate", label: "農転/地目 申請日", width: "130px" },
  { key: "noutenCompletionScheduled", label: "農転/地目 完了予定日", width: "160px" },
  { key: "noutenCompletionDate", label: "農転/地目 完了日", width: "130px" },
  { key: "regulationCategory", label: "規制 区分", width: "100px" },
  { key: "developmentStatus", label: "造成 有無", width: "90px" },
  { key: "residentialDevApplicationScheduled", label: "宅造法 申請予定日", width: "140px" },
  { key: "residentialDevApplicationDate", label: "宅造法 申請日", width: "120px" },
  { key: "residentialDevCompletionScheduled", label: "宅造法 完了予定日", width: "140px" },
  { key: "residentialDevCompletionDate", label: "宅造法 完了日", width: "120px" },
  { key: "otherRegulations", label: "その他 法令", width: "120px" },
  { key: "regulationApplicationScheduled", label: "法令申請予定日", width: "130px" },
  { key: "regulationApplicationPaymentDate", label: "法令申請日 支払日", width: "150px" },
  { key: "regulationPermitScheduled", label: "法令許可予定日", width: "130px" },
  { key: "regulationPermitDate", label: "法令許可日", width: "110px" },
  { key: "completionNotification", label: "完了届", width: "80px" },
  { key: "regulationRemarks", label: "法令備考", width: "150px" },
  { key: "moduleType", label: "ﾓｼﾞｭｰﾙ", width: "100px" },
  { key: "moduleCount", label: "ﾓｼﾞｭｰﾙ 枚数", width: "110px" },
  { key: "moduleCapacity", label: "ﾓｼﾞｭｰﾙ 容量", width: "110px" },
  { key: "systemCapacity", label: "ｼｽﾃﾑ 容量", width: "100px" },
  { key: "powerSimulation", label: "発電シミュレーション", width: "160px" },
  { key: "powerCompany", label: "電力 会社", width: "100px" },
  { key: "powerApplicationDestination", label: "電力申請 申請先", width: "130px" },
  { key: "powerApplicationScheduled", label: "電力 申請予定日", width: "130px" },
  { key: "powerApplicationDate", label: "電力 申請日", width: "110px" },
  { key: "powerResponseScheduled", label: "電力 回答予定日", width: "130px" },
  { key: "powerResponseDate", label: "電力 回答日", width: "110px" },
  { key: "estimatedBurden", label: "概算 負担金額", width: "120px" },
  { key: "additionalBurden", label: "追加 負担金額", width: "120px" },
  { key: "burdenPaymentDate", label: "負担金 支払日", width: "120px" },
  { key: "interconnectionStatus", label: "連系可否", width: "90px" },
  { key: "interconnectionDetails", label: "連系詳細", width: "150px" },
  { key: "powerRemarks", label: "電力備考", width: "150px" },
  { key: "landSettlementDocScheduled", label: "土地決済書類回収予定", width: "170px" },
  { key: "landSettlementDocCollection", label: "土地決済書類回収", width: "150px" },
  { key: "landSettlementScheduled", label: "土地決済予定日", width: "130px" },
  { key: "landSettlementDate", label: "土地 決済日", width: "110px" },
  { key: "ownershipTransferAppScheduled", label: "所有権移転登記申請予定", width: "180px" },
  { key: "ownershipTransferApplication", label: "所有権移転登記申請", width: "160px" },
  { key: "ownershipTransferCompScheduled", label: "所有権移転登記完了予定", width: "180px" },
  { key: "ownershipTransferCompletion", label: "所有権移転登記完了", width: "160px" },
  { key: "developmentCost", label: "造成費用", width: "100px" },
  { key: "surveyingCost", label: "測量費用", width: "100px" },
  { key: "administrativeCost", label: "行政費用", width: "100px" },
  { key: "otherCostTotal", label: "その他 費用合計", width: "140px" },
  { key: "neighborGreetingRequestScheduled", label: "近隣挨拶 依頼予定日", width: "160px" },
  { key: "neighborGreetingRequestDate", label: "近隣挨拶 依頼日", width: "130px" },
  { key: "neighborGreetingScheduled", label: "近隣挨拶 予定日", width: "130px" },
  { key: "neighborGreetingDate", label: "近隣挨拶 実施日", width: "130px" },
  { key: "ssRequestScheduled", label: "SS 依頼予定日", width: "120px" },
  { key: "ssRequestDate", label: "SS 依頼日", width: "100px" },
  { key: "ssScheduled", label: "SS 予定日", width: "100px" },
  { key: "ssDate", label: "SS 実施日", width: "100px" },
  { key: "orderCreationRequestScheduled", label: "注文書作成依頼予定", width: "160px" },
  { key: "orderCreationRequest", label: "注文書作成依頼", width: "130px" },
  { key: "orderScheduled", label: "発注予定日", width: "110px" },
  { key: "orderDate", label: "発注日", width: "90px" },
  { key: "deliveryDate", label: "納品日", width: "90px" },
  { key: "constructionStartScheduled", label: "着工 予定日", width: "110px" },
  { key: "constructionStartDate", label: "着工日", width: "90px" },
  { key: "constructionEndScheduled", label: "完工 予定日", width: "110px" },
  { key: "constructionEndDate", label: "完工日", width: "90px" },
  { key: "externalLineWorkDate", label: "外線 工事日", width: "110px" },
  { key: "leadInWorkDate", label: "引込 工事日", width: "110px" },
  { key: "interconnectionScheduled", label: "連系 予定日", width: "110px" },
  { key: "interconnectionDate", label: "連系日", width: "90px" },
  { key: "burdenLandOther", label: "負担金土地 その他", width: "150px" },
  { key: "confirmationItems", label: "確認事項", width: "150px" },
  { key: "completionMonth", label: "完成月", width: "100px" },
  { key: "constructionComplete", label: "完工", width: "60px" },
];

function getRecentSearches(): string[] {
  if (typeof window === "undefined") return [];
  try {
    const raw = localStorage.getItem(PROJECT_SEARCH_RECENT_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw) as unknown;
    return Array.isArray(arr)
      ? arr.filter((x): x is string => typeof x === "string").slice(0, MAX_RECENT_SEARCHES)
      : [];
  } catch {
    return [];
  }
}

function addRecentSearch(query: string): string[] {
  const q = query.trim();
  if (!q) return getRecentSearches();
  const prev = getRecentSearches();
  const next = [q, ...prev.filter((x) => x !== q)].slice(0, MAX_RECENT_SEARCHES);
  try {
    localStorage.setItem(PROJECT_SEARCH_RECENT_KEY, JSON.stringify(next));
  } catch {
    // ignore
  }
  return next;
}

// 超過情報・コメント・TODO検索用テキストを含む案件型
type ProjectWithOverdue = Project & { hasOverdue: boolean; commentSearchText?: string; todoSearchText?: string };

interface ProjectsViewProps {
  initialProjects: ProjectWithOverdue[];
}

// フィルター用のヘルパー関数
function formatCompletionMonthForFilter(value: string | null | undefined): string {
  if (!value) return "未設定";
  const [year, month] = value.split("-");
  return `${year}年${parseInt(month, 10)}月`;
}

// 固定カラム数（管理番号、担当、販売先、販売店案件番号）
const FIXED_COLUMNS_COUNT = 4;

export default function ProjectsView({ initialProjects }: ProjectsViewProps) {
  const router = useRouter();
  const [projects, setProjects] = useState<ProjectWithOverdue[]>(initialProjects);
  const [open, setOpen] = useState(false);
  const [editOpen, setEditOpen] = useState(false);
  const [editingProject, setEditingProject] = useState<Project | null>(null);
  const [form, setForm] = useState<NewProject>({
    managementNumber: "",
    manager: "",
    client: "",
    projectNumber: "",
    completionMonth: "",
  });
  const [calendarOpen, setCalendarOpen] = useState(false);
  const [editCalendarOpen, setEditCalendarOpen] = useState(false);
  const [calendarYear, setCalendarYear] = useState(new Date().getFullYear());
  const [deleteOpen, setDeleteOpen] = useState(false);
  const [deletingProject, setDeletingProject] = useState<Project | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);

  // 編集モード関連
  const [isEditMode, setIsEditMode] = useState(false);
  const [editingCell, setEditingCell] = useState<{ projectId: number; columnKey: string } | null>(null);
  const [editingValue, setEditingValue] = useState("");
  const [isSaving, setIsSaving] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  // フィルター機能用のstate
  const [filterOpen, setFilterOpen] = useState<string | null>(null);
  const [selectedManagementNumbers, setSelectedManagementNumbers] = useState<Set<string>>(new Set());
  const [selectedManagers, setSelectedManagers] = useState<Set<string>>(new Set());
  const [selectedClients, setSelectedClients] = useState<Set<string>>(new Set());
  const [selectedProjectNumbers, setSelectedProjectNumbers] = useState<Set<string>>(new Set());
  const [selectedCompletionMonths, setSelectedCompletionMonths] = useState<Set<string>>(new Set());
  const [filterSearchQuery, setFilterSearchQuery] = useState("");

  // 各フィルターの選択肢を取得
  const uniqueManagementNumbers = useMemo(() =>
    [...new Set(projects.map(p => p.managementNumber))].sort(), [projects]);
  const uniqueManagers = useMemo(() =>
    [...new Set(projects.map(p => p.manager))].sort(), [projects]);
  const uniqueClients = useMemo(() =>
    [...new Set(projects.map(p => p.client))].sort(), [projects]);
  const uniqueProjectNumbers = useMemo(() =>
    [...new Set(projects.map(p => p.projectNumber))].sort(), [projects]);
  const uniqueCompletionMonths = useMemo(() =>
    [...new Set(projects.map(p => p.completionMonth || "未設定"))].sort(), [projects]);

  // フィルター内検索で絞り込んだ選択肢
  const getFilteredOptions = (options: string[], searchQuery: string) => {
    if (!searchQuery.trim()) return options;
    const q = searchQuery.toLowerCase();
    return options.filter(opt => opt.toLowerCase().includes(q));
  };

  // チェックボックスの選択/解除
  const toggleSelection = (
    value: string,
    selectedSet: Set<string>,
    setSelectedSet: React.Dispatch<React.SetStateAction<Set<string>>>
  ) => {
    setSelectedSet(prev => {
      const newSet = new Set(prev);
      if (newSet.has(value)) {
        newSet.delete(value);
      } else {
        newSet.add(value);
      }
      return newSet;
    });
  };

  // 全選択/全解除
  const selectAll = (
    options: string[],
    setSelectedSet: React.Dispatch<React.SetStateAction<Set<string>>>
  ) => {
    setSelectedSet(new Set(options));
  };

  const clearAll = (
    setSelectedSet: React.Dispatch<React.SetStateAction<Set<string>>>
  ) => {
    setSelectedSet(new Set());
  };

  // 全フィルターをクリア
  const clearAllFilters = () => {
    setSelectedManagementNumbers(new Set());
    setSelectedManagers(new Set());
    setSelectedClients(new Set());
    setSelectedProjectNumbers(new Set());
    setSelectedCompletionMonths(new Set());
    setFilterSearchQuery("");
  };

  // フィルターが適用されているか
  const isFiltered = selectedManagementNumbers.size > 0 ||
    selectedManagers.size > 0 ||
    selectedClients.size > 0 ||
    selectedProjectNumbers.size > 0 ||
    selectedCompletionMonths.size > 0;

  // 検索フィルタリング（管理番号・案件番号・地権者・現地住所・コメント・TODO内容）+ チェックボックスフィルタ
  const filteredProjects = useMemo(() => {
    let result = projects;

    // テキスト検索フィルター
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      result = result.filter((project) => {
        const addr = (project.address ?? "").toLowerCase();
        const l1 = (project.landowner1 ?? "").toLowerCase();
        const l2 = (project.landowner2 ?? "").toLowerCase();
        const l3 = (project.landowner3 ?? "").toLowerCase();
        const commentText = (project.commentSearchText ?? "").toLowerCase();
        const todoText = (project.todoSearchText ?? "").toLowerCase();
        return (
          project.managementNumber.toLowerCase().includes(query) ||
          project.projectNumber.toLowerCase().includes(query) ||
          addr.includes(query) ||
          l1.includes(query) ||
          l2.includes(query) ||
          l3.includes(query) ||
          commentText.includes(query) ||
          todoText.includes(query)
        );
      });
    }

    // チェックボックスフィルター
    if (selectedManagementNumbers.size > 0) {
      result = result.filter(p => selectedManagementNumbers.has(p.managementNumber));
    }
    if (selectedManagers.size > 0) {
      result = result.filter(p => selectedManagers.has(p.manager));
    }
    if (selectedClients.size > 0) {
      result = result.filter(p => selectedClients.has(p.client));
    }
    if (selectedProjectNumbers.size > 0) {
      result = result.filter(p => selectedProjectNumbers.has(p.projectNumber));
    }
    if (selectedCompletionMonths.size > 0) {
      result = result.filter(p => selectedCompletionMonths.has(p.completionMonth || "未設定"));
    }

    return result;
  }, [projects, searchQuery, selectedManagementNumbers, selectedManagers, selectedClients, selectedProjectNumbers, selectedCompletionMonths]);

  const fetchProjects = () => {
    fetch("/api/projects", { cache: "no-store" })
      .then((res) => res.json())
      .then(setProjects)
      .catch((err) => {
        console.error("案件一覧の取得に失敗しました:", err);
      });
  };

  // 直近の検索履歴をローカルから読み込み
  useEffect(() => {
    setRecentSearches(getRecentSearches());
  }, []);

  const handleSearchFocus = () => setShowSuggestions(true);
  const handleSearchBlur = () => {
    setTimeout(() => setShowSuggestions(false), 200);
    const q = searchQuery.trim();
    if (q) setRecentSearches(addRecentSearch(q));
  };
  const handleSearchKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      const q = searchQuery.trim();
      if (q) setRecentSearches(addRecentSearch(q));
    }
  };
  const handleSuggestionClick = (text: string) => {
    setSearchQuery(text);
    setRecentSearches(addRecentSearch(text));
    setShowSuggestions(false);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!form.manager?.trim()) {
      alert("担当を選択してください");
      return;
    }
    setIsSubmitting(true);
    try {
      await fetch("/api/projects", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form),
      });
      setForm({ managementNumber: "", manager: "", client: "", projectNumber: "", completionMonth: "" });
      setOpen(false);
      fetchProjects();
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleEditSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editingProject) return;
    await fetch(`/api/projects/${editingProject.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(editingProject),
    });
    setEditOpen(false);
    setEditingProject(null);
    fetchProjects();
  };

  const openEditDialog = (project: Project, e: React.MouseEvent) => {
    e.stopPropagation();
    setEditingProject({ ...project });
    setEditOpen(true);
    if (project.completionMonth) {
      const [year] = project.completionMonth.split("-");
      setCalendarYear(parseInt(year, 10));
    } else {
      setCalendarYear(new Date().getFullYear());
    }
  };

  const openDeleteDialog = (project: Project, e: React.MouseEvent) => {
    e.stopPropagation();
    setDeletingProject(project);
    setDeleteOpen(true);
  };

  const handleDelete = async () => {
    if (!deletingProject) return;
    await fetch(`/api/projects/${deletingProject.id}`, {
      method: "DELETE",
    });
    setDeleteOpen(false);
    setDeletingProject(null);
    fetchProjects();
  };

  const selectMonth = (monthIndex: number) => {
    const monthStr = `${calendarYear}-${String(monthIndex + 1).padStart(2, "0")}`;
    setForm({ ...form, completionMonth: monthStr });
    setCalendarOpen(false);
  };

  const selectEditMonth = (monthIndex: number) => {
    if (!editingProject) return;
    const monthStr = `${calendarYear}-${String(monthIndex + 1).padStart(2, "0")}`;
    setEditingProject({ ...editingProject, completionMonth: monthStr });
    setEditCalendarOpen(false);
  };

  const formatCompletionMonth = (value: string | null | undefined) => {
    if (!value) return "";
    const [year, month] = value.split("-");
    return `${year}年${parseInt(month, 10)}月`;
  };

  // セル値を取得するヘルパー
  const getCellValue = (project: ProjectWithOverdue, key: string): string => {
    const value = (project as Record<string, unknown>)[key];
    if (value === null || value === undefined) return "-";
    if (key === "completionMonth") return formatCompletionMonth(value as string) || "-";
    return String(value);
  };

  // セル値を取得するヘルパー（編集用 - 生の値を返す）
  const getRawCellValue = (project: ProjectWithOverdue, key: string): string => {
    const value = (project as Record<string, unknown>)[key];
    if (value === null || value === undefined) return "";
    return String(value);
  };

  // セル編集開始
  const startEditCell = useCallback((projectId: number, columnKey: string, currentValue: string) => {
    if (!isEditMode) return;
    setEditingCell({ projectId, columnKey });
    setEditingValue(currentValue === "-" ? "" : currentValue);
    setTimeout(() => inputRef.current?.focus(), 0);
  }, [isEditMode]);

  // セル編集保存
  const saveEditCell = useCallback(async () => {
    if (!editingCell) return;

    setIsSaving(true);
    try {
      const project = projects.find(p => p.id === editingCell.projectId);
      if (!project) return;

      const updateData = {
        ...project,
        [editingCell.columnKey]: editingValue || null,
      };

      const res = await fetch(`/api/projects/${editingCell.projectId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updateData),
      });

      if (res.ok) {
        // ローカルステートを更新
        setProjects(prev => prev.map(p =>
          p.id === editingCell.projectId
            ? { ...p, [editingCell.columnKey]: editingValue || null }
            : p
        ));
      }
    } catch (error) {
      console.error("Failed to save cell:", error);
    } finally {
      setIsSaving(false);
      setEditingCell(null);
      setEditingValue("");
    }
  }, [editingCell, editingValue, projects]);

  // セル編集キャンセル
  const cancelEditCell = useCallback(() => {
    setEditingCell(null);
    setEditingValue("");
  }, []);

  // キーボードイベント処理
  const handleCellKeyDown = useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      e.preventDefault();
      saveEditCell();
    } else if (e.key === "Escape") {
      e.preventDefault();
      cancelEditCell();
    } else if (e.key === "Tab") {
      e.preventDefault();
      saveEditCell();
    }
  }, [saveEditCell, cancelEditCell]);

  // 編集モード切り替え
  const toggleEditMode = useCallback(() => {
    if (isEditMode) {
      // 編集モード終了時に未保存の編集をキャンセル
      cancelEditCell();
    }
    setIsEditMode(prev => !prev);
  }, [isEditMode, cancelEditCell]);

  // フィルター付きヘッダーを生成するコンポーネント
  const FilterableHeader = ({
    columnKey,
    label,
    options,
    selected,
    setSelected,
  }: {
    columnKey: string;
    label: string;
    options: string[];
    selected: Set<string>;
    setSelected: React.Dispatch<React.SetStateAction<Set<string>>>;
  }) => (
    <Popover open={filterOpen === columnKey} onOpenChange={(open) => {
      setFilterOpen(open ? columnKey : null);
      if (!open) setFilterSearchQuery("");
    }}>
      <PopoverTrigger asChild>
        <Button
          variant="ghost"
          className={cn(
            "h-auto p-1 text-xs font-semibold hover:text-foreground justify-start gap-1 whitespace-nowrap",
            selected.size > 0 && "text-primary"
          )}
        >
          <Filter className={cn("h-3 w-3", selected.size > 0 && "text-primary")} />
          {label}
          <ChevronDown className="h-2 w-2" />
          {selected.size > 0 && (
            <Badge variant="secondary" className="ml-1 h-4 px-1 text-[9px]">
              {selected.size}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-64 p-0" align="start">
        <div className="p-2 border-b">
          <div className="flex items-center gap-2 mb-2">
            <Search className="h-3 w-3 text-muted-foreground" />
            <Input
              placeholder="検索..."
              value={filterSearchQuery}
              onChange={(e) => setFilterSearchQuery(e.target.value)}
              className="h-7 text-xs"
            />
          </div>
          <div className="flex items-center gap-2">
            <Button variant="outline" size="sm" onClick={() => selectAll(getFilteredOptions(options, filterSearchQuery), setSelected)} className="h-6 text-xs flex-1">
              全選択
            </Button>
            <Button variant="outline" size="sm" onClick={() => clearAll(setSelected)} className="h-6 text-xs flex-1">
              全解除
            </Button>
          </div>
        </div>
        <ScrollArea className="h-[200px]">
          <div className="p-1">
            {getFilteredOptions(options, filterSearchQuery).length === 0 ? (
              <p className="text-xs text-muted-foreground text-center py-4">見つかりません</p>
            ) : (
              getFilteredOptions(options, filterSearchQuery).map((value) => (
                <div key={value} className="flex items-center gap-2 px-2 py-1.5 rounded hover:bg-muted/50 cursor-pointer" onClick={() => toggleSelection(value, selected, setSelected)}>
                  <Checkbox checked={selected.has(value)} onCheckedChange={() => toggleSelection(value, selected, setSelected)} className="h-3 w-3" />
                  <span className="text-xs truncate">{columnKey === "completionMonth" && value !== "未設定" ? formatCompletionMonthForFilter(value) : value}</span>
                </div>
              ))
            )}
          </div>
        </ScrollArea>
        <div className="p-2 border-t">
          <Button variant="default" size="sm" onClick={() => { setFilterOpen(null); setFilterSearchQuery(""); }} className="w-full h-7 text-xs">
            適用 ({selected.size}件選択中)
          </Button>
        </div>
      </PopoverContent>
    </Popover>
  );

  return (
    <div className="min-h-screen bg-background px-4">
      <div className="py-6">
        <div className="space-y-4">
          <div className="flex items-center justify-between gap-4">
            <div className="space-y-1 shrink-0">
              <h1 className="text-2xl font-semibold">案件一覧</h1>
              <p className="text-sm text-muted-foreground">
                担当する案件を確認できます
              </p>
            </div>

            {/* 検索欄（直近3件のサジェスト付き） */}
            <div className="relative flex-1 max-w-md">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground z-10 pointer-events-none" />
              <Input
                placeholder="管理番号・案件番号・地権者・現地住所で検索"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onFocus={handleSearchFocus}
                onBlur={handleSearchBlur}
                onKeyDown={handleSearchKeyDown}
                className="w-full pl-10 h-10 text-sm bg-muted/50 border-0 focus-visible:ring-2 rounded-lg"
              />
              {showSuggestions && recentSearches.length > 0 && (
                <div
                  className="absolute left-0 right-0 top-full mt-1 z-20 rounded-lg border border-border bg-card shadow-lg overflow-hidden"
                  onMouseDown={(e) => e.preventDefault()}
                >
                  <p className="px-3 py-1.5 text-xs text-muted-foreground border-b border-border bg-muted/30">
                    最近の検索
                  </p>
                  <ul className="py-1">
                    {recentSearches.map((text) => (
                      <li key={text}>
                        <button
                          type="button"
                          className="w-full px-3 py-2 text-left text-sm hover:bg-muted/50 focus:bg-muted/50 focus:outline-none"
                          onMouseDown={() => handleSuggestionClick(text)}
                        >
                          {text}
                        </button>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>

            {/* 編集ボタン */}
            <Button
              size="sm"
              variant={isEditMode ? "default" : "outline"}
              onClick={toggleEditMode}
              className={cn(isEditMode && "bg-primary text-primary-foreground")}
            >
              {isEditMode ? (
                <>
                  <Check className="h-4 w-4" />
                  編集完了
                </>
              ) : (
                <>
                  <Pencil className="h-4 w-4" />
                  編集
                </>
              )}
            </Button>

            <Dialog open={open} onOpenChange={setOpen}>
              <DialogTrigger asChild>
                <Button size="sm">
                  <Plus className="h-4 w-4" />
                  新規登録
                </Button>
              </DialogTrigger>
              <DialogContent>
                <DialogHeader>
                  <DialogTitle>案件を新規登録</DialogTitle>
                </DialogHeader>
                <form onSubmit={handleSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="managementNumber">管理番号</Label>
                    <Input
                      id="managementNumber"
                      value={form.managementNumber}
                      onChange={(e) => setForm({ ...form, managementNumber: e.target.value })}
                      placeholder="例: P-001"
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="manager">担当</Label>
                    <Select
                      value={form.manager || undefined}
                      onValueChange={(value) => setForm({ ...form, manager: value })}
                    >
                      <SelectTrigger id="manager" className="w-full">
                        <SelectValue placeholder="選択してください" />
                      </SelectTrigger>
                      <SelectContent>
                        {MANAGER_OPTIONS.map((name) => (
                          <SelectItem key={name} value={name}>
                            {name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="client">販売先</Label>
                    <Input
                      id="client"
                      value={form.client}
                      onChange={(e) => setForm({ ...form, client: e.target.value })}
                      placeholder="例: 〇〇不動産"
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="projectNumber">案件番号</Label>
                    <Input
                      id="projectNumber"
                      value={form.projectNumber}
                      onChange={(e) => setForm({ ...form, projectNumber: e.target.value })}
                      placeholder="例: 2026-0001"
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label>完成月</Label>
                    <Popover open={calendarOpen} onOpenChange={setCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button
                          type="button"
                          variant="outline"
                          className="w-full justify-start text-left font-normal"
                        >
                          <CalendarIcon className="mr-2 h-4 w-4" />
                          {form.completionMonth ? formatCompletionMonth(form.completionMonth) : "選択してください"}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-64 p-3">
                        <div className="flex items-center justify-between mb-3">
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => setCalendarYear(calendarYear - 1)}
                          >
                            <ChevronLeft className="h-4 w-4" />
                          </Button>
                          <span className="font-medium">{calendarYear}年</span>
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => setCalendarYear(calendarYear + 1)}
                          >
                            <ChevronRight className="h-4 w-4" />
                          </Button>
                        </div>
                        <div className="grid grid-cols-3 gap-2">
                          {MONTHS.map((month, index) => (
                            <Button
                              key={month}
                              type="button"
                              variant="ghost"
                              size="sm"
                              className="h-9"
                              onClick={() => selectMonth(index)}
                            >
                              {month}
                            </Button>
                          ))}
                        </div>
                      </PopoverContent>
                    </Popover>
                  </div>
                  <div className="flex justify-end gap-2">
                    <Button type="button" variant="outline" onClick={() => setOpen(false)} disabled={isSubmitting}>
                      キャンセル
                    </Button>
                    <Button type="submit" disabled={isSubmitting}>
                      {isSubmitting ? (
                        <>
                          <Loader2 className="h-4 w-4 animate-spin mr-2" />
                          登録中...
                        </>
                      ) : (
                        "登録"
                      )}
                    </Button>
                  </div>
                </form>
              </DialogContent>
            </Dialog>
          </div>

          {/* 編集ダイアログ */}
          <Dialog open={editOpen} onOpenChange={setEditOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>案件を編集</DialogTitle>
              </DialogHeader>
              {editingProject && (
                <form onSubmit={handleEditSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="edit-managementNumber">管理番号</Label>
                    <Input
                      id="edit-managementNumber"
                      value={editingProject.managementNumber}
                      onChange={(e) => setEditingProject({ ...editingProject, managementNumber: e.target.value })}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="edit-manager">担当</Label>
                    <Select
                      value={editingProject.manager}
                      onValueChange={(value) => setEditingProject({ ...editingProject, manager: value })}
                    >
                      <SelectTrigger id="edit-manager" className="w-full">
                        <SelectValue placeholder="選択してください" />
                      </SelectTrigger>
                      <SelectContent>
                        {MANAGER_OPTIONS.map((name) => (
                          <SelectItem key={name} value={name}>
                            {name}
                          </SelectItem>
                        ))}
                        {editingProject.manager && !MANAGER_OPTIONS.includes(editingProject.manager) && (
                          <SelectItem value={editingProject.manager}>{editingProject.manager}</SelectItem>
                        )}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="edit-client">販売先</Label>
                    <Input
                      id="edit-client"
                      value={editingProject.client}
                      onChange={(e) => setEditingProject({ ...editingProject, client: e.target.value })}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="edit-projectNumber">案件番号</Label>
                    <Input
                      id="edit-projectNumber"
                      value={editingProject.projectNumber}
                      onChange={(e) => setEditingProject({ ...editingProject, projectNumber: e.target.value })}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label>完成月</Label>
                    <Popover open={editCalendarOpen} onOpenChange={setEditCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button
                          type="button"
                          variant="outline"
                          className="w-full justify-start text-left font-normal"
                        >
                          <CalendarIcon className="mr-2 h-4 w-4" />
                          {editingProject.completionMonth ? formatCompletionMonth(editingProject.completionMonth) : "選択してください"}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-64 p-3">
                        <div className="flex items-center justify-between mb-3">
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => setCalendarYear(calendarYear - 1)}
                          >
                            <ChevronLeft className="h-4 w-4" />
                          </Button>
                          <span className="font-medium">{calendarYear}年</span>
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => setCalendarYear(calendarYear + 1)}
                          >
                            <ChevronRight className="h-4 w-4" />
                          </Button>
                        </div>
                        <div className="grid grid-cols-3 gap-2">
                          {MONTHS.map((month, index) => (
                            <Button
                              key={month}
                              type="button"
                              variant="ghost"
                              size="sm"
                              className="h-9"
                              onClick={() => selectEditMonth(index)}
                            >
                              {month}
                            </Button>
                          ))}
                        </div>
                      </PopoverContent>
                    </Popover>
                  </div>
                  <div className="flex justify-end gap-2">
                    <Button type="button" variant="outline" onClick={() => setEditOpen(false)}>
                      キャンセル
                    </Button>
                    <Button type="submit">保存</Button>
                  </div>
                </form>
              )}
            </DialogContent>
          </Dialog>

          {/* 削除確認ダイアログ */}
          <AlertDialog open={deleteOpen} onOpenChange={setDeleteOpen}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>案件を削除</AlertDialogTitle>
                <AlertDialogDescription>
                  「{deletingProject?.managementNumber}」を削除しますか？
                  <br />
                  関連する進捗もすべて削除されます。
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>キャンセル</AlertDialogCancel>
                <AlertDialogAction
                  onClick={handleDelete}
                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                >
                  削除
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>

          {/* フィルター適用中の表示 */}
          {isFiltered && (
            <div className="flex items-center gap-2 text-sm">
              <Badge variant="secondary" className="gap-1">
                <Filter className="h-3 w-3" />
                {filteredProjects.length}件を表示中
              </Badge>
              <Button
                variant="ghost"
                size="sm"
                onClick={clearAllFilters}
                className="h-7 text-xs"
              >
                <X className="h-3 w-3 mr-1" />
                フィルターを解除
              </Button>
            </div>
          )}

          {/* 編集モード時のヘルプテキスト */}
          {isEditMode && (
            <div className="flex items-center gap-2 text-sm p-2 rounded-lg bg-primary/10 border border-primary/20">
              <Pencil className="h-4 w-4 text-primary" />
              <span className="text-primary font-medium">編集モード:</span>
              <span className="text-muted-foreground">セルをクリックして編集 | Enter で保存 | Escape でキャンセル</span>
            </div>
          )}

          {/* 横スクロールのヒント */}
          <div className="flex items-center gap-2 text-sm p-3 rounded-lg bg-blue-50 dark:bg-blue-950/30 border border-blue-200 dark:border-blue-800">
            <ChevronRight className="h-4 w-4 text-blue-500 animate-pulse" />
            <span className="text-blue-700 dark:text-blue-300">
              <span className="font-medium">横スクロール:</span>
              {" "}右側にもデータがあります。テーブル上で <span className="font-medium">Shift + マウスホイール</span> または <span className="font-medium">横スクロール</span> で確認できます。
            </span>
          </div>

          {/* 横スクロール対応テーブル - 固定カラムとスクロール可能カラムを分離 */}
          <div className="relative">
            <div className="rounded-lg border border-border overflow-hidden">
              <div className="flex">
              {/* 固定カラム部分（管理番号、担当、販売先、販売店案件番号） */}
              <div className="flex-shrink-0 border-r border-border bg-background z-10">
                <Table>
                  <TableHeader>
                    <TableRow className="h-12 bg-muted/30">
                      <TableHead className="px-1 bg-muted/30" style={{ minWidth: "120px" }}>
                        <FilterableHeader
                          columnKey="managementNumber"
                          label="管理番号"
                          options={uniqueManagementNumbers}
                          selected={selectedManagementNumbers}
                          setSelected={setSelectedManagementNumbers}
                        />
                      </TableHead>
                      <TableHead className="px-1 bg-muted/30" style={{ minWidth: "80px" }}>
                        <FilterableHeader
                          columnKey="manager"
                          label="担当"
                          options={uniqueManagers}
                          selected={selectedManagers}
                          setSelected={setSelectedManagers}
                        />
                      </TableHead>
                      <TableHead className="px-1 bg-muted/30" style={{ minWidth: "120px" }}>
                        <FilterableHeader
                          columnKey="client"
                          label="販売先"
                          options={uniqueClients}
                          selected={selectedClients}
                          setSelected={setSelectedClients}
                        />
                      </TableHead>
                      <TableHead className="px-1 bg-muted/30" style={{ minWidth: "140px" }}>
                        <FilterableHeader
                          columnKey="projectNumber"
                          label="販売店 案件番号"
                          options={uniqueProjectNumbers}
                          selected={selectedProjectNumbers}
                          setSelected={setSelectedProjectNumbers}
                        />
                      </TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {filteredProjects.length === 0 ? (
                      <TableRow className="h-16">
                        <TableCell colSpan={4} className="text-center text-muted-foreground text-sm py-8">
                          {searchQuery ? "検索結果がありません" : "案件がありません"}
                        </TableCell>
                      </TableRow>
                    ) : (
                      filteredProjects.map((project) => (
                        <TableRow
                          key={project.id}
                          className={cn(
                            "h-12",
                            !isEditMode && "cursor-pointer hover:bg-muted/50"
                          )}
                          onClick={() => {
                            if (!isEditMode) {
                              router.push(`/projects/${project.id}`);
                            }
                          }}
                        >
                          {/* 管理番号 */}
                          <TableCell className="font-medium text-sm py-2 px-2 bg-background">
                            {editingCell?.projectId === project.id && editingCell?.columnKey === "managementNumber" ? (
                              <Input
                                ref={inputRef}
                                value={editingValue}
                                onChange={(e) => setEditingValue(e.target.value)}
                                onKeyDown={handleCellKeyDown}
                                onBlur={saveEditCell}
                                className="h-8 text-sm"
                                disabled={isSaving}
                              />
                            ) : (
                              <div
                                className={cn(
                                  "flex items-center gap-2",
                                  isEditMode && "cursor-text hover:bg-muted/50 px-1 py-0.5 rounded"
                                )}
                                onClick={(e) => {
                                  if (isEditMode) {
                                    e.stopPropagation();
                                    startEditCell(project.id, "managementNumber", getRawCellValue(project, "managementNumber"));
                                  }
                                }}
                              >
                                {project.hasOverdue && (
                                  <AlertCircle className="h-4 w-4 text-red-500 shrink-0" />
                                )}
                                <span className="truncate">{project.managementNumber}</span>
                              </div>
                            )}
                          </TableCell>
                          {/* 担当 */}
                          <TableCell className="text-sm py-2 px-2 bg-background">
                            {editingCell?.projectId === project.id && editingCell?.columnKey === "manager" ? (
                              <Input
                                ref={inputRef}
                                value={editingValue}
                                onChange={(e) => setEditingValue(e.target.value)}
                                onKeyDown={handleCellKeyDown}
                                onBlur={saveEditCell}
                                className="h-8 text-sm"
                                disabled={isSaving}
                              />
                            ) : (
                              <div
                                className={cn(
                                  isEditMode && "cursor-text hover:bg-muted/50 px-1 py-0.5 rounded"
                                )}
                                onClick={(e) => {
                                  if (isEditMode) {
                                    e.stopPropagation();
                                    startEditCell(project.id, "manager", getRawCellValue(project, "manager"));
                                  }
                                }}
                              >
                                {getCellValue(project, "manager")}
                              </div>
                            )}
                          </TableCell>
                          {/* 販売先 */}
                          <TableCell className="text-sm py-2 px-2 bg-background">
                            {editingCell?.projectId === project.id && editingCell?.columnKey === "client" ? (
                              <Input
                                ref={inputRef}
                                value={editingValue}
                                onChange={(e) => setEditingValue(e.target.value)}
                                onKeyDown={handleCellKeyDown}
                                onBlur={saveEditCell}
                                className="h-8 text-sm"
                                disabled={isSaving}
                              />
                            ) : (
                              <div
                                className={cn(
                                  isEditMode && "cursor-text hover:bg-muted/50 px-1 py-0.5 rounded"
                                )}
                                onClick={(e) => {
                                  if (isEditMode) {
                                    e.stopPropagation();
                                    startEditCell(project.id, "client", getRawCellValue(project, "client"));
                                  }
                                }}
                              >
                                {getCellValue(project, "client")}
                              </div>
                            )}
                          </TableCell>
                          {/* 販売店 案件番号 */}
                          <TableCell className="text-sm py-2 px-2 bg-background">
                            {editingCell?.projectId === project.id && editingCell?.columnKey === "projectNumber" ? (
                              <Input
                                ref={inputRef}
                                value={editingValue}
                                onChange={(e) => setEditingValue(e.target.value)}
                                onKeyDown={handleCellKeyDown}
                                onBlur={saveEditCell}
                                className="h-8 text-sm"
                                disabled={isSaving}
                              />
                            ) : (
                              <div
                                className={cn(
                                  isEditMode && "cursor-text hover:bg-muted/50 px-1 py-0.5 rounded"
                                )}
                                onClick={(e) => {
                                  if (isEditMode) {
                                    e.stopPropagation();
                                    startEditCell(project.id, "projectNumber", getRawCellValue(project, "projectNumber"));
                                  }
                                }}
                              >
                                {getCellValue(project, "projectNumber")}
                              </div>
                            )}
                          </TableCell>
                        </TableRow>
                      ))
                    )}
                  </TableBody>
                </Table>
              </div>

              {/* スクロール可能カラム部分 */}
              <ScrollArea className="flex-1">
                <div className="min-w-max">
                  <Table>
                    <TableHeader>
                      <TableRow className="h-12 bg-muted/30">
                        {/* 残りのカラム（フィルターなし） */}
                        {TABLE_COLUMNS.slice(4, -1).map((col) => (
                          <TableHead
                            key={col.key}
                            className="px-2 whitespace-nowrap text-xs font-semibold bg-muted/30"
                            style={{ minWidth: col.width }}
                          >
                            {col.label}
                          </TableHead>
                        ))}
                        {/* 完成月（フィルター付き） */}
                        <TableHead className="px-1 bg-muted/30" style={{ minWidth: "100px" }}>
                          <FilterableHeader
                            columnKey="completionMonth"
                            label="完成月"
                            options={uniqueCompletionMonths}
                            selected={selectedCompletionMonths}
                            setSelected={setSelectedCompletionMonths}
                          />
                        </TableHead>
                        {/* 完工 */}
                        <TableHead className="px-2 whitespace-nowrap text-xs font-semibold bg-muted/30" style={{ minWidth: "60px" }}>
                          完工
                        </TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredProjects.length === 0 ? (
                        <TableRow className="h-16">
                          <TableCell colSpan={TABLE_COLUMNS.length - 4} className="text-center text-muted-foreground text-sm py-8">
                            &nbsp;
                          </TableCell>
                        </TableRow>
                      ) : (
                        filteredProjects.map((project) => (
                          <TableRow
                            key={project.id}
                            className="h-12 hover:bg-muted/50"
                          >
                            {/* 残りのカラム（クリックしても詳細画面には遷移しない） */}
                            {TABLE_COLUMNS.slice(4).map((col) => (
                              <TableCell
                                key={col.key}
                                className="text-sm py-2 px-2 whitespace-nowrap"
                              >
                                {editingCell?.projectId === project.id && editingCell?.columnKey === col.key ? (
                                  <Input
                                    ref={inputRef}
                                    value={editingValue}
                                    onChange={(e) => setEditingValue(e.target.value)}
                                    onKeyDown={handleCellKeyDown}
                                    onBlur={saveEditCell}
                                    className="h-8 text-sm min-w-[100px]"
                                    disabled={isSaving}
                                  />
                                ) : (
                                  <div
                                    className={cn(
                                      isEditMode && "cursor-text hover:bg-muted/50 px-1 py-0.5 rounded min-h-[24px]"
                                    )}
                                    onClick={(e) => {
                                      if (isEditMode) {
                                        e.stopPropagation();
                                        startEditCell(project.id, col.key, getRawCellValue(project, col.key));
                                      }
                                    }}
                                  >
                                    {getCellValue(project, col.key)}
                                  </div>
                                )}
                              </TableCell>
                            ))}
                          </TableRow>
                        ))
                      )}
                    </TableBody>
                  </Table>
                </div>
                <ScrollBar orientation="horizontal" />
              </ScrollArea>
            </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/SideNav.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { Home, FolderKanban, Scale, Wrench, LogOut, Calendar, CalendarDays, MapPin, GitBranch, ListTodo, MessageSquarePlus, Users } from "lucide-react";
import { signOut } from "next-auth/react";

import { cn } from "@/lib/utils";
import { ThemeToggle } from "@/components/ThemeToggle";

const items = [
  { href: "/", label: "ホーム", icon: Home },
  { href: "/todo", label: "TODO", icon: ListTodo },
  { href: "/projects", label: "案件", icon: FolderKanban },
  { href: "/todos", label: "タイムライン", icon: GitBranch },
  { href: "/calendar", label: "カレンダー", icon: Calendar },
  { href: "/meetings", label: "会議", icon: Users },
  { href: "/map", label: "マップ", icon: MapPin },
  { href: "/schedule", label: "スケジュール", icon: CalendarDays },
  { href: "/legal", label: "法令確認", icon: Scale },
  { href: "/tools", label: "ツール", icon: Wrench },
  { href: "/feedbacks", label: "要望", icon: MessageSquarePlus },
] as const;

export function SideNav() {
  const pathname = usePathname();

  if (pathname === "/login") return null;

  return (
    <aside className="sticky top-0 h-screen w-72 shrink-0 border-r border-sidebar-border bg-sidebar text-sidebar-foreground">
      <div className="flex h-full flex-col p-4">
        {/* ロゴ */}
        <div className="mb-4 rounded-xl px-3 py-2">
          <span className="text-lg font-semibold tracking-tight">ALAN</span>
        </div>

        <nav className="space-y-1">
          {items.map((item) => {
            // サブパスでもアクティブにする
            const active = item.href === "/tools"
              ? pathname.startsWith("/tools")
              : item.href === "/todos"
                ? pathname.startsWith("/todos")
                : item.href === "/map"
                  ? pathname.startsWith("/map")
                  : item.href === "/calendar"
                    ? pathname.startsWith("/calendar")
                    : item.href === "/meetings"
                      ? pathname.startsWith("/meetings")
                      : item.href === "/feedbacks"
                        ? pathname.startsWith("/feedbacks")
                        : pathname === item.href;
            const Icon = item.icon;
            return (
              <Link
                key={item.href}
                href={item.href}
                className={cn(
                  "flex items-center gap-2 rounded-xl px-3 py-2 text-sm transition-colors hover:bg-sidebar-accent",
                  active && "bg-sidebar-accent text-sidebar-accent-foreground"
                )}
              >
                <Icon className="h-4 w-4" />
                <span>{item.label}</span>
              </Link>
            );
          })}
        </nav>

        <div className="mt-auto border-t border-sidebar-border pt-4 space-y-2">
          <div className="flex items-center justify-between px-3 py-1">
            <span className="text-sm text-muted-foreground">テーマ</span>
            <ThemeToggle />
          </div>
          <button
            onClick={() => signOut({ callbackUrl: "/login" })}
            className="flex w-full items-center gap-2 rounded-xl px-3 py-2 text-sm transition-colors hover:bg-sidebar-accent text-muted-foreground hover:text-foreground"
          >
            <LogOut className="h-4 w-4" />
            <span>ログアウト</span>
          </button>
        </div>
      </div>
    </aside>
  );
}
</file>

<file path="src/db/schema.ts">
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";

export const projects = sqliteTable("projects", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  // 基本情報
  managementNumber: text("management_number").notNull(), // 管理番号
  manager: text("manager").notNull(), // 担当
  client: text("client").notNull(), // 販売先
  projectNumber: text("project_number").notNull(), // 販売店 案件番号
  availability: text("availability"), // 可否
  businessType: text("business_type"), // 業務
  designPower: text("design_power"), // 設計/電力
  sales: text("sales"), // 営業
  parcelCount: text("parcel_count"), // 筆数
  prefecture: text("prefecture"), // 都道府県
  blank1: text("blank_1"), // (空白)
  link: text("link"), // リンク
  agreementMonth: text("agreement_month"), // 合意書 計上月
  projectSubmissionScheduled: text("project_submission_scheduled"), // 案件提出 予定日
  projectSubmissionDate: text("project_submission_date"), // 案件提出日
  fellingConsentRequest: text("felling_consent_request"), // 伐採/工事 承諾書依頼
  fellingConsentComplete: text("felling_consent_complete"), // 伐採/工事 承諾書揃う
  siteInvestigation: text("site_investigation"), // 現調
  level: text("level"), // レベル

  // 土地契約関連
  landContractRequestScheduled: text("land_contract_request_scheduled"), // 土地売契 依頼予定日
  landContractRequest: text("land_contract_request"), // 土地売契 依頼
  landContractScheduled: text("land_contract_scheduled"), // 土地契約 締結予定日
  landContractDate: text("land_contract_date"), // 土地契約 締結日
  landPrice: text("land_price"), // 土地代

  // 地権者情報（統合）
  landowner: text("landowner"), // 地権者
  landownerAddress: text("landowner_address"), // 地権者住所
  landAreaTotal: text("land_area_total"), // 土地 ㎡数
  correctionStatus: text("correction_status"), // 更正 有無
  inheritanceStatus: text("inheritance_status"), // 相続 有無
  mortgageStatus: text("mortgage_status"), // 抵当権 有無
  hazardAtHome: text("hazard_at_home"), // ハザード（アットホーム）
  photo: text("photo"), // 写真
  snowfall: text("snowfall"), // 積雪
  windSpeedValue: text("wind_speed_value"), // 風速
  neighborhoodFelling: text("neighborhood_felling"), // 近隣伐採
  landRemarks: text("land_remarks"), // 土地備考
  landCategory: text("land_category"), // 地目

  // 農振関連
  nourinStatus: text("nourin_status"), // 農振 有無
  nourinScrivenerRequest: text("nourin_scrivener_request"), // 農振 行政書士依頼
  nourinApplicationScheduled: text("nourin_application_scheduled"), // 農振 申請予定日
  nourinApplicationDate: text("nourin_application_date"), // 農振 申請日
  nourinCompletionScheduled: text("nourin_completion_scheduled"), // 農振 完了予定日
  nourinCompletionDate: text("nourin_completion_date"), // 農振 完了日

  // 農転関連
  noutenStatus: text("nouten_status"), // 農転 有無
  landCategoryChangeRequest: text("land_category_change_request"), // 地目変更 営業への依頼
  noutenScrivenerRequest: text("nouten_scrivener_request"), // 農転 行政書士依頼
  noutenApplicationScheduled: text("nouten_application_scheduled"), // 農転/地目 申請予定日
  noutenApplicationDate: text("nouten_application_date"), // 農転/地目 申請日
  noutenCompletionScheduled: text("nouten_completion_scheduled"), // 農転/地目 完了予定日
  noutenCompletionDate: text("nouten_completion_date"), // 農転/地目 完了日

  // 規制・造成関連
  regulationCategory: text("regulation_category"), // 規制 区分
  developmentStatus: text("development_status"), // 造成 有無
  residentialDevApplicationScheduled: text("residential_dev_application_scheduled"), // 宅造法 申請予定日
  residentialDevApplicationDate: text("residential_dev_application_date"), // 宅造法 申請日
  residentialDevCompletionScheduled: text("residential_dev_completion_scheduled"), // 宅造法 完了予定日
  residentialDevCompletionDate: text("residential_dev_completion_date"), // 宅造法 完了日

  // その他法令関連
  otherRegulations: text("other_regulations"), // その他 法令
  regulationApplicationScheduled: text("regulation_application_scheduled"), // 法令申請予定日
  regulationApplicationPaymentDate: text("regulation_application_payment_date"), // 法令申請日 支払日
  regulationPermitScheduled: text("regulation_permit_scheduled"), // 法令許可予定日
  regulationPermitDate: text("regulation_permit_date"), // 法令許可日
  completionNotification: text("completion_notification"), // 完了届
  regulationRemarks: text("regulation_remarks"), // 法令備考

  // モジュール・システム関連
  moduleType: text("module_type"), // ﾓｼﾞｭｰﾙ
  moduleCount: text("module_count"), // ﾓｼﾞｭｰﾙ 枚数
  moduleCapacity: text("module_capacity"), // ﾓｼﾞｭｰﾙ 容量
  systemCapacity: text("system_capacity"), // ｼｽﾃﾑ 容量
  powerSimulation: text("power_simulation"), // 発電シミュレーション

  // 電力関連
  powerCompany: text("power_company"), // 電力 会社
  powerApplicationDestination: text("power_application_destination"), // 電力申請 申請先
  powerApplicationScheduled: text("power_application_scheduled"), // 電力 申請予定日
  powerApplicationDate: text("power_application_date"), // 電力 申請日
  powerResponseScheduled: text("power_response_scheduled"), // 電力 回答予定日
  powerResponseDate: text("power_response_date"), // 電力 回答日
  estimatedBurden: text("estimated_burden"), // 概算 負担金額
  additionalBurden: text("additional_burden"), // 追加 負担金額
  burdenPaymentDate: text("burden_payment_date"), // 負担金 支払日
  interconnectionStatus: text("interconnection_status"), // 連系可否
  interconnectionDetails: text("interconnection_details"), // 連系詳細
  powerRemarks: text("power_remarks"), // 電力備考

  // 土地決済関連
  landSettlementDocScheduled: text("land_settlement_doc_scheduled"), // 土地決済書類回収予定
  landSettlementDocCollection: text("land_settlement_doc_collection"), // 土地決済書類回収
  landSettlementScheduled: text("land_settlement_scheduled"), // 土地決済予定日
  landSettlementDate: text("land_settlement_date"), // 土地 決済日

  // 所有権移転登記関連
  ownershipTransferAppScheduled: text("ownership_transfer_app_scheduled"), // 所有権移転登記申請予定
  ownershipTransferApplication: text("ownership_transfer_application"), // 所有権移転登記申請
  ownershipTransferCompScheduled: text("ownership_transfer_comp_scheduled"), // 所有権移転登記完了予定
  ownershipTransferCompletion: text("ownership_transfer_completion"), // 所有権移転登記完了

  // 費用関連
  developmentCost: text("development_cost"), // 造成費用
  surveyingCost: text("surveying_cost"), // 測量費用
  administrativeCost: text("administrative_cost"), // 行政費用
  otherCostTotal: text("other_cost_total"), // その他 費用合計

  // 近隣挨拶関連
  neighborGreetingRequestScheduled: text("neighbor_greeting_request_scheduled"), // 近隣挨拶 依頼予定日
  neighborGreetingRequestDate: text("neighbor_greeting_request_date"), // 近隣挨拶 依頼日
  neighborGreetingScheduled: text("neighbor_greeting_scheduled"), // 近隣挨拶 予定日
  neighborGreetingDate: text("neighbor_greeting_date"), // 近隣挨拶 実施日

  // SS関連
  ssRequestScheduled: text("ss_request_scheduled"), // SS 依頼予定日
  ssRequestDate: text("ss_request_date"), // SS 依頼日
  ssScheduled: text("ss_scheduled"), // SS 予定日
  ssDate: text("ss_date"), // SS 実施日

  // 注文・発注関連
  orderCreationRequestScheduled: text("order_creation_request_scheduled"), // 注文書作成依頼予定
  orderCreationRequest: text("order_creation_request"), // 注文書作成依頼
  orderScheduled: text("order_scheduled"), // 発注予定日
  orderDate: text("order_date"), // 発注日
  deliveryDate: text("delivery_date"), // 納品日

  // 工事関連
  constructionAvailableDate: text("construction_available_date"), // 着工可能日
  constructionStartScheduled: text("construction_start_scheduled"), // 着工 予定日
  constructionStartDate: text("construction_start_date"), // 着工日
  constructionEndScheduled: text("construction_end_scheduled"), // 完工 予定日
  constructionEndDate: text("construction_end_date"), // 完工日
  externalLineWorkDate: text("external_line_work_date"), // 外線 工事日
  leadInWorkDate: text("lead_in_work_date"), // 引込 工事日
  interconnectionScheduled: text("interconnection_scheduled"), // 連系 予定日
  interconnectionDate: text("interconnection_date"), // 連系日

  // その他
  burdenLandOther: text("burden_land_other"), // 負担金土地 その他
  confirmationItems: text("confirmation_items"), // 確認事項
  completionMonth: text("completion_month"), // 完成月
  constructionComplete: text("construction_complete"), // 完工

  // 既存フィールド（互換性維持）
  address: text("address"), // 現地住所
  coordinates: text("coordinates"), // 座標
  landowner1: text("landowner_1"), // 地権者1
  landowner2: text("landowner_2"), // 地権者2
  landowner3: text("landowner_3"), // 地権者3
  landownerAddress1: text("landowner_address_1"), // 地権者1の住所
  landownerAddress2: text("landowner_address_2"), // 地権者2の住所
  landownerAddress3: text("landowner_address_3"), // 地権者3の住所
  inheritanceStatus1: text("inheritance_status_1"), // 相続有無1（有/無/未確認）
  inheritanceStatus2: text("inheritance_status_2"), // 相続有無2
  inheritanceStatus3: text("inheritance_status_3"), // 相続有無3
  correctionRegistration1: text("correction_registration_1"), // 更正登記有無1（有/無/未確認）
  correctionRegistration2: text("correction_registration_2"), // 更正登記有無2
  correctionRegistration3: text("correction_registration_3"), // 更正登記有無3
  mortgageStatus1: text("mortgage_status_1"), // 抵当権有無1（有/無/未確認）
  mortgageStatus2: text("mortgage_status_2"), // 抵当権有無2
  mortgageStatus3: text("mortgage_status_3"), // 抵当権有無3
  landCategory1: text("land_category_1"), // 地目1（山林・原野・畑）
  landCategory2: text("land_category_2"), // 地目2（山林・原野・畑）
  landCategory3: text("land_category_3"), // 地目3（山林・原野・畑）
  landArea1: text("land_area_1"), // 土地面積1
  landArea2: text("land_area_2"), // 土地面積2
  landArea3: text("land_area_3"), // 土地面積3
  verticalSnowLoad: text("vertical_snow_load"), // 垂直積雪量
  windSpeed: text("wind_speed"), // 風速
  dococabiLink: text("dococabi_link"), // どこキャビ連携URL

  // 法令チェック結果（JSON形式で保存）
  // 形式: { "法令名": { "status": "該当" | "非該当" | "要確認", "note": "メモ" }, ... }
  legalStatuses: text("legal_statuses"),
});

// 進捗テーブル
export const progress = sqliteTable("progress", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  projectId: integer("project_id").notNull(),
  title: text("title").notNull(),
  description: text("description"),
  status: text("status").notNull().default("planned"), // planned: 予定, completed: 完了
  createdAt: text("created_at").notNull(), // 予定日
  completedAt: text("completed_at"), // 完了日
});

// コメント（ツイート）テーブル
export const comments = sqliteTable("comments", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  projectId: integer("project_id").notNull(),
  content: text("content").notNull(),
  createdAt: text("created_at").notNull(),
  userId: integer("user_id"), // 投稿者
  userName: text("user_name"), // 投稿者名（キャッシュ用）
});

// TODOテーブル（案件ごと・期日付きリマインダー、ダッシュボード表示用）
// projectIdがnullの場合は案件に紐づかないプレーンなTODO
export const todos = sqliteTable("todos", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  projectId: integer("project_id"), // nullの場合は案件に紐づかない
  content: text("content").notNull(),
  dueDate: text("due_date").notNull(), // この日までに行う（YYYY-MM-DD）
  createdAt: text("created_at").notNull(),
  completedAt: text("completed_at"), // 完了日時（ISO文字列）
  completedMemo: text("completed_memo"), // 完了時のメモ
  userId: integer("user_id"), // 作成者
  userName: text("user_name"), // 作成者名（キャッシュ用）
});

export type Project = typeof projects.$inferSelect;
export type NewProject = typeof projects.$inferInsert;
export type Progress = typeof progress.$inferSelect;
export type NewProgress = typeof progress.$inferInsert;
export type Comment = typeof comments.$inferSelect;
export type NewComment = typeof comments.$inferInsert;
export type Todo = typeof todos.$inferSelect;
export type NewTodo = typeof todos.$inferInsert;

// 会議（議事録）テーブル
export const meetings = sqliteTable("meetings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  title: text("title").notNull(), // タイトル（どんな会議だったか）
  meetingDate: text("meeting_date").notNull(), // 日付（YYYY-MM-DD）
  category: text("category").notNull(), // 種別（社内 / 社外）
  content: text("content"), // 議事録本文（長文）
  agenda: text("agenda"), // 議題（今後検索用）
});

export type Meeting = typeof meetings.$inferSelect;
export type NewMeeting = typeof meetings.$inferInsert;

// ユーザーテーブル
export const users = sqliteTable("users", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  username: text("username").notNull().unique(), // ログインID
  name: text("name"), // 表示名
  password: text("password").notNull(), // ハッシュ化したパスワード
  role: text("role").notNull().default("user"), // user, admin
  // OAuth連携用
  lineId: text("line_id").unique(), // LINE User ID
  email: text("email"), // メールアドレス（OAuth取得用）
  image: text("image"), // プロフィール画像URL
});

export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;

// 案件ファイルテーブル（Vercel Blob Storage）
// カテゴリ: registry_copy(謄本) / cadastral_map(公図) / drawing(図面) / consent_form(同意書) / other(その他)
export const projectFiles = sqliteTable("project_files", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  projectId: integer("project_id").notNull(),
  fileName: text("file_name").notNull(), // 元のファイル名
  fileUrl: text("file_url").notNull(), // Vercel BlobのURL
  fileType: text("file_type").notNull(), // image/jpeg, application/pdf など
  fileSize: integer("file_size").notNull(), // バイト数
  category: text("category").default("other"), // registry_copy / cadastral_map / drawing / consent_form / other
  createdAt: text("created_at").notNull(),
});

export type ProjectFile = typeof projectFiles.$inferSelect;
export type NewProjectFile = typeof projectFiles.$inferInsert;

// 要望（フィードバック）テーブル
export const feedbacks = sqliteTable("feedbacks", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  content: text("content").notNull(), // 要望内容
  pagePath: text("page_path").notNull(), // どの画面から投稿されたか
  pageTitle: text("page_title"), // 画面のタイトル（表示用）
  status: text("status").notNull().default("pending"), // pending, in_progress, completed, rejected
  replies: text("replies"), // JSON形式の返信（Gitツリー形式）
  likes: integer("likes").notNull().default(0), // いいね数
  createdAt: text("created_at").notNull(),
  userId: integer("user_id"), // 投稿者ID
  userName: text("user_name"), // 投稿者名（キャッシュ用）
});

export type Feedback = typeof feedbacks.$inferSelect;
export type NewFeedback = typeof feedbacks.$inferInsert;

// 工事進捗カテゴリ（工程表の代わり）
export const CONSTRUCTION_PROGRESS_CATEGORIES = [
  "造成",
  "載荷試験",
  "杭打ち",
  "ケーブル埋設",
  "架台組立",
  "パネル設置",
  "電気工事",
  "フェンス設置",
  "その他",
] as const;

// 工事写真カテゴリ
export const CONSTRUCTION_PHOTO_CATEGORIES = [
  "着工前",
  "造成後",
  "載荷試験",
  "杭打ち",
  "ケーブル埋設",
  "架台組立",
  "パネル",
  "電気",
  "フェンス",
  "完工写真",
] as const;

// 工事進捗テーブル（工程表の代わり）
export const constructionProgress = sqliteTable("construction_progress", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  projectId: integer("project_id").notNull(),
  category: text("category").notNull(), // 造成、杭打ち、etc.
  status: text("status").notNull().default("pending"), // pending: 未着手, in_progress: 進行中, completed: 完了
  note: text("note"), // 進捗メモ
  completedAt: text("completed_at"), // 完了日時
  createdAt: text("created_at").notNull(),
  updatedAt: text("updated_at"),
});

export type ConstructionProgress = typeof constructionProgress.$inferSelect;
export type NewConstructionProgress = typeof constructionProgress.$inferInsert;

// 工事写真テーブル
export const constructionPhotos = sqliteTable("construction_photos", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  projectId: integer("project_id").notNull(),
  category: text("category").notNull(), // 着工前、造成後、etc.
  fileName: text("file_name").notNull(), // 元のファイル名
  fileUrl: text("file_url").notNull(), // Vercel BlobのURL
  fileType: text("file_type").notNull(), // image/jpeg など
  fileSize: integer("file_size").notNull(), // バイト数
  contractorName: text("contractor_name"), // 撮影した業者名
  note: text("note"), // 写真に関するメモ
  takenAt: text("taken_at"), // 撮影日時
  createdAt: text("created_at").notNull(),
});

export type ConstructionPhoto = typeof constructionPhotos.$inferSelect;
export type NewConstructionPhoto = typeof constructionPhotos.$inferInsert;

// カレンダーイベントテーブル（カスタムイベント用）
export const calendarEvents = sqliteTable("calendar_events", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  title: text("title").notNull(), // イベント名
  eventType: text("event_type").notNull().default("other"), // todo, meeting, other, etc.
  eventDate: text("event_date").notNull(), // 日付（YYYY-MM-DD）
  endDate: text("end_date"), // 終了日（任意）
  description: text("description"), // 説明・メモ
  userId: integer("user_id"), // 作成者ID
  userName: text("user_name"), // 作成者名（キャッシュ用）
  createdAt: text("created_at").notNull(),
});

export type CalendarEvent = typeof calendarEvents.$inferSelect;
export type NewCalendarEvent = typeof calendarEvents.$inferInsert;
</file>

<file path="src/db/index.ts">
import { createClient, Client } from "@libsql/client";
import { drizzle, LibSQLDatabase } from "drizzle-orm/libsql";
import * as schema from "./schema";

let client: Client | null = null;
let dbInstance: LibSQLDatabase<typeof schema> | null = null;
let initialized = false;

function getClient(): Client {
  if (!client) {
    if (!process.env.TURSO_DATABASE_URL) {
      throw new Error("TURSO_DATABASE_URL is not set");
    }
    client = createClient({
      url: process.env.TURSO_DATABASE_URL,
      authToken: process.env.TURSO_AUTH_TOKEN,
    });
  }
  return client;
}

export const db: LibSQLDatabase<typeof schema> = new Proxy({} as LibSQLDatabase<typeof schema>, {
  get(_, prop) {
    if (!dbInstance) {
      initDb(); // 背景で初期化（非同期だが、次は待たれる）
      dbInstance = drizzle(getClient(), { schema });
    }
    return (dbInstance as unknown as Record<string, unknown>)[prop as string];
  },
});

// テーブル作成（初回のみ）
async function initDb() {
  if (initialized) return;
  
  const c = getClient();
  
  await c.execute(`
    CREATE TABLE IF NOT EXISTS projects (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      management_number TEXT NOT NULL,
      manager TEXT NOT NULL,
      client TEXT NOT NULL,
      project_number TEXT NOT NULL,
      completion_month TEXT,
      address TEXT,
      coordinates TEXT,
      landowner TEXT
    )
  `);

  // カラム追加用（既存テーブルへの対応）
  try { await c.execute(`ALTER TABLE projects ADD COLUMN address TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN coordinates TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_category_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_category_2 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_category_3 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_area_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_area_2 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_area_3 TEXT`); } catch (e) {}
  // 地権者を3つに拡張（既存のlandownerカラムがある場合はlandowner_1に移行）
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner_2 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner_3 TEXT`); } catch (e) {}
  try { await c.execute(`UPDATE projects SET landowner_1 = landowner WHERE landowner IS NOT NULL AND landowner_1 IS NULL`); } catch (e) {}

  // 地権者追加情報（住所、相続有無、更正登記有無、抵当権有無）
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner_address_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner_address_2 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner_address_3 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN inheritance_status_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN inheritance_status_2 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN inheritance_status_3 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN correction_registration_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN correction_registration_2 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN correction_registration_3 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN mortgage_status_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN mortgage_status_2 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN mortgage_status_3 TEXT`); } catch (e) {}

  // 環境データ（垂直積雪量、風速）
  try { await c.execute(`ALTER TABLE projects ADD COLUMN vertical_snow_load TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN wind_speed TEXT`); } catch (e) {}

  // 外部連携（どこキャビ）
  try { await c.execute(`ALTER TABLE projects ADD COLUMN dococabi_link TEXT`); } catch (e) {}

  // ===== Excel案件表カラム追加（2026年2月） =====
  // 基本情報
  try { await c.execute(`ALTER TABLE projects ADD COLUMN availability TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN business_type TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN design_power TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN sales TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN parcel_count TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN prefecture TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN blank_1 TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN link TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN agreement_month TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN project_submission_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN project_submission_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN felling_consent_request TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN felling_consent_complete TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN site_investigation TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN level TEXT`); } catch (e) {}

  // 土地契約関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_contract_request_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_contract_request TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_contract_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_contract_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_price TEXT`); } catch (e) {}

  // 地権者情報（統合）
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN landowner_address TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_area_total TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN correction_status TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN inheritance_status TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN mortgage_status TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN hazard_at_home TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN photo TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN snowfall TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN wind_speed_value TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN neighborhood_felling TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_remarks TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_category TEXT`); } catch (e) {}

  // 農振関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nourin_status TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nourin_scrivener_request TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nourin_application_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nourin_application_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nourin_completion_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nourin_completion_date TEXT`); } catch (e) {}

  // 農転関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nouten_status TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_category_change_request TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nouten_scrivener_request TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nouten_application_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nouten_application_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nouten_completion_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN nouten_completion_date TEXT`); } catch (e) {}

  // 規制・造成関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN regulation_category TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN development_status TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN residential_dev_application_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN residential_dev_application_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN residential_dev_completion_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN residential_dev_completion_date TEXT`); } catch (e) {}

  // その他法令関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN other_regulations TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN regulation_application_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN regulation_application_payment_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN regulation_permit_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN regulation_permit_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN completion_notification TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN regulation_remarks TEXT`); } catch (e) {}

  // モジュール・システム関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN module_type TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN module_count TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN module_capacity TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN system_capacity TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_simulation TEXT`); } catch (e) {}

  // 電力関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_company TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_application_destination TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_application_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_application_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_response_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_response_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN estimated_burden TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN additional_burden TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN burden_payment_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN interconnection_status TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN interconnection_details TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN power_remarks TEXT`); } catch (e) {}

  // 土地決済関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_settlement_doc_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_settlement_doc_collection TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_settlement_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN land_settlement_date TEXT`); } catch (e) {}

  // 所有権移転登記関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ownership_transfer_app_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ownership_transfer_application TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ownership_transfer_comp_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ownership_transfer_completion TEXT`); } catch (e) {}

  // 費用関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN development_cost TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN surveying_cost TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN administrative_cost TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN other_cost_total TEXT`); } catch (e) {}

  // 近隣挨拶関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN neighbor_greeting_request_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN neighbor_greeting_request_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN neighbor_greeting_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN neighbor_greeting_date TEXT`); } catch (e) {}

  // SS関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ss_request_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ss_request_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ss_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN ss_date TEXT`); } catch (e) {}

  // 注文・発注関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN order_creation_request_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN order_creation_request TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN order_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN order_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN delivery_date TEXT`); } catch (e) {}

  // 工事関連
  try { await c.execute(`ALTER TABLE projects ADD COLUMN construction_available_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN construction_start_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN construction_start_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN construction_end_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN construction_end_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN external_line_work_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN lead_in_work_date TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN interconnection_scheduled TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN interconnection_date TEXT`); } catch (e) {}

  // その他
  try { await c.execute(`ALTER TABLE projects ADD COLUMN burden_land_other TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN confirmation_items TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE projects ADD COLUMN construction_complete TEXT`); } catch (e) {}

  // 法令チェック結果（JSON形式）
  try { await c.execute(`ALTER TABLE projects ADD COLUMN legal_statuses TEXT`); } catch (e) {}

  await c.execute(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      username TEXT NOT NULL UNIQUE,
      name TEXT,
      password TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'user'
    )
  `);

  // OAuth連携用カラム追加
  try { await c.execute(`ALTER TABLE users ADD COLUMN line_id TEXT UNIQUE`); } catch (e) {}
  try { await c.execute(`ALTER TABLE users ADD COLUMN email TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE users ADD COLUMN image TEXT`); } catch (e) {}

  await c.execute(`
    CREATE TABLE IF NOT EXISTS progress (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER NOT NULL,
      title TEXT NOT NULL,
      description TEXT,
      status TEXT NOT NULL DEFAULT 'planned',
      created_at TEXT NOT NULL,
      completed_at TEXT,
      FOREIGN KEY (project_id) REFERENCES projects(id)
    )
  `);

  await c.execute(`
    CREATE TABLE IF NOT EXISTS comments (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER NOT NULL,
      content TEXT NOT NULL,
      created_at TEXT NOT NULL,
      FOREIGN KEY (project_id) REFERENCES projects(id)
    )
  `);

  // todosテーブルのproject_idをnullableに変更するマイグレーション
  // SQLiteではALTER TABLEでNOT NULLを削除できないため、テーブルを再作成する
  try {
    // 既存のテーブルがproject_id NOT NULLかどうか確認
    const tableInfo = await c.execute(`PRAGMA table_info(todos)`);
    const projectIdColumn = tableInfo.rows.find((row: any) => row.name === 'project_id');

    if (projectIdColumn && projectIdColumn.notnull === 1) {
      // NOT NULL制約がある場合、テーブルを再作成
      await c.execute(`
        CREATE TABLE IF NOT EXISTS todos_new (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          project_id INTEGER,
          content TEXT NOT NULL,
          due_date TEXT NOT NULL,
          created_at TEXT NOT NULL,
          completed_at TEXT,
          completed_memo TEXT,
          FOREIGN KEY (project_id) REFERENCES projects(id)
        )
      `);

      // 既存データを移行
      await c.execute(`
        INSERT INTO todos_new (id, project_id, content, due_date, created_at, completed_at, completed_memo)
        SELECT id, project_id, content, due_date, created_at, completed_at, completed_memo FROM todos
      `);

      // 古いテーブルを削除
      await c.execute(`DROP TABLE todos`);

      // 新しいテーブルをリネーム
      await c.execute(`ALTER TABLE todos_new RENAME TO todos`);
    }
  } catch (e) {
    // テーブルが存在しない場合は新規作成
    await c.execute(`
      CREATE TABLE IF NOT EXISTS todos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_id INTEGER,
        content TEXT NOT NULL,
        due_date TEXT NOT NULL,
        created_at TEXT NOT NULL,
        completed_at TEXT,
        completed_memo TEXT,
        FOREIGN KEY (project_id) REFERENCES projects(id)
      )
    `);
  }
  try { await c.execute(`ALTER TABLE todos ADD COLUMN completed_at TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE todos ADD COLUMN completed_memo TEXT`); } catch (e) {}
  // アカウント機能用カラム追加
  try { await c.execute(`ALTER TABLE todos ADD COLUMN user_id INTEGER`); } catch (e) {}
  try { await c.execute(`ALTER TABLE todos ADD COLUMN user_name TEXT`); } catch (e) {}
  try { await c.execute(`ALTER TABLE comments ADD COLUMN user_id INTEGER`); } catch (e) {}
  try { await c.execute(`ALTER TABLE comments ADD COLUMN user_name TEXT`); } catch (e) {}

  await c.execute(`
    CREATE TABLE IF NOT EXISTS meetings (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      meeting_date TEXT NOT NULL,
      category TEXT NOT NULL,
      content TEXT,
      agenda TEXT
    )
  `);

  // 案件ファイルテーブル（Vercel Blob Storage）
  await c.execute(`
    CREATE TABLE IF NOT EXISTS project_files (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER NOT NULL,
      file_name TEXT NOT NULL,
      file_url TEXT NOT NULL,
      file_type TEXT NOT NULL,
      file_size INTEGER NOT NULL,
      created_at TEXT NOT NULL,
      FOREIGN KEY (project_id) REFERENCES projects(id)
    )
  `);
  // カテゴリカラム追加（registry_copy/cadastral_map/drawing/consent_form/other）
  try { await c.execute(`ALTER TABLE project_files ADD COLUMN category TEXT DEFAULT 'other'`); } catch (e) {}

  // 要望（フィードバック）テーブル
  await c.execute(`
    CREATE TABLE IF NOT EXISTS feedbacks (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      content TEXT NOT NULL,
      page_path TEXT NOT NULL,
      page_title TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      replies TEXT,
      likes INTEGER NOT NULL DEFAULT 0,
      created_at TEXT NOT NULL
    )
  `);
  // フィードバック投稿者情報カラム追加
  try { await c.execute(`ALTER TABLE feedbacks ADD COLUMN user_id INTEGER`); } catch (e) {}
  try { await c.execute(`ALTER TABLE feedbacks ADD COLUMN user_name TEXT`); } catch (e) {}


  // 工事進捗テーブル（工程表の代わり）
  await c.execute(`
    CREATE TABLE IF NOT EXISTS construction_progress (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER NOT NULL,
      category TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'pending',
      note TEXT,
      completed_at TEXT,
      created_at TEXT NOT NULL,
      updated_at TEXT,
      FOREIGN KEY (project_id) REFERENCES projects(id)
    )
  `);

  // 工事写真テーブル
  await c.execute(`
    CREATE TABLE IF NOT EXISTS construction_photos (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER NOT NULL,
      category TEXT NOT NULL,
      file_name TEXT NOT NULL,
      file_url TEXT NOT NULL,
      file_type TEXT NOT NULL,
      file_size INTEGER NOT NULL,
      contractor_name TEXT,
      note TEXT,
      taken_at TEXT,
      created_at TEXT NOT NULL,
      FOREIGN KEY (project_id) REFERENCES projects(id)
    )
  `);

  // カレンダーイベントテーブル（カスタムイベント用）
  await c.execute(`
    CREATE TABLE IF NOT EXISTS calendar_events (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      event_type TEXT NOT NULL DEFAULT 'other',
      event_date TEXT NOT NULL,
      end_date TEXT,
      description TEXT,
      user_id INTEGER,
      user_name TEXT,
      created_at TEXT NOT NULL
    )
  `);

  // 古い名前を新しい名前に統一（重複データのクリーンアップ）
  // 「現地調査」→「現調」、「農転・地目申請」→「法令申請」、「連系（発電開始）」→「連系」
  const legacyTitleMigrations = [
    { oldTitle: "現地調査", newTitle: "現調" },
    { oldTitle: "農転・地目申請", newTitle: "法令申請" },
    { oldTitle: "連系（発電開始）", newTitle: "連系" },
  ];

  for (const { oldTitle, newTitle } of legacyTitleMigrations) {
    // 新しい名前が既に存在するプロジェクトから古い名前のレコードを削除
    try {
      await c.execute(`
        DELETE FROM progress 
        WHERE title = ? 
        AND project_id IN (
          SELECT DISTINCT project_id FROM progress WHERE title = ?
        )
      `, [oldTitle, newTitle]);
    } catch (e) {}

    // 残りの古い名前を新しい名前に変更
    try {
      await c.execute(`UPDATE progress SET title = ? WHERE title = ?`, [newTitle, oldTitle]);
    } catch (e) {}
  }
  
  initialized = true;
}

// 初期化関数をエクスポート
export { initDb };
</file>

<file path="src/app/projects/[id]/page.tsx">
"use client";

import { useEffect, useState, useMemo, useRef } from "react";
import { useParams } from "next/navigation";
import Link from "next/link";
import { ArrowLeft, Plus, Check, Circle, Calendar as CalendarIcon, Clock, Pencil, Trash2, MessageCircle, Send, ExternalLink, Copy, Scale, CheckCircle2, XCircle, Loader2, ListTodo, HardHat, Camera, Upload, Image as ImageIcon } from "lucide-react";
import { formatDateJp } from "@/lib/timeline";
import { cn, parseTodoMessages, addTodoMessage } from "@/lib/utils";
import {
  parseCoordinateString,
  normalizeCoordinateString,
} from "@/lib/coordinates";
import { parsePrefectureAndCity } from "@/lib/address";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import type { Project, Progress, Comment, Todo, ProjectFile, ConstructionProgress, ConstructionPhoto } from "@/db/schema";
import { CONSTRUCTION_PROGRESS_CATEGORIES, CONSTRUCTION_PHOTO_CATEGORIES } from "@/db/schema";
import { ProjectFiles } from "@/components/ProjectFiles";
import { Card, CardContent } from "@/components/ui/card";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { LawAlertCard } from "@/components/LawAlertCard";
import { ContactDeptAlertCard } from "@/components/ContactDeptAlertCard";

const PROGRESS_TITLES = [
  "合意書",
  "案件提出",
  "現調",
  "土地売買契約",
  "土地契約",
  "法令申請",
  "法令許可",
  "電力申請",
  "電力回答",
  "SS依頼",
  "SS実施",
  "土地決済",
  "発注",
  "着工",
  "連系",
  "完工",
] as const;

// 法令検索タブ用の型と定数（GeoSearchViewから再利用）
interface JudgmentResult {
  宅地造成等工事規制区域: boolean;
  特定盛土等規制区域: boolean;
}

const TEMPLATES = {
  宅地造成等工事規制区域: "宅地造成規制区域。造成の規模によっては許可申請が必要。現調結果次第で判断いたします。",
  特定盛土等規制区域: "特定盛土規制区域。造成の規模によっては届出 / 許可申請が必要。現調結果次第で判断いたします。",
};

// 土壌汚染対策法・福山市要措置区域等の対象地区（現地住所がこれらのいずれかを含む場合にアラート表示）
const FUKUYAMA_SOIL_TARGET_DISTRICTS = [
  "瀬戸町",
  "加茂町",
  "鋼管町",
  "柳津町",
  "緑町",
  "三吉町",
  "松浜町",
] as const;
const FUKUYAMA_SOIL_DETAIL_URL =
  "https://www.city.fukuyama.hiroshima.jp/site/kankyo/335122.html";

// 鳥獣の保護及び管理並びに狩猟の適正化に関する法律：赤アラート表示対象（広島県内）
const HIROSHIMA_BIRD_PROTECTION_AREAS = [
  "庄原市口和町",
  "東広島市志和町",
  "福山市走島町",
  "福山市赤坂町",
  "福山市沼隈町",
  "福山市千田町",
  "三原市",
] as const;
const HIROSHIMA_BIRD_PROTECTION_URL =
  "https://www.pref.hiroshima.lg.jp/site/huntinglicense/hunter-map.html";

function isHiroshimaBirdProtectionArea(address: string | null): boolean {
  if (!address || !address.includes("広島県")) return false;
  return HIROSHIMA_BIRD_PROTECTION_AREAS.some((area) => address.includes(area));
}

// 担当部署にお問い合わせのアラートを表示し、検索クエリに「担当部署」を追加する法律（河川法・急傾斜地・砂防・地すべり・森林法）
const CONTACT_DEPT_LAW_IDS = [3, 6, 7, 8, 12] as const;
const CONTACT_DEPT_MESSAGE = "担当部署にお問い合わせください";

function isFukuyamaSoilTargetArea(address: string | null): boolean {
  if (!address || !address.includes("福山市")) return false;
  return FUKUYAMA_SOIL_TARGET_DISTRICTS.some((d) => address.includes(d));
}

interface AdditionalButton {
  label: string;
  url: string;
}

interface LawSearchCardProps {
  lawName: string;
  onSearch: (lawName: string, lawId?: number) => void;
  lawId?: number;
  fixedText?: string;
  copiedText: string | null;
  onCopy: (text: string) => void;
  prefecture?: string;
  additionalButtons?: AdditionalButton[];
  badges?: string[];
  caption?: string;
  /** ただし書き（コピーアイコンなしで表示） */
  note?: string;
  /** 地目に農地（田・畑）が含まれる場合の小さなアラート表示 */
  farmlandAlert?: boolean;
  /** 現在のステータス */
  currentStatus?: LegalStatus;
  /** ステータス変更時のコールバック */
  onStatusChange?: (status: LegalStatus) => void;
  /** ステータス削除時のコールバック */
  onStatusRemove?: () => void;
}

const LawSearchCard: React.FC<LawSearchCardProps> = ({
  lawName,
  onSearch,
  lawId,
  fixedText,
  copiedText,
  onCopy,
  prefecture,
  additionalButtons = [],
  badges = [],
  caption,
  note,
  farmlandAlert,
  currentStatus,
  onStatusChange,
  onStatusRemove,
}) => {
  return (
    <div className={cn(
      "bg-card rounded-4xl border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500",
      currentStatus === "該当" && "border-red-300 dark:border-red-700 bg-red-50/50 dark:bg-red-950/20",
      currentStatus === "要確認" && "border-amber-300 dark:border-amber-700 bg-amber-50/50 dark:bg-amber-950/20",
      currentStatus === "非該当" && "border-green-300 dark:border-green-700 bg-green-50/50 dark:bg-green-950/20",
      !currentStatus && "border-border"
    )}>
      <div className="flex items-start justify-between gap-4">
        <div className="flex-1">
          <div className="flex items-center gap-2">
            <p className="font-medium text-foreground">{lawName}</p>
            {currentStatus && (
              <span className={cn(
                "inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium",
                currentStatus === "該当" && "bg-red-100 text-red-800 dark:bg-red-900/40 dark:text-red-200",
                currentStatus === "要確認" && "bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200",
                currentStatus === "非該当" && "bg-green-100 text-green-800 dark:bg-green-900/40 dark:text-green-200"
              )}>
                {currentStatus}
              </span>
            )}
          </div>
          {farmlandAlert && (
            <p className="text-xs text-amber-700 dark:text-amber-400 mt-2 px-2.5 py-1.5 rounded-lg bg-amber-50 dark:bg-amber-950/40 border border-amber-200 dark:border-amber-800">
              地目に農地が含まれています
            </p>
          )}
          {caption && (
            <p className="text-sm text-muted-foreground mt-2">{caption}</p>
          )}
          {fixedText && (
            <div className="flex items-start gap-2 mt-3 p-3 rounded-xl bg-muted/50 border border-border">
              <p className="flex-1 text-sm text-foreground leading-relaxed">{fixedText}</p>
              <button
                onClick={() => onCopy(fixedText)}
                className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                title="コピー"
              >
                {copiedText === fixedText ? (
                  <Check className="w-4 h-4 text-green-500" />
                ) : (
                  <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                )}
              </button>
            </div>
          )}
          {note && (
            <p className="text-xs text-muted-foreground mt-2">{note}</p>
          )}
          {badges.length > 0 && (
            <div className="flex flex-wrap gap-2 mt-3">
              {badges.map((badge, index) => (
                <span
                  key={index}
                  className="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-primary/10 text-primary border border-primary/20"
                >
                  {badge}
                </span>
              ))}
            </div>
          )}
          {/* ステータス選択ボタン */}
          {onStatusChange && (
            <div className="flex flex-wrap items-center gap-2 mt-4 pt-3 border-t border-border/50">
              <span className="text-xs text-muted-foreground mr-1">判定:</span>
              <button
                onClick={() => onStatusChange("該当")}
                className={cn(
                  "px-3 py-1 rounded-full text-xs font-medium border transition-colors",
                  currentStatus === "該当"
                    ? "bg-red-500 text-white border-red-500"
                    : "bg-transparent text-red-600 border-red-300 hover:bg-red-100 dark:text-red-400 dark:border-red-700 dark:hover:bg-red-900/30"
                )}
              >
                該当
              </button>
              <button
                onClick={() => onStatusChange("要確認")}
                className={cn(
                  "px-3 py-1 rounded-full text-xs font-medium border transition-colors",
                  currentStatus === "要確認"
                    ? "bg-amber-500 text-white border-amber-500"
                    : "bg-transparent text-amber-600 border-amber-300 hover:bg-amber-100 dark:text-amber-400 dark:border-amber-700 dark:hover:bg-amber-900/30"
                )}
              >
                要確認
              </button>
              <button
                onClick={() => onStatusChange("非該当")}
                className={cn(
                  "px-3 py-1 rounded-full text-xs font-medium border transition-colors",
                  currentStatus === "非該当"
                    ? "bg-green-500 text-white border-green-500"
                    : "bg-transparent text-green-600 border-green-300 hover:bg-green-100 dark:text-green-400 dark:border-green-700 dark:hover:bg-green-900/30"
                )}
              >
                非該当
              </button>
              {currentStatus && onStatusRemove && (
                <button
                  onClick={onStatusRemove}
                  className="ml-1 text-xs text-muted-foreground hover:text-foreground"
                  title="判定を解除"
                >
                  ×
                </button>
              )}
            </div>
          )}
        </div>
        <div className="flex flex-col gap-2 shrink-0">
          <Button onClick={() => onSearch(lawName, lawId)} size="sm">
            Googleで検索
          </Button>
          {additionalButtons.map((button, index) => (
            <Button
              key={index}
              variant="outline"
              size="sm"
              onClick={() => window.open(button.url, '_blank')}
            >
              <ExternalLink className="h-3 w-3 mr-2" />
              {button.label}
            </Button>
          ))}
        </div>
      </div>
    </div>
  );
};

interface Law {
  id: number;
  name: string;
  fixedText?: string;
}

const laws: Law[] = [
  { id: 1, name: "国土利用計画法" },
  { id: 2, name: "都市計画法" },
  { id: 3, name: "河川法" },
  { id: 4, name: "港湾法" },
  { id: 5, name: "海岸法" },
  { id: 6, name: "急傾斜地の崩壊による災害の防止に関する法律" },
  { id: 7, name: "砂防法" },
  { id: 8, name: "地すべり等防止法" },
  { id: 9, name: "景観法" },
  { id: 10, name: "農業振興地域の整備に関する法律" },
  { id: 11, name: "農地法" },
  { id: 12, name: "森林法" },
  { id: 13, name: "文化財保護法" },
  { id: 14, name: "土壌汚染対策法" },
  { id: 15, name: "自然公園法" },
  { id: 16, name: "自然環境保全法" },
  { id: 17, name: "絶滅の恐れがある野生動植物の種の保存に関する法律" },
  { id: 18, name: "鳥獣の保護及び管理並びに狩猟の適正化に関する法律" },
  { id: 19, name: "環境影響評価法・条例" },
  { id: 20, name: "消防法", fixedText: "低圧の為、消防署への届出が必要な機器設置なく、該当しません。" },
  { id: 21, name: "振動規制法", fixedText: "特定施設を設置しないため、該当しません。" },
  { id: 22, name: "道路法", fixedText: "工事区域に道路が無い為、道路使用許可が占用許可の必要な行為は予定されていません。" },
  { id: 23, name: "廃棄物の処理及び清掃に関する法律", fixedText: "敷地内の残置物及び工事で発生した産廃物については適正に処理します。" },
];

// 法令ステータスの型
type LegalStatus = "該当" | "非該当" | "要確認";
interface LegalStatusInfo {
  status: LegalStatus;
  note?: string;
}
type LegalStatuses = Record<string, LegalStatusInfo>;

// 法令検索タブコンポーネント
interface LegalSearchTabProps {
  searchParams: { lat: string; lon: string; prefecture: string } | null;
  projectAddress: string | null;
  projectCoordinates: string | null;
  projectLandCategories?: {
    landCategory1: string | null;
    landCategory2: string | null;
    landCategory3: string | null;
  } | null;
  projectId?: number;
  initialLegalStatuses?: string | null;
  onLegalStatusesChange?: (statuses: LegalStatuses) => void;
}

function LegalSearchTab({ searchParams, projectAddress, projectCoordinates, projectLandCategories, projectId, initialLegalStatuses, onLegalStatusesChange }: LegalSearchTabProps) {
  const [coordinateInput, setCoordinateInput] = useState("");
  const [latitude, setLatitude] = useState("");
  const [longitude, setLongitude] = useState("");
  const [prefecture, setPrefecture] = useState("");
  const [result, setResult] = useState<JudgmentResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);
  const [copiedText, setCopiedText] = useState<string | null>(null);
  const [legalStatuses, setLegalStatuses] = useState<LegalStatuses>(() => {
    if (initialLegalStatuses) {
      try {
        return JSON.parse(initialLegalStatuses) as LegalStatuses;
      } catch {
        return {};
      }
    }
    return {};
  });
  const [isSaving, setIsSaving] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  // 法令ステータスを更新
  const updateLegalStatus = (lawName: string, status: LegalStatus, note?: string) => {
    setLegalStatuses(prev => {
      const updated = { ...prev, [lawName]: { status, note } };
      setHasChanges(true);
      return updated;
    });
  };

  // 法令ステータスを削除
  const removeLegalStatus = (lawName: string) => {
    setLegalStatuses(prev => {
      const updated = { ...prev };
      delete updated[lawName];
      setHasChanges(true);
      return updated;
    });
  };

  // 法令ステータスを保存
  const saveLegalStatuses = async () => {
    if (!projectId) return;
    setIsSaving(true);
    try {
      const response = await fetch(`/api/projects/${projectId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ legalStatuses: JSON.stringify(legalStatuses) }),
      });
      if (response.ok) {
        setHasChanges(false);
        onLegalStatusesChange?.(legalStatuses);
      } else {
        alert("保存に失敗しました");
      }
    } catch (error) {
      console.error("保存エラー:", error);
      alert("保存に失敗しました");
    } finally {
      setIsSaving(false);
    }
  };

  // 座標入力を解析（カンマ・スラッシュ・空白区切りに対応）し、有効なら正規化表示
  const handleCoordinateInput = (value: string) => {
    setCoordinateInput(value);
    const parsed = parseCoordinateString(value);
    if (parsed) {
      setLatitude(parsed.lat);
      setLongitude(parsed.lon);
      setCoordinateInput(normalizeCoordinateString(value));
    } else {
      setLatitude("");
      setLongitude("");
    }
  };

  // 検索実行（逆ジオコーディングは削除）
  const runSearch = async (lat: number, lon: number, pref: string) => {
    setHasSearched(true);
    setResult(null);
    setIsLoading(true);

    try {
      const response = await fetch("https://geo-checker-backend-aj4j.onrender.com/api/v1/check", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ latitude: lat, longitude: lon, prefecture: pref }),
      });
      const data: JudgmentResult = await response.json();
      setResult(data);
    } catch (error) {
      console.error("判定エラー:", error);
      alert("判定に失敗しました。もう一度お試しください。");
    } finally {
      setIsLoading(false);
    }
  };

  // フォームからの検索実行
  const handleSearch = () => {
    if (!latitude || !longitude || !prefecture) return;
    runSearch(parseFloat(latitude), parseFloat(longitude), prefecture);
  };

  // searchParamsが設定されたら自動検索
  useEffect(() => {
    if (!searchParams) return;
    const lat = parseFloat(searchParams.lat);
    const lon = parseFloat(searchParams.lon);
    if (isNaN(lat) || isNaN(lon)) return;
    runSearch(lat, lon, searchParams.prefecture);
  }, [searchParams]);

  const handleCopy = async (text: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedText(text);
      setTimeout(() => setCopiedText(null), 2000);
    } catch (error) {
      console.error("コピーに失敗しました:", error);
    }
  };

  const handleGoogleSearch = (lawName: string, lawId?: number) => {
    const currentPrefecture = searchParams?.prefecture || prefecture;
    const { prefectureName: addrPrefecture, cityName } = parsePrefectureAndCity(projectAddress);
    const prefectureName =
      addrPrefecture ||
      (currentPrefecture === "hiroshima" ? "広島県" : currentPrefecture === "okayama" ? "岡山県" : "");
    const parts = [prefectureName, cityName, lawName];
    if (lawId != null && CONTACT_DEPT_LAW_IDS.includes(lawId as (typeof CONTACT_DEPT_LAW_IDS)[number])) {
      parts.push("担当部署");
    }
    const keyword = parts.filter(Boolean).join(" ");
    const encodedKeyword = encodeURIComponent(keyword);
    const searchUrl = `https://www.google.com/search?q=${encodedKeyword}`;
    window.open(searchUrl, "_blank");
  };

  // 座標から緯度・経度を取得
  const getCoordinates = () => {
    if (searchParams) {
      return { lat: searchParams.lat, lon: searchParams.lon };
    }
    if (projectCoordinates) {
      const parsed = parseCoordinateString(projectCoordinates);
      if (parsed) return parsed;
    }
    if (latitude && longitude) {
      return { lat: latitude, lon: longitude };
    }
    return null;
  };

  const coordinates = getCoordinates();

  const getMappleUrl = () => {
    if (!coordinates) return null;
    const lat = coordinates.lat.trim();
    const lng = coordinates.lon.trim();
    if (!lat || !lng || isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) return null;
    return `https://labs.mapple.com/mapplexml.html#16/${lat}/${lng}`;
  };

  // searchParamsがnullの場合はフォームを表示
  if (!searchParams) {
    const currentPrefecture = prefecture;
    const currentLat = latitude;
    const currentLon = longitude;
    const isOkayama = currentPrefecture === "okayama";
    const isHiroshima = currentPrefecture === "hiroshima";

    return (
      <div className="space-y-6">
        {/* 検索フォーム */}
        <div className="bg-card rounded-4xl border border-border shadow-lg p-8 space-y-6">
          {/* 座標入力（カンマ区切り） */}
          <div className="space-y-2">
            <label htmlFor="coordinate" className="text-sm font-medium text-foreground">
              座標（緯度,経度 または 緯度/経度）
            </label>
            <Input
              id="coordinate"
              type="text"
              placeholder="例: 34.580590,133.457655 または 34.58/133.45"
              value={coordinateInput}
              onChange={(e) => handleCoordinateInput(e.target.value)}
              className="w-full"
            />
            <p className="text-xs text-muted-foreground">
              緯度と経度をカンマまたはスラッシュ区切りで入力してください
            </p>
          </div>

          {/* 都道府県選択 */}
          <div className="space-y-2">
            <label htmlFor="prefecture" className="text-sm font-medium text-foreground">
              都道府県
            </label>
            <Select value={prefecture} onValueChange={setPrefecture}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="都道府県を選択してください" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="hiroshima">広島県</SelectItem>
                <SelectItem value="okayama">岡山県</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* 検索ボタン */}
          <div className="pt-2">
            <Button
              onClick={handleSearch}
              size="lg"
              className="w-full"
              disabled={!latitude || !longitude || !prefecture || isLoading}
            >
              {isLoading ? "検索中..." : "検索"}
            </Button>
          </div>
        </div>

        {/* 現地住所・現地座標（画面上部に固定表示） */}
        {(projectAddress || projectCoordinates) && (
          <div className="sticky top-0 z-10 bg-background pt-1 -mt-1 pb-4 space-y-4 border-b border-border/50 shadow-sm">
            {projectAddress && (
              <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
                <h2 className="text-xl font-semibold text-foreground mb-4">現地住所</h2>
                <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                  <p className="flex-1 text-sm text-foreground leading-relaxed">
                    {projectAddress}
                  </p>
                  <button
                    onClick={() => handleCopy(projectAddress)}
                    className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                    title="コピー"
                  >
                    {copiedText === projectAddress ? (
                      <Check className="w-4 h-4 text-green-500" />
                    ) : (
                      <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                    )}
                  </button>
                </div>
              </div>
            )}

            {projectCoordinates && (
              <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
                <h2 className="text-xl font-semibold text-foreground mb-4">現地座標</h2>
                <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                  <p className="flex-1 text-sm text-foreground leading-relaxed">
                    {projectCoordinates}
                  </p>
                  <button
                    onClick={() => handleCopy(projectCoordinates)}
                    className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                    title="コピー"
                  >
                    {copiedText === projectCoordinates ? (
                      <Check className="w-4 h-4 text-green-500" />
                    ) : (
                      <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                    )}
                  </button>
                </div>
                {coordinates && (
                  <div className="flex flex-wrap gap-2">
                    {getMappleUrl() && (
                      <Button variant="outline" size="sm" asChild className="h-9">
                        <a
                          href={getMappleUrl() ?? ""}
                          target="_blank"
                          rel="noopener noreferrer"
                        >
                          <ExternalLink className="h-3 w-3 mr-2" />
                          MAPPLE
                        </a>
                      </Button>
                    )}
                    <Button
                      onClick={() => window.open(
                        `https://www.google.com/maps?q=${coordinates.lat},${coordinates.lon}`,
                        '_blank'
                      )}
                      className="flex-1"
                    >
                      Google Mapで確認
                    </Button>
                    {currentPrefecture === "okayama" && (
                      <Button
                        onClick={() => window.open('https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7', '_blank')}
                        className="flex-1"
                      >
                        おかやま全県統合型GIS
                      </Button>
                    )}
                  </div>
                )}
              </div>
            )}
          </div>
        )}

        {/* 法律検索カード一覧 */}
        {hasSearched && laws.map((law) => {
          let additionalButtons: AdditionalButton[] = [];
          let badges: string[] = [];
          let caption: string | undefined;
          let fixedTextWithCopy = law.fixedText;
          let noteForCard: string | undefined;
          let showFarmlandAlert = false;

          if (law.id === 1 && isOkayama) {
            additionalButtons.push({
              label: "おかやま全県統合型GIS",
              url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
            });
          }
          if (law.id === 1 && isHiroshima && projectAddress?.includes("広島市")) {
            additionalButtons.push({
              label: "ひろしま地図ナビ",
              url: "https://www2.wagmap.jp/hiroshimacity/Portal?mid=4"
            });
          }

          if (law.id === 4) {
            fixedTextWithCopy = "対象地区ではありません。";
          }

          if (law.id === 5) {
            fixedTextWithCopy = "対象地区ではありません。";
          }
          if (law.id === 4) {
            noteForCard = "港湾区域に関する法規制です。港湾区域の開発でない場合は該当しません。";
          }
          if (law.id === 5) {
            noteForCard = "海岸保全区域に関する法規制です。海岸保全区域の開発でない場合は該当しません。";
          }

          if (law.id === 9 && isOkayama && !projectAddress?.includes("井原市")) {
            caption = "岡山県は全域が景観区域です。届出対象行為はこちらで確認してください。";
          }
          if (law.id === 9) {
            const { cityName: landscapeCityName } = parsePrefectureAndCity(projectAddress ?? null);
            if (landscapeCityName) {
              const landscapeButtonUrl = isOkayama
                ? "https://www.pref.okayama.jp/uploaded/attachment/325065.pdf"
                : "https://www.city.fukuyama.hiroshima.jp/uploaded/attachment/130060.pdf";
              additionalButtons.push({
                label: `${landscapeCityName}の届出対象行為`,
                url: landscapeButtonUrl
              });
            }
          }
          if (law.id === 9) {
            fixedTextWithCopy = "要件に該当しないため、届出不要です。";
            noteForCard = "開発面積や工作物の高さが一般的な要件です。各都道府県の法令を確認してください。";
          }

          if (law.id === 13 && isOkayama) {
            additionalButtons.push({
              label: "おかやま全県統合型GIS",
              url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
            });
          }
          if (law.id === 13 && isHiroshima) {
            additionalButtons.push({
              label: "広島県埋蔵文化財地図",
              url: "https://www.pref.hiroshima.lg.jp/site/bunkazai/bunkazai-map-map.html"
            });
          }
          if (law.id === 13) {
            noteForCard = "地図で確認してください。";
          }

          if (law.id === 15 && isOkayama) {
            additionalButtons.push({
              label: "おかやま全県統合型GIS",
              url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
            });
          }
          if (law.id === 15 && isHiroshima) {
            additionalButtons.push({
              label: "広島県の自然公園",
              url: "https://www.pref.hiroshima.lg.jp/soshiki/47/kouikisei.html"
            });
          }
          if (law.id === 15) {
            fixedTextWithCopy = "対象地区ではありません。";
            noteForCard = "自然公園区域に関する法規制です。自然公園内の開発でない場合は該当しません。";
          }

          if (law.id === 16 && isOkayama) {
            additionalButtons.push({
              label: "自然環境保全地域",
              url: "https://www.pref.okayama.jp/page/573469.html"
            });
          }
          if (law.id === 16 && isHiroshima) {
            additionalButtons.push({
              label: "広島県の保全地域一覧",
              url: "https://www.pref.hiroshima.lg.jp/site/hiroshima-shizenkankyouhozen/"
            });
            fixedTextWithCopy = "対象地区ではありません。";
          }

          if (law.id === 17) {
            // 中国四国地方の県かどうか判定
            const chushikokuPrefectures = ["岡山県", "広島県", "山口県", "鳥取県", "島根県", "香川県", "愛媛県", "徳島県", "高知県"];
            const { prefectureName: speciesPrefecture } = parsePrefectureAndCity(projectAddress);
            const isChushikoku = speciesPrefecture && chushikokuPrefectures.includes(speciesPrefecture);

            if (isChushikoku) {
              fixedTextWithCopy = "中国四国地方環境事務所管内には、種の保存法に基づき指定された生息地等保護区はありません。";
              additionalButtons.push({
                label: "参照リンク",
                url: "https://chushikoku.env.go.jp/procure/page_00068.html"
              });
            } else {
              fixedTextWithCopy = "対象地区ではありません。";
            }
            additionalButtons.push({
              label: "生息地等保護区",
              url: "https://www.env.go.jp/nature/kisho/hogoku/list.html"
            });
          }

          if (law.id === 18 && projectAddress && isHiroshimaBirdProtectionArea(projectAddress)) {
            return (
              <LawAlertCard
                key={law.id}
                title={law.name}
                message="鳥獣保護区に該当する可能性があります"
                detailUrl={HIROSHIMA_BIRD_PROTECTION_URL}
                variant="red"
              />
            );
          }
          if (law.id === 18 && isOkayama) {
            additionalButtons.push({
              label: "鳥獣保護区等位置図",
              url: "https://www.pref.okayama.jp/uploaded/life/1011233_9758897_misc.pdf"
            });
          }
          if (law.id === 18 && isHiroshima) {
            additionalButtons.push({
              label: "広島県の鳥獣保護区",
              url: HIROSHIMA_BIRD_PROTECTION_URL
            });
          }
          if (law.id === 18) {
            fixedTextWithCopy = "対象地区ではありません。";
            noteForCard = "鳥獣保護区に関する法規制です。";
          }

          if (law.id === 19 && isHiroshima) {
            fixedTextWithCopy = "対象の面積要件は○○ha以上のため、今回は該当しません。";
            noteForCard = "上記は例文です。各都道府県の条例に沿って記入してください。";
            const { prefectureName: assessmentPrefecture } = parsePrefectureAndCity(projectAddress ?? null);
            additionalButtons.push({
              label: `${assessmentPrefecture || "広島県"}の対象事業`,
              url: "https://www.pref.hiroshima.lg.jp/site/eco/h-h2-assessment-panhu-03.html"
            });
          }
          if (law.id === 19 && isOkayama) {
            fixedTextWithCopy = "対象の面積要件は20ha以上のため、今回は該当しません。";
            noteForCard = "上記は例文です。各都道府県の条例に沿って記入してください。";
            const { prefectureName: assessmentPrefecture } = parsePrefectureAndCity(projectAddress ?? null);
            additionalButtons.push({
              label: `${assessmentPrefecture || "岡山県"}の対象事業`,
              url: "https://www.pref.okayama.jp/uploaded/life/1005026_9692062_misc.pdf"
            });
          }

          if (law.id === 14 && projectAddress && isFukuyamaSoilTargetArea(projectAddress)) {
            return (
              <LawAlertCard
                key={law.id}
                title="土壌汚染対策法"
                message="土壌汚染対策法の対象区域の可能性があります。"
                detailUrl={FUKUYAMA_SOIL_DETAIL_URL}
              />
            );
          }
          if (CONTACT_DEPT_LAW_IDS.includes(law.id as (typeof CONTACT_DEPT_LAW_IDS)[number])) {
            return (
              <ContactDeptAlertCard
                key={law.id}
                title={law.name}
                message={CONTACT_DEPT_MESSAGE}
                onSearch={handleGoogleSearch}
                lawName={law.name}
                lawId={law.id}
              />
            );
          }
          if (law.id === 14) {
            fixedTextWithCopy = "対象地区ではありません。";
          }
          if (law.id === 10 || law.id === 11) {
            const isOkayamaNonFarmlandArea =
              projectAddress?.includes("井原市") ||
              projectAddress?.includes("笠岡市") ||
              projectAddress?.includes("矢掛");
            if (isOkayamaNonFarmlandArea) {
              fixedTextWithCopy = "非農地認定済みのため不要。地目変更登記を行います。";
              caption = "井原・笠岡・矢掛の場合は非農地リストがあるので、農地であっても手続きが地目変更のみになります。";
            } else {
              const cats = [
                projectLandCategories?.landCategory1 ?? null,
                projectLandCategories?.landCategory2 ?? null,
                projectLandCategories?.landCategory3 ?? null,
              ].filter((c): c is string => !!c);
              const hasFarmland = cats.some((c) => c === "田" || c === "畑");
              if (cats.length > 0 && hasFarmland) {
                showFarmlandAlert = true;
              }
              if (cats.length > 0 && !hasFarmland) {
                fixedTextWithCopy = "農地ではないため該当しません。";
                noteForCard = "地目が正しく登録されていることを確認してください";
              }
            }
          }

          return (
            <LawSearchCard
              key={law.id}
              lawName={law.name}
              lawId={law.id}
              onSearch={handleGoogleSearch}
              fixedText={fixedTextWithCopy}
              copiedText={copiedText}
              onCopy={handleCopy}
              prefecture={currentPrefecture}
              additionalButtons={additionalButtons}
              badges={badges}
              caption={caption}
              note={noteForCard}
              farmlandAlert={showFarmlandAlert}
              currentStatus={legalStatuses[law.name]?.status}
              onStatusChange={(status) => updateLegalStatus(law.name, status)}
              onStatusRemove={() => removeLegalStatus(law.name)}
            />
          );
        })}

        {/* ○○県の太陽光に関する条例 */}
        {hasSearched && currentPrefecture && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">
              {currentPrefecture === "hiroshima" ? "広島県" : currentPrefecture === "okayama" ? "岡山県" : ""}の太陽光に関する条例
            </h2>
            <div className="flex items-center justify-between">
              <div className="flex-1">
                <p className="font-medium text-foreground">
                  {currentPrefecture === "hiroshima" ? "広島県" : currentPrefecture === "okayama" ? "岡山県" : ""}の太陽光発電に関する条例を検索
                </p>
              </div>
              <Button
                onClick={() => {
                  const prefName = currentPrefecture === "hiroshima" ? "広島県" : currentPrefecture === "okayama" ? "岡山県" : "";
                  const query = encodeURIComponent(`${prefName}　太陽光　条例`);
                  window.open(`https://www.google.com/search?q=${query}`, "_blank");
                }}
                className="shrink-0 ml-4"
              >
                Googleで検索
              </Button>
            </div>
          </div>
        )}

        {/* 都道府県条例カード（岡山県） */}
        {hasSearched && currentPrefecture === "okayama" && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">都道府県条例</h2>
            <div className="flex items-center justify-between">
              <div className="flex-1">
                <p className="font-medium text-foreground">岡山県太陽光発電施設の安全な導入を促進する条例</p>
              </div>
              <Button
                onClick={() => window.open("https://www.pref.okayama.jp/page/619095.html", "_blank")}
                className="shrink-0 ml-4"
              >
                Googleで検索
              </Button>
            </div>
          </div>
        )}

        {/* 市区町村条例カード（井原市） */}
        {hasSearched && projectAddress?.includes("井原市") && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">市区町村条例</h2>
            <div className="flex items-center justify-between">
              <div className="flex-1">
                <p className="font-medium text-foreground">井原市開発事業の調整に関する条例</p>
              </div>
              <Button
                onClick={() => window.open("https://www.city.ibara.okayama.jp/soshiki/3/1214.html", "_blank")}
                className="shrink-0 ml-4"
              >
                Googleで検索
              </Button>
            </div>
          </div>
        )}

        {/* 判定結果表示 */}
        {hasSearched && (
          <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <h2 className="text-xl font-semibold text-foreground mb-4">判定結果</h2>
            
            {isLoading ? (
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Loader2 className="h-4 w-4 animate-spin" />
                判定中...
              </div>
            ) : result ? (
              <>
                <div className="space-y-3">
                  <div className="flex items-center justify-between p-4 rounded-2xl bg-muted/50 border border-border">
                    <div className="flex-1">
                      <p className="font-medium text-foreground">宅地造成等工事規制区域</p>
                    </div>
                    <div className="flex items-center gap-2">
                      {result.宅地造成等工事規制区域 ? (
                        <>
                          <CheckCircle2 className="w-6 h-6 text-green-500" />
                          <span className="font-semibold text-green-500">該当します</span>
                        </>
                      ) : (
                        <>
                          <XCircle className="w-6 h-6 text-red-500" />
                          <span className="font-semibold text-muted-foreground">該当しません</span>
                        </>
                      )}
                    </div>
                  </div>
                  
                  {result.宅地造成等工事規制区域 && (
                    <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                      <p className="flex-1 text-sm text-foreground leading-relaxed">
                        {TEMPLATES.宅地造成等工事規制区域}
                      </p>
                      <button
                        onClick={() => handleCopy(TEMPLATES.宅地造成等工事規制区域)}
                        className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                        title="コピー"
                      >
                        {copiedText === TEMPLATES.宅地造成等工事規制区域 ? (
                          <Check className="w-4 h-4 text-green-500" />
                        ) : (
                          <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                        )}
                      </button>
                    </div>
                  )}
                </div>

                <div className="space-y-3">
                  {isHiroshima && (
                    <div className="rounded-2xl border-2 border-amber-400 bg-amber-50 dark:bg-amber-950/50 dark:border-amber-600 p-4">
                      <p className="text-sm font-semibold text-amber-800 dark:text-amber-200">
                        広島県は未対応です
                      </p>
                      <p className="text-xs text-amber-700 dark:text-amber-300 mt-1">
                        特定盛土等規制区域の判定は広島県では提供しておりません。
                      </p>
                    </div>
                  )}
                  <div className="flex items-center justify-between p-4 rounded-2xl bg-muted/50 border border-border">
                    <div className="flex-1">
                      <p className="font-medium text-foreground">特定盛土等規制区域</p>
                    </div>
                    <div className="flex items-center gap-2">
                      {result.特定盛土等規制区域 ? (
                        <>
                          <CheckCircle2 className="w-6 h-6 text-green-500" />
                          <span className="font-semibold text-green-500">該当します</span>
                        </>
                      ) : (
                        <>
                          <XCircle className="w-6 h-6 text-red-500" />
                          <span className="font-semibold text-muted-foreground">該当しません</span>
                        </>
                      )}
                    </div>
                  </div>
                  
                  {result.特定盛土等規制区域 && (
                    <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                      <p className="flex-1 text-sm text-foreground leading-relaxed">
                        {TEMPLATES.特定盛土等規制区域}
                      </p>
                      <button
                        onClick={() => handleCopy(TEMPLATES.特定盛土等規制区域)}
                        className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                        title="コピー"
                      >
                        {copiedText === TEMPLATES.特定盛土等規制区域 ? (
                          <Check className="w-4 h-4 text-green-500" />
                        ) : (
                          <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                        )}
                      </button>
                    </div>
                  )}
                </div>

                <div className="pt-2 border-t border-border mt-4">
                  <p className="text-sm text-muted-foreground">
                    判定座標: {projectAddress && `${projectAddress}, `}緯度 {currentLat}, 経度 {currentLon}
                  </p>
                </div>
              </>
            ) : (
              <div className="text-sm text-muted-foreground">
                判定結果がありません
              </div>
            )}
          </div>
        )}
      </div>
    );
  }

  const currentPrefecture = searchParams.prefecture;
  const isOkayama = currentPrefecture === "okayama";
  const isHiroshima = currentPrefecture === "hiroshima";

  // 座標から緯度・経度を取得（searchParams時）
  const getCoordinatesForSearchParams = () => {
    if (searchParams) {
      return { lat: searchParams.lat, lon: searchParams.lon };
    }
    if (projectCoordinates) {
      const parsed = parseCoordinateString(projectCoordinates);
      if (parsed) return parsed;
    }
    return null;
  };

  const coordinatesForSearchParams = getCoordinatesForSearchParams();

  const getMappleUrlForSearchParams = () => {
    if (!coordinatesForSearchParams) return null;
    const lat = coordinatesForSearchParams.lat.trim();
    const lng = coordinatesForSearchParams.lon.trim();
    if (!lat || !lng || isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) return null;
    return `https://labs.mapple.com/mapplexml.html#16/${lat}/${lng}`;
  };

  return (
    <div className="space-y-6">
      {/* 現地住所・現地座標（画面上部に固定表示） */}
      {(projectAddress || projectCoordinates) && (
        <div className="sticky top-0 z-10 bg-background pt-1 -mt-1 pb-4 space-y-4 border-b border-border/50 shadow-sm">
          {projectAddress && (
            <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
              <h2 className="text-xl font-semibold text-foreground mb-4">現地住所</h2>
              <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                <p className="flex-1 text-sm text-foreground leading-relaxed">
                  {projectAddress}
                </p>
                <button
                  onClick={() => handleCopy(projectAddress)}
                  className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                  title="コピー"
                >
                  {copiedText === projectAddress ? (
                    <Check className="w-4 h-4 text-green-500" />
                  ) : (
                    <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                  )}
                </button>
              </div>
            </div>
          )}

          {projectCoordinates && (
            <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
              <h2 className="text-xl font-semibold text-foreground mb-4">現地座標</h2>
              <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                <p className="flex-1 text-sm text-foreground leading-relaxed">
                  {projectCoordinates}
                </p>
                <button
                  onClick={() => handleCopy(projectCoordinates)}
                  className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                  title="コピー"
                >
                  {copiedText === projectCoordinates ? (
                    <Check className="w-4 h-4 text-green-500" />
                  ) : (
                    <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                  )}
                </button>
              </div>
              {coordinatesForSearchParams && (
                <div className="flex flex-wrap gap-2">
                  {getMappleUrlForSearchParams() && (
                    <Button variant="outline" size="sm" asChild className="h-9">
                      <a
                        href={getMappleUrlForSearchParams() ?? ""}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <ExternalLink className="h-3 w-3 mr-2" />
                        MAPPLE
                      </a>
                    </Button>
                  )}
                  {coordinatesForSearchParams && (
                    <Button
                      onClick={() => window.open(
                        `https://www.google.com/maps?q=${coordinatesForSearchParams.lat},${coordinatesForSearchParams.lon}`,
                        '_blank'
                      )}
                      className="flex-1"
                    >
                      Google Mapで確認
                    </Button>
                  )}
                  {currentPrefecture === "okayama" && (
                    <Button
                      onClick={() => window.open('https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7', '_blank')}
                      className="flex-1"
                    >
                      おかやま全県統合型GIS
                    </Button>
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      )}

      {/* 法律検索カード一覧 */}
      {hasSearched && laws.map((law) => {
        let additionalButtons: AdditionalButton[] = [];
        let badges: string[] = [];
        let caption: string | undefined;
        let fixedTextWithCopy = law.fixedText;
        let noteForCard: string | undefined;
        let showFarmlandAlert = false;

        if (law.id === 1 && isOkayama) {
          additionalButtons.push({
            label: "おかやま全県統合型GIS",
            url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
          });
        }
        if (law.id === 1 && isHiroshima && projectAddress?.includes("広島市")) {
          additionalButtons.push({
            label: "ひろしま地図ナビ",
            url: "https://www2.wagmap.jp/hiroshimacity/Portal?mid=4"
          });
        }

        if (law.id === 4) {
          fixedTextWithCopy = "対象地区ではありません。";
        }

        if (law.id === 5) {
          fixedTextWithCopy = "対象地区ではありません。";
        }
        if (law.id === 4) {
          noteForCard = "港湾区域に関する法規制です。港湾区域の開発でない場合は該当しません。";
        }
        if (law.id === 5) {
          noteForCard = "海岸保全区域に関する法規制です。海岸保全区域の開発でない場合は該当しません。";
        }

        if (law.id === 9 && isOkayama && !projectAddress?.includes("井原市")) {
          caption = "岡山県は全域が景観区域です。届出対象行為はこちらで確認してください。";
        }
        if (law.id === 9) {
          const { cityName: landscapeCityName } = parsePrefectureAndCity(projectAddress ?? null);
          if (landscapeCityName) {
            const landscapeButtonUrl = isOkayama
              ? "https://www.pref.okayama.jp/uploaded/attachment/325065.pdf"
              : "https://www.city.fukuyama.hiroshima.jp/uploaded/attachment/130060.pdf";
            additionalButtons.push({
              label: `${landscapeCityName}の届出対象行為`,
              url: landscapeButtonUrl
            });
          }
        }
        if (law.id === 9) {
          fixedTextWithCopy = "要件に該当しないため、届出不要です。";
          noteForCard = "開発面積や工作物の高さが一般的な要件です。各都道府県の法令を確認してください。";
        }

        if (law.id === 13 && isOkayama) {
          additionalButtons.push({
            label: "おかやま全県統合型GIS",
            url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
          });
        }
        if (law.id === 13 && isHiroshima) {
          additionalButtons.push({
            label: "広島県埋蔵文化財地図",
            url: "https://www.pref.hiroshima.lg.jp/site/bunkazai/bunkazai-map-map.html"
          });
        }
        if (law.id === 13) {
          noteForCard = "地図で確認してください。";
        }

        if (law.id === 15 && isOkayama) {
          additionalButtons.push({
            label: "おかやま全県統合型GIS",
            url: "https://www.gis.pref.okayama.jp/pref-okayama/PositionSelect?mid=7"
          });
        }
        if (law.id === 15 && isHiroshima) {
          additionalButtons.push({
            label: "自然公園の位置図",
            url: "https://www.pref.hiroshima.lg.jp/soshiki/47/kouikisei.html"
          });
        }
        if (law.id === 15) {
          fixedTextWithCopy = "対象地区ではありません。";
          noteForCard = "自然公園区域に関する法規制です。自然公園内の開発でない場合は該当しません。";
        }

        if (law.id === 16 && isOkayama) {
          additionalButtons.push({
            label: "自然環境保全地域",
            url: "https://www.pref.okayama.jp/page/573469.html"
          });
        }
        if (law.id === 16 && isHiroshima) {
          additionalButtons.push({
            label: "広島県の保全地域一覧",
            url: "https://www.pref.hiroshima.lg.jp/site/hiroshima-shizenkankyouhozen/"
          });
          fixedTextWithCopy = "対象地区ではありません。";
        }

        if (law.id === 17) {
          // 中国四国地方の県かどうか判定
          const chushikokuPrefectures = ["岡山県", "広島県", "山口県", "鳥取県", "島根県", "香川県", "愛媛県", "徳島県", "高知県"];
          const { prefectureName: speciesPrefecture } = parsePrefectureAndCity(projectAddress);
          const isChushikoku = speciesPrefecture && chushikokuPrefectures.includes(speciesPrefecture);

          if (isChushikoku) {
            fixedTextWithCopy = "中国四国地方環境事務所管内には、種の保存法に基づき指定された生息地等保護区はありません。";
            additionalButtons.push({
              label: "参照リンク",
              url: "https://chushikoku.env.go.jp/procure/page_00068.html"
            });
          } else {
            fixedTextWithCopy = "対象地区ではありません。";
          }
          additionalButtons.push({
            label: "生息地等保護区",
            url: "https://www.env.go.jp/nature/kisho/hogoku/list.html"
          });
        }

        if (law.id === 18 && projectAddress && isHiroshimaBirdProtectionArea(projectAddress)) {
          return (
            <LawAlertCard
              key={law.id}
              title={law.name}
              message="鳥獣保護区に該当する可能性があります"
              detailUrl={HIROSHIMA_BIRD_PROTECTION_URL}
              variant="red"
            />
          );
        }
        if (law.id === 18 && isOkayama) {
          additionalButtons.push({
            label: "鳥獣保護区等位置図",
            url: "https://www.pref.okayama.jp/uploaded/life/1011233_9758897_misc.pdf"
          });
        }
        if (law.id === 18 && isHiroshima) {
          additionalButtons.push({
            label: "広島県の鳥獣保護区",
            url: HIROSHIMA_BIRD_PROTECTION_URL
          });
        }
        if (law.id === 18) {
          fixedTextWithCopy = "対象地区ではありません。";
          noteForCard = "鳥獣保護区に関する法規制です。";
        }

        if (law.id === 19 && isHiroshima) {
          fixedTextWithCopy = "対象の面積要件は○○ha以上のため、今回は該当しません。";
          noteForCard = "上記は例文です。各都道府県の条例に沿って記入してください。";
          const { prefectureName: assessmentPrefecture } = parsePrefectureAndCity(projectAddress ?? null);
          additionalButtons.push({
            label: `${assessmentPrefecture || "広島県"}の対象事業`,
            url: "https://www.pref.hiroshima.lg.jp/site/eco/h-h2-assessment-panhu-03.html"
          });
        }
        if (law.id === 19 && isOkayama) {
          fixedTextWithCopy = "対象の面積要件は20ha以上のため、今回は該当しません。";
          noteForCard = "上記は例文です。各都道府県の条例に沿って記入してください。";
          const { prefectureName: assessmentPrefecture } = parsePrefectureAndCity(projectAddress ?? null);
          additionalButtons.push({
            label: `${assessmentPrefecture || "岡山県"}の対象事業`,
            url: "https://www.pref.okayama.jp/uploaded/life/1005026_9692062_misc.pdf"
          });
        }

        if (law.id === 14 && projectAddress && isFukuyamaSoilTargetArea(projectAddress)) {
          return (
            <LawAlertCard
              key={law.id}
              title="土壌汚染対策法"
              message="土壌汚染対策法の対象区域の可能性があります。"
              detailUrl={FUKUYAMA_SOIL_DETAIL_URL}
            />
          );
        }
        if (CONTACT_DEPT_LAW_IDS.includes(law.id as (typeof CONTACT_DEPT_LAW_IDS)[number])) {
          return (
            <ContactDeptAlertCard
              key={law.id}
              title={law.name}
              message={CONTACT_DEPT_MESSAGE}
              onSearch={handleGoogleSearch}
              lawName={law.name}
              lawId={law.id}
            />
          );
        }
        if (law.id === 14) {
          fixedTextWithCopy = "対象地区ではありません。";
        }
        if (law.id === 10 || law.id === 11) {
          const isOkayamaNonFarmlandArea =
            projectAddress?.includes("井原市") ||
            projectAddress?.includes("笠岡市") ||
            projectAddress?.includes("矢掛");
          if (isOkayamaNonFarmlandArea) {
            fixedTextWithCopy = "非農地認定済みのため不要。地目変更登記を行います。";
            caption = "井原・笠岡・矢掛の場合は非農地リストがあるので、農地であっても手続きが地目変更のみになります。";
          } else {
            const cats = [
              projectLandCategories?.landCategory1 ?? null,
              projectLandCategories?.landCategory2 ?? null,
              projectLandCategories?.landCategory3 ?? null,
            ].filter((c): c is string => !!c);
            const hasFarmland = cats.some((c) => c === "田" || c === "畑");
            if (cats.length > 0 && hasFarmland) {
              showFarmlandAlert = true;
            }
            if (cats.length > 0 && !hasFarmland) {
              fixedTextWithCopy = "農地ではないため該当しません。";
              noteForCard = "地目が正しく登録されていることを確認してください";
            }
          }
        }

        return (
          <LawSearchCard
            key={law.id}
            lawName={law.name}
            lawId={law.id}
            onSearch={handleGoogleSearch}
            fixedText={fixedTextWithCopy}
            copiedText={copiedText}
            onCopy={handleCopy}
            prefecture={currentPrefecture}
            additionalButtons={additionalButtons}
            badges={badges}
            caption={caption}
            note={noteForCard}
            farmlandAlert={showFarmlandAlert}
            currentStatus={legalStatuses[law.name]?.status}
            onStatusChange={(status) => updateLegalStatus(law.name, status)}
            onStatusRemove={() => removeLegalStatus(law.name)}
          />
        );
      })}

      {/* ○○県の太陽光に関する条例 */}
      {hasSearched && currentPrefecture && (
        <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
          <h2 className="text-xl font-semibold text-foreground mb-4">
            {currentPrefecture === "hiroshima" ? "広島県" : currentPrefecture === "okayama" ? "岡山県" : ""}の太陽光に関する条例
          </h2>
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <p className="font-medium text-foreground">
                {currentPrefecture === "hiroshima" ? "広島県" : currentPrefecture === "okayama" ? "岡山県" : ""}の太陽光発電に関する条例を検索
              </p>
            </div>
            <Button
              onClick={() => {
                const prefName = currentPrefecture === "hiroshima" ? "広島県" : currentPrefecture === "okayama" ? "岡山県" : "";
                const query = encodeURIComponent(`${prefName}　太陽光　条例`);
                window.open(`https://www.google.com/search?q=${query}`, "_blank");
              }}
              className="shrink-0 ml-4"
            >
              Googleで検索
            </Button>
          </div>
        </div>
      )}

      {/* 都道府県条例カード（岡山県） */}
      {hasSearched && currentPrefecture === "okayama" && (
        <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
          <h2 className="text-xl font-semibold text-foreground mb-4">都道府県条例</h2>
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <p className="font-medium text-foreground">岡山県太陽光発電施設の安全な導入を促進する条例</p>
            </div>
            <Button
              onClick={() => window.open("https://www.pref.okayama.jp/page/619095.html", "_blank")}
              className="shrink-0 ml-4"
            >
              Googleで検索
            </Button>
          </div>
        </div>
      )}

      {/* 市区町村条例カード（井原市） */}
      {hasSearched && projectAddress?.includes("井原市") && (
        <div className="bg-card rounded-4xl border border-border shadow-lg p-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
          <h2 className="text-xl font-semibold text-foreground mb-4">市区町村条例</h2>
          <div className="flex items-center justify-between">
            <div className="flex-1">
              <p className="font-medium text-foreground">井原市開発事業の調整に関する条例</p>
            </div>
            <Button
              onClick={() => window.open("https://www.city.ibara.okayama.jp/soshiki/3/1214.html", "_blank")}
              className="shrink-0 ml-4"
            >
              Googleで検索
            </Button>
          </div>
        </div>
      )}

      {/* 判定結果表示 */}
      {hasSearched && (
        <div className="bg-card rounded-4xl border border-border shadow-lg p-6 space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
          <h2 className="text-xl font-semibold text-foreground mb-4">判定結果</h2>
          
          {isLoading ? (
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              判定中...
            </div>
          ) : result ? (
            <>
              <div className="space-y-3">
                <div className="flex items-center justify-between p-4 rounded-2xl bg-muted/50 border border-border">
                  <div className="flex-1">
                    <p className="font-medium text-foreground">宅地造成等工事規制区域</p>
                  </div>
                  <div className="flex items-center gap-2">
                    {result.宅地造成等工事規制区域 ? (
                      <>
                        <CheckCircle2 className="w-6 h-6 text-green-500" />
                        <span className="font-semibold text-green-500">該当します</span>
                      </>
                    ) : (
                      <>
                        <XCircle className="w-6 h-6 text-red-500" />
                        <span className="font-semibold text-muted-foreground">該当しません</span>
                      </>
                    )}
                  </div>
                </div>
                
                {result.宅地造成等工事規制区域 && (
                  <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                    <p className="flex-1 text-sm text-foreground leading-relaxed">
                      {TEMPLATES.宅地造成等工事規制区域}
                    </p>
                    <button
                      onClick={() => handleCopy(TEMPLATES.宅地造成等工事規制区域)}
                      className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                      title="コピー"
                    >
                      {copiedText === TEMPLATES.宅地造成等工事規制区域 ? (
                        <Check className="w-4 h-4 text-green-500" />
                      ) : (
                        <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                      )}
                    </button>
                  </div>
                )}
              </div>

              <div className="space-y-3">
                {isHiroshima && (
                  <div className="rounded-2xl border-2 border-amber-400 bg-amber-50 dark:bg-amber-950/50 dark:border-amber-600 p-4">
                    <p className="text-sm font-semibold text-amber-800 dark:text-amber-200">
                      広島県は未対応です
                    </p>
                    <p className="text-xs text-amber-700 dark:text-amber-300 mt-1">
                      特定盛土等規制区域の判定は広島県では提供しておりません。
                    </p>
                  </div>
                )}
                <div className="flex items-center justify-between p-4 rounded-2xl bg-muted/50 border border-border">
                  <div className="flex-1">
                    <p className="font-medium text-foreground">特定盛土等規制区域</p>
                  </div>
                  <div className="flex items-center gap-2">
                    {result.特定盛土等規制区域 ? (
                      <>
                        <CheckCircle2 className="w-6 h-6 text-green-500" />
                        <span className="font-semibold text-green-500">該当します</span>
                      </>
                    ) : (
                      <>
                        <XCircle className="w-6 h-6 text-red-500" />
                        <span className="font-semibold text-muted-foreground">該当しません</span>
                      </>
                    )}
                  </div>
                </div>
                
                {result.特定盛土等規制区域 && (
                  <div className="flex items-start gap-2 p-4 rounded-2xl bg-muted/50 border border-border">
                    <p className="flex-1 text-sm text-foreground leading-relaxed">
                      {TEMPLATES.特定盛土等規制区域}
                    </p>
                    <button
                      onClick={() => handleCopy(TEMPLATES.特定盛土等規制区域)}
                      className="shrink-0 p-2 rounded-lg hover:bg-accent transition-colors"
                      title="コピー"
                    >
                      {copiedText === TEMPLATES.特定盛土等規制区域 ? (
                        <Check className="w-4 h-4 text-green-500" />
                      ) : (
                        <Copy className="w-4 h-4 text-muted-foreground hover:text-foreground" />
                      )}
                    </button>
                  </div>
                )}
              </div>

              {coordinatesForSearchParams && (
                <div className="pt-2 border-t border-border mt-4">
                  <p className="text-sm text-muted-foreground">
                    判定座標: {projectAddress && `${projectAddress}, `}緯度 {coordinatesForSearchParams.lat}, 経度 {coordinatesForSearchParams.lon}
                  </p>
                </div>
              )}
            </>
          ) : (
            <div className="text-sm text-muted-foreground">
              判定結果がありません
            </div>
          )}
        </div>
      )}

      {/* 法令ステータス保存ボタン */}
      {projectId && Object.keys(legalStatuses).length > 0 && (
        <div className="sticky bottom-4 flex justify-center">
          <Button
            onClick={saveLegalStatuses}
            disabled={isSaving || !hasChanges}
            size="lg"
            className={cn(
              "shadow-lg px-8",
              hasChanges && "animate-pulse"
            )}
          >
            {isSaving ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin mr-2" />
                保存中...
              </>
            ) : hasChanges ? (
              "法令判定を保存"
            ) : (
              <><Check className="h-4 w-4 mr-2" />保存済み</>
            )}
          </Button>
        </div>
      )}
    </div>
  );
}

function formatYyyyMd(date: Date | undefined) {
  if (!date) return "";
  const y = date.getFullYear();
  const m = date.getMonth() + 1;
  const d = date.getDate();
  return `${y}.${m}.${d}`;
}

export default function ProjectDetailPage() {
  const params = useParams();
  const id = params.id as string;

  const [project, setProject] = useState<Project | null>(null);
  const [progressList, setProgressList] = useState<Progress[]>([]);
  const [comments, setComments] = useState<Comment[]>([]);
  const [todos, setTodos] = useState<Todo[]>([]);
  const [files, setFiles] = useState<ProjectFile[]>([]);
  const [newTodoContent, setNewTodoContent] = useState("");
  const [newTodoDueDate, setNewTodoDueDate] = useState<string>("");
  const [newTodoCalendarOpen, setNewTodoCalendarOpen] = useState(false);
  const [newTodoSelectedDate, setNewTodoSelectedDate] = useState<Date | undefined>(undefined);
  const [todoEditOpen, setTodoEditOpen] = useState(false);
  const [editingTodo, setEditingTodo] = useState<Todo | null>(null);
  const [editTodoContent, setEditTodoContent] = useState("");
  const [editTodoDueDate, setEditTodoDueDate] = useState("");
  const [editTodoCalendarOpen, setEditTodoCalendarOpen] = useState(false);
  const [editTodoSelectedDate, setEditTodoSelectedDate] = useState<Date | undefined>(undefined);
  const [todoCompleteOpen, setTodoCompleteOpen] = useState(false);
  const [completingTodo, setCompletingTodo] = useState<Todo | null>(null);
  const [completeTodoMemo, setCompleteTodoMemo] = useState("");
  const [todoAddMessageOpen, setTodoAddMessageOpen] = useState(false);
  const [addingMessageTodo, setAddingMessageTodo] = useState<Todo | null>(null);
  const [newTodoMessage, setNewTodoMessage] = useState("");
  const [todoDeleteOpen, setTodoDeleteOpen] = useState(false);
  const [deletingTodo, setDeletingTodo] = useState<Todo | null>(null);
  const [activeTab, setActiveTab] = useState("details");
  const [legalSearchParams, setLegalSearchParams] = useState<{ lat: string; lon: string; prefecture: string } | null>(null);
  // 工事タブ用state
  const [constructionProgressList, setConstructionProgressList] = useState<ConstructionProgress[]>([]);
  const [constructionPhotos, setConstructionPhotos] = useState<ConstructionPhoto[]>([]);
  const [isLoadingConstruction, setIsLoadingConstruction] = useState(false);
  const [uploadingPhoto, setUploadingPhoto] = useState(false);
  const [photoUploadCategory, setPhotoUploadCategory] = useState<string>("");
  const [photoContractorName, setPhotoContractorName] = useState("");
  const [photoNote, setPhotoNote] = useState("");
  // 工事タブ用 datepicker state
  const [constructionAvailableDateOpen, setConstructionAvailableDateOpen] = useState(false);
  const [deliveryDateOpen, setDeliveryDateOpen] = useState(false);
  const [constructionStartScheduledOpen, setConstructionStartScheduledOpen] = useState(false);
  const [constructionStartDateOpen, setConstructionStartDateOpen] = useState(false);
  const [constructionEndScheduledOpen, setConstructionEndScheduledOpen] = useState(false);
  const [constructionEndDateOpen, setConstructionEndDateOpen] = useState(false);
  const photoInputRef = useRef<HTMLInputElement>(null);
  const [newComment, setNewComment] = useState("");
  const [editingComment, setEditingComment] = useState<Comment | null>(null);
  const [editCommentContent, setEditCommentContent] = useState("");
  const [commentEditOpen, setCommentEditOpen] = useState(false);
  const [commentDeleteOpen, setCommentDeleteOpen] = useState(false);
  const [deletingComment, setDeletingComment] = useState<Comment | null>(null);
  const [copiedField, setCopiedField] = useState<string | null>(null);
  const [detailEditOpen, setDetailEditOpen] = useState(false);
  const [detailForm, setDetailForm] = useState({
    address: "",
    coordinates: "",
    landowner1: "",
    landowner2: "",
    landowner3: "",
    // 地権者追加情報
    landownerAddress1: "",
    landownerAddress2: "",
    landownerAddress3: "",
    inheritanceStatus1: "",
    inheritanceStatus2: "",
    inheritanceStatus3: "",
    correctionRegistration1: "",
    correctionRegistration2: "",
    correctionRegistration3: "",
    mortgageStatus1: "",
    mortgageStatus2: "",
    mortgageStatus3: "",
    // 地目・面積
    landCategory1: "",
    landCategory2: "",
    landCategory3: "",
    landArea1: "",
    landArea2: "",
    landArea3: "",
    // 環境データ
    verticalSnowLoad: "",
    windSpeed: "",
    // 外部連携
    dococabiLink: "",
  });
  const [open, setOpen] = useState(false);
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const [form, setForm] = useState<{
    title: string;
    description: string;
    date: Date | undefined;
    status: "planned" | "completed";
  }>({
    title: "",
    description: "",
    date: undefined,
    status: "planned",
  });
  const [dateText, setDateText] = useState("");

  // 編集用の状態
  const [editOpen, setEditOpen] = useState(false);
  const [editCalendarOpen, setEditCalendarOpen] = useState(false);
  const [editingProgress, setEditingProgress] = useState<Progress | null>(null);
  const [editForm, setEditForm] = useState<{
    title: string;
    description: string;
    date: Date | undefined;
    completedAt: Date | undefined;
    status: "planned" | "completed";
  }>({
    title: "",
    description: "",
    date: undefined,
    completedAt: undefined,
    status: "planned",
  });
  const [editCompletedDateText, setEditCompletedDateText] = useState("");
  const [editCompletedCalendarOpen, setEditCompletedCalendarOpen] = useState(false);
  const [editDateText, setEditDateText] = useState("");

  const fetchProject = () => {
    fetch(`/api/projects/${id}`)
      .then((res) => res.json())
      .then(setProject);
  };

  const fetchProgress = () => {
    fetch(`/api/projects/${id}/progress`)
      .then((res) => res.json())
      .then(setProgressList);
  };

  const fetchComments = () => {
    fetch(`/api/projects/${id}/comments`)
      .then((res) => res.json())
      .then(setComments);
  };

  const fetchTodos = () => {
    fetch(`/api/projects/${id}/todos`)
      .then((res) => res.json())
      .then(setTodos);
  };

  // 工事進捗・写真取得
  const fetchConstructionData = async () => {
    setIsLoadingConstruction(true);
    try {
      const [progressRes, photosRes] = await Promise.all([
        fetch(`/api/projects/${id}/construction-progress`),
        fetch(`/api/projects/${id}/construction-photos`),
      ]);
      const progressData = await progressRes.json();
      const photosData = await photosRes.json();
      setConstructionProgressList(Array.isArray(progressData) ? progressData : []);
      setConstructionPhotos(Array.isArray(photosData) ? photosData : []);
    } catch (error) {
      console.error("Failed to fetch construction data:", error);
    } finally {
      setIsLoadingConstruction(false);
    }
  };

  const fetchFiles = () => {
    fetch(`/api/projects/${id}/files`)
      .then((res) => res.json())
      .then(setFiles);
  };

  const handleDetailUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!project) return;
    await fetch(`/api/projects/${id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        ...project,
        address: detailForm.address,
        coordinates: normalizeCoordinateString(detailForm.coordinates) || detailForm.coordinates,
        landowner1: detailForm.landowner1,
        landowner2: detailForm.landowner2,
        landowner3: detailForm.landowner3,
        // 地権者追加情報
        landownerAddress1: detailForm.landownerAddress1,
        landownerAddress2: detailForm.landownerAddress2,
        landownerAddress3: detailForm.landownerAddress3,
        inheritanceStatus1: detailForm.inheritanceStatus1,
        inheritanceStatus2: detailForm.inheritanceStatus2,
        inheritanceStatus3: detailForm.inheritanceStatus3,
        correctionRegistration1: detailForm.correctionRegistration1,
        correctionRegistration2: detailForm.correctionRegistration2,
        correctionRegistration3: detailForm.correctionRegistration3,
        mortgageStatus1: detailForm.mortgageStatus1,
        mortgageStatus2: detailForm.mortgageStatus2,
        mortgageStatus3: detailForm.mortgageStatus3,
        // 地目・面積
        landCategory1: detailForm.landCategory1,
        landCategory2: detailForm.landCategory2,
        landCategory3: detailForm.landCategory3,
        landArea1: detailForm.landArea1,
        landArea2: detailForm.landArea2,
        landArea3: detailForm.landArea3,
        // 環境データ
        verticalSnowLoad: detailForm.verticalSnowLoad,
        windSpeed: detailForm.windSpeed,
        // 外部連携
        dococabiLink: detailForm.dococabiLink,
      }),
    });
    setDetailEditOpen(false);
    fetchProject();
  };

  const openDetailEditDialog = () => {
    if (!project) return;
    setDetailForm({
      address: project.address ?? "",
      coordinates: project.coordinates ?? "",
      landowner1: project.landowner1 ?? "",
      landowner2: project.landowner2 ?? "",
      landowner3: project.landowner3 ?? "",
      // 地権者追加情報
      landownerAddress1: project.landownerAddress1 ?? "",
      landownerAddress2: project.landownerAddress2 ?? "",
      landownerAddress3: project.landownerAddress3 ?? "",
      inheritanceStatus1: project.inheritanceStatus1 ?? "",
      inheritanceStatus2: project.inheritanceStatus2 ?? "",
      inheritanceStatus3: project.inheritanceStatus3 ?? "",
      correctionRegistration1: project.correctionRegistration1 ?? "",
      correctionRegistration2: project.correctionRegistration2 ?? "",
      correctionRegistration3: project.correctionRegistration3 ?? "",
      mortgageStatus1: project.mortgageStatus1 ?? "",
      mortgageStatus2: project.mortgageStatus2 ?? "",
      mortgageStatus3: project.mortgageStatus3 ?? "",
      // 地目・面積
      landCategory1: project.landCategory1 ?? "",
      landCategory2: project.landCategory2 ?? "",
      landCategory3: project.landCategory3 ?? "",
      landArea1: project.landArea1 ?? "",
      landArea2: project.landArea2 ?? "",
      landArea3: project.landArea3 ?? "",
      // 環境データ
      verticalSnowLoad: project.verticalSnowLoad ?? "",
      windSpeed: project.windSpeed ?? "",
      // 外部連携
      dococabiLink: project.dococabiLink ?? "",
    });
    setDetailEditOpen(true);
  };

  // 土地面積の合計を計算
  const calculateTotalArea = (area1: string, area2: string, area3: string) => {
    const num1 = parseFloat(area1) || 0;
    const num2 = parseFloat(area2) || 0;
    const num3 = parseFloat(area3) || 0;
    return num1 + num2 + num3;
  };

  // クリップボードにコピーする汎用関数
  const copyToClipboard = async (text: string, fieldName: string) => {
    if (!text) return;
    await navigator.clipboard.writeText(text);
    setCopiedField(fieldName);
    setTimeout(() => setCopiedField(null), 2000);
  };

  // 座標をクリップボードにコピー
  const copyCoordinates = async () => {
    if (!project?.coordinates) return;
    await copyToClipboard(project.coordinates, "coordinates");
  };

  // 合計値をクリップボードにコピー
  const copyTotalArea = async () => {
    if (!project) return;
    const total = calculateTotalArea(
      project.landArea1 ?? "",
      project.landArea2 ?? "",
      project.landArea3 ?? ""
    );
    await copyToClipboard(total.toString(), "totalArea");
  };

  // 住所をコピー
  const copyAddress = async () => {
    if (!project?.address) return;
    await copyToClipboard(project.address, "address");
  };

  // 地権者をコピー
  const copyLandowners = async () => {
    if (!project) return;
    const landowners = [project.landowner1, project.landowner2, project.landowner3]
      .filter(Boolean)
      .join("\n");
    if (landowners) {
      await copyToClipboard(landowners, "landowners");
    }
  };

  const handleCommentSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim()) return;
    await fetch(`/api/projects/${id}/comments`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ content: newComment }),
    });
    setNewComment("");
    fetchComments();
  };

  const openCommentEditDialog = (comment: Comment) => {
    setEditingComment(comment);
    setEditCommentContent(comment.content);
    setCommentEditOpen(true);
  };

  const handleCommentEditSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editingComment || !editCommentContent.trim()) return;
    await fetch(`/api/projects/${id}/comments`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        commentId: editingComment.id,
        content: editCommentContent,
      }),
    });
    setCommentEditOpen(false);
    setEditingComment(null);
    fetchComments();
  };

  const openCommentDeleteDialog = (comment: Comment) => {
    setDeletingComment(comment);
    setCommentDeleteOpen(true);
  };

  const handleCommentDelete = async () => {
    if (!deletingComment) return;
    await fetch(`/api/projects/${id}/comments?commentId=${deletingComment.id}`, {
      method: "DELETE",
    });
    setCommentDeleteOpen(false);
    setDeletingComment(null);
    fetchComments();
  };

  // 工事進捗更新
  const handleConstructionProgressUpdate = async (category: string, status: string, note?: string) => {
    try {
      await fetch(`/api/projects/${id}/construction-progress`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ category, status, note }),
      });
      fetchConstructionData();
    } catch (error) {
      console.error("Failed to update construction progress:", error);
    }
  };

  // 工事写真アップロード
  const handlePhotoUpload = async (file: File) => {
    if (!photoUploadCategory) {
      alert("写真カテゴリを選択してください");
      return;
    }
    setUploadingPhoto(true);
    try {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("category", photoUploadCategory);
      if (photoContractorName) formData.append("contractorName", photoContractorName);
      if (photoNote) formData.append("note", photoNote);

      const res = await fetch(`/api/projects/${id}/construction-photos`, {
        method: "POST",
        body: formData,
      });

      if (!res.ok) {
        const error = await res.json();
        alert(error.error || "アップロードに失敗しました");
        return;
      }

      // 成功後リセット
      setPhotoUploadCategory("");
      setPhotoContractorName("");
      setPhotoNote("");
      if (photoInputRef.current) photoInputRef.current.value = "";
      fetchConstructionData();
    } catch (error) {
      console.error("Failed to upload photo:", error);
      alert("アップロードに失敗しました");
    } finally {
      setUploadingPhoto(false);
    }
  };

  // 工事写真削除
  const handlePhotoDelete = async (photoId: number) => {
    if (!confirm("この写真を削除しますか？")) return;
    try {
      await fetch(`/api/projects/${id}/construction-photos/${photoId}`, {
        method: "DELETE",
      });
      fetchConstructionData();
    } catch (error) {
      console.error("Failed to delete photo:", error);
    }
  };

  const handleTodoSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newTodoContent.trim() || !newTodoDueDate) return;
    await fetch(`/api/projects/${id}/todos`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ content: newTodoContent.trim(), dueDate: newTodoDueDate }),
    });
    setNewTodoContent("");
    setNewTodoDueDate("");
    setNewTodoSelectedDate(undefined);
    fetchTodos();
  };

  const handleTodoDelete = async (todoId: number) => {
    await fetch(`/api/todos/${todoId}`, { method: "DELETE" });
    fetchTodos();
  };

  const openTodoDeleteDialog = (todo: Todo) => {
    setDeletingTodo(todo);
    setTodoDeleteOpen(true);
  };

  const openTodoEditDialog = (todo: Todo) => {
    setEditingTodo(todo);
    setEditTodoContent(todo.content);
    setEditTodoDueDate(todo.dueDate);
    setEditTodoSelectedDate(new Date(todo.dueDate + "T00:00:00"));
    setTodoEditOpen(true);
  };

  const handleTodoEditSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editingTodo || !editTodoContent.trim() || !editTodoDueDate) return;
    await fetch(`/api/todos/${editingTodo.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ content: editTodoContent.trim(), dueDate: editTodoDueDate }),
    });
    setTodoEditOpen(false);
    setEditingTodo(null);
    fetchTodos();
  };

  const openTodoCompleteDialog = (todo: Todo) => {
    setCompletingTodo(todo);
    setCompleteTodoMemo("");
    setTodoCompleteOpen(true);
  };

  const handleTodoCompleteSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!completingTodo) return;
    // 完了メモがある場合は配列形式で保存
    const completedMemo = completeTodoMemo.trim()
      ? addTodoMessage(null, completeTodoMemo.trim())
      : null;
    await fetch(`/api/todos/${completingTodo.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        completedAt: new Date().toISOString(),
        completedMemo,
      }),
    });
    setTodoCompleteOpen(false);
    setCompletingTodo(null);
    setCompleteTodoMemo("");
    fetchTodos();
  };

  const handleTodoReopen = async (todo: Todo) => {
    // 再開時はメッセージを保持（completedAtのみクリア）
    await fetch(`/api/todos/${todo.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ completedAt: null }),
    });
    fetchTodos();
  };

  // 完了済みTODOにメッセージを追加
  const openAddMessageDialog = (todo: Todo) => {
    setAddingMessageTodo(todo);
    setNewTodoMessage("");
    setTodoAddMessageOpen(true);
  };

  const handleAddMessageSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!addingMessageTodo || !newTodoMessage.trim()) return;
    const updatedMemo = addTodoMessage(
      addingMessageTodo.completedMemo,
      newTodoMessage.trim()
    );
    await fetch(`/api/todos/${addingMessageTodo.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ completedMemo: updatedMemo }),
    });
    setTodoAddMessageOpen(false);
    setAddingMessageTodo(null);
    setNewTodoMessage("");
    fetchTodos();
  };

  // タイムラインを自動生成してから進捗を取得
  const generateAndFetchProgress = async () => {
    await fetch(`/api/projects/${id}/progress/generate`, { method: "POST" });
    fetchProgress();
  };

  // Strict Modeでの二重呼び出しを防止
  const hasGeneratedRef = useRef(false);

  useEffect(() => {
    fetchProject();
    fetchComments();
    fetchTodos();
    fetchFiles();
    fetchConstructionData();
    // generate APIは1回だけ呼び出す（React Strict Modeでの二重実行防止）
    if (!hasGeneratedRef.current) {
      hasGeneratedRef.current = true;
      generateAndFetchProgress();
    } else {
      // 2回目以降は進捗の取得のみ
      fetchProgress();
    }
  }, [id]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!form.date) return;
    await fetch(`/api/projects/${id}/progress`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        title: form.title,
        description: form.description,
        status: form.status,
        createdAt: form.date.toISOString(),
      }),
    });
    setForm({ title: "", description: "", date: undefined, status: "planned" });
    setDateText("");
    setOpen(false);
    fetchProgress();
  };

  const markAsCompleted = async (progressId: number) => {
    await fetch(`/api/projects/${id}/progress`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        progressId, 
        status: "completed",
        completedAt: new Date().toISOString(),
      }),
    });
    fetchProgress();
  };

  const markAsIncomplete = async (progressId: number) => {
    await fetch(`/api/projects/${id}/progress`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        progressId, 
        status: "planned",
        completedAt: null,
      }),
    });
    fetchProgress();
  };

  const openEditDialog = (p: Progress) => {
    setEditingProgress(p);
    const date = new Date(p.createdAt);
    const completedAt = p.completedAt ? new Date(p.completedAt) : undefined;
    setEditForm({
      title: p.title,
      description: p.description ?? "",
      date,
      completedAt,
      status: p.status as "planned" | "completed",
    });
    setEditDateText(formatYyyyMd(date));
    setEditCompletedDateText(completedAt ? formatYyyyMd(completedAt) : "");
    setEditOpen(true);
  };

  const handleEditSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editingProgress || !editForm.date) return;
    await fetch(`/api/projects/${id}/progress`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        progressId: editingProgress.id,
        title: editForm.title,
        description: editForm.description,
        status: editForm.status,
        createdAt: editForm.date.toISOString(),
        completedAt: editForm.completedAt ? editForm.completedAt.toISOString() : null,
      }),
    });
    setEditOpen(false);
    setEditingProgress(null);
    fetchProgress();
  };

  const handleDelete = async () => {
    if (!editingProgress) return;
    if (!confirm("この進捗を削除しますか？")) return;
    await fetch(`/api/projects/${id}/progress?progressId=${editingProgress.id}`, {
      method: "DELETE",
    });
    setEditOpen(false);
    setEditingProgress(null);
    fetchProgress();
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString("ja-JP", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    });
  };

  const getMappleUrl = (coords: string | null) => {
    const parsed = coords ? parseCoordinateString(coords) : null;
    if (!parsed) return null;
    return `https://labs.mapple.com/mapplexml.html#16/${parsed.lat}/${parsed.lon}`;
  };

  const getGoogleMapsUrl = (coords: string | null) => {
    const parsed = coords ? parseCoordinateString(coords) : null;
    if (!parsed) return null;
    return `https://www.google.com/maps?q=${parsed.lat},${parsed.lon}`;
  };

  const getHazardMapUrl = (coords: string | null) => {
    const parsed = coords ? parseCoordinateString(coords) : null;
    if (!parsed) return null;
    return `https://disaportal.gsi.go.jp/maps/?ll=${parsed.lat},${parsed.lon}&z=16&base=ort&vs=c1j0l0u0t0h0z0`;
  };

  // 現地住所から都道府県の選択値（法令検索用）を取得
  const getPrefectureParam = (address: string | null): string | null => {
    if (!address) return null;
    if (address.includes("広島県")) return "hiroshima";
    if (address.includes("岡山県")) return "okayama";
    return null;
  };

  // 法令確認画面へのURL（座標・都道府県をクエリで渡す）
  const getLegalSearchUrl = () => {
    if (!project?.coordinates || !project?.address) return null;
    const parsed = parseCoordinateString(project.coordinates);
    if (!parsed) return null;
    const { lat, lon } = parsed;
    const prefectureParam = getPrefectureParam(project.address);
    if (!prefectureParam || !lat || !lon) return null;
    const params = new URLSearchParams({ lat, lon, prefecture: prefectureParam });
    return `/legal?${params.toString()}`;
  };

  // 法令タブを直接開いたときも、法令検索ボタンと同じ内容を表示する（座標・住所があれば検索パラメータを自動設定）
  useEffect(() => {
    if (activeTab !== "legal") return;
    if (legalSearchParams != null) return;
    if (!project?.coordinates || !project?.address) return;
    const parsed = parseCoordinateString(project.coordinates);
    if (!parsed) return;
    const prefectureParam = getPrefectureParam(project.address);
    if (!prefectureParam || !parsed.lat || !parsed.lon) return;
    setLegalSearchParams({ lat: parsed.lat, lon: parsed.lon, prefecture: prefectureParam });
  }, [activeTab, legalSearchParams, project?.coordinates, project?.address]);

  // 進捗を日付でソート（すべてDBから取得）
  const sortedTimeline = useMemo(() => {
    return [...progressList]
      .map((p) => ({
        id: p.id,
        title: p.title,
        description: p.description ?? undefined,
        date: new Date(p.createdAt),
        completedAt: p.completedAt ? new Date(p.completedAt) : undefined,
        status: p.status as "completed" | "planned",
      }))
      .sort((a, b) => a.date.getTime() - b.date.getTime());
  }, [progressList]);

  if (!project) return null;

  return (
    <div className="min-h-screen bg-background px-6">
      <div className="mx-auto max-w-7xl py-10">
        <div className="space-y-6">
          {/* ヘッダー */}
          <div className="flex items-center gap-3">
            <Button asChild variant="ghost" size="icon">
              <Link href="/projects">
                <ArrowLeft className="h-4 w-4" />
              </Link>
            </Button>
            <div className="space-y-1">
              <h1 className="text-xl font-semibold">{project.managementNumber}</h1>
              <p className="text-sm text-muted-foreground">
                {project.client} / {project.projectNumber}
              </p>
              {project.completionMonth && (
                <p className="text-sm text-muted-foreground">
                  完成月: {project.completionMonth}
                </p>
              )}
            </div>
          </div>

          {/* 進捗追加ダイアログ */}
          <Dialog open={open} onOpenChange={setOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>進捗を追加</DialogTitle>
              </DialogHeader>
              <form onSubmit={handleSubmit} className="space-y-4">
                <div className="space-y-2">
                  <Label>タイトル</Label>
                  <Select
                    value={form.title}
                    onValueChange={(value) => setForm({ ...form, title: value })}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="選択してください" />
                    </SelectTrigger>
                    <SelectContent>
                      {PROGRESS_TITLES.map((title) => (
                        <SelectItem key={title} value={title}>
                          {title}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="description">詳細（任意）</Label>
                  <Textarea
                    id="description"
                    value={form.description}
                    onChange={(e) => setForm({ ...form, description: e.target.value })}
                    placeholder="例: 司法書士事務所へ郵送済み"
                    rows={3}
                  />
                </div>
                <div className="space-y-2">
                  <Label>日付</Label>
                  <div className="flex gap-2">
                    <Input
                      value={dateText}
                      onChange={(e) => {
                        const value = e.target.value;
                        setDateText(value);
                        const match = value.match(/^(\d{4})[./](\d{1,2})[./](\d{1,2})$/);
                        if (match) {
                          const [, y, m, d] = match;
                          const parsed = new Date(Number(y), Number(m) - 1, Number(d));
                          if (!isNaN(parsed.getTime())) {
                            setForm({ ...form, date: parsed });
                          }
                        } else if (value === "") {
                          setForm({ ...form, date: undefined });
                        }
                      }}
                      placeholder="例: 2026.1.19"
                      className="flex-1"
                    />
                    <Popover open={isCalendarOpen} onOpenChange={setIsCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button type="button" variant="outline" size="icon">
                          <CalendarIcon className="h-4 w-4" />
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="end">
                        <Calendar
                          mode="single"
                          required
                          selected={form.date}
                          onSelect={(d) => {
                            if (d) {
                              setForm({ ...form, date: d });
                              setDateText(formatYyyyMd(d));
                            }
                            setIsCalendarOpen(false);
                          }}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                  </div>
                </div>
                <div className="space-y-2">
                  <Label>ステータス</Label>
                  <Select
                    value={form.status}
                    onValueChange={(value: "planned" | "completed") =>
                      setForm({ ...form, status: value })
                    }
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="planned">予定</SelectItem>
                      <SelectItem value="completed">完了</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="flex justify-end gap-2">
                  <Button type="button" variant="outline" onClick={() => setOpen(false)}>
                    キャンセル
                  </Button>
                  <Button type="submit" disabled={!form.date || !form.title}>
                    追加
                  </Button>
                </div>
              </form>
            </DialogContent>
          </Dialog>

          {/* 編集ダイアログ */}
          <Dialog open={editOpen} onOpenChange={setEditOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>進捗を編集</DialogTitle>
              </DialogHeader>
              <form onSubmit={handleEditSubmit} className="space-y-4">
                <div className="space-y-2">
                  <Label>タイトル</Label>
                  <Select
                    value={editForm.title}
                    onValueChange={(value) => setEditForm({ ...editForm, title: value })}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="選択してください" />
                    </SelectTrigger>
                    <SelectContent>
                      {PROGRESS_TITLES.map((title) => (
                        <SelectItem key={title} value={title}>
                          {title}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="edit-description">詳細（任意）</Label>
                  <Textarea
                    id="edit-description"
                    value={editForm.description}
                    onChange={(e) => setEditForm({ ...editForm, description: e.target.value })}
                    placeholder="例: 司法書士事務所へ郵送済み"
                    rows={3}
                  />
                </div>
                <div className="space-y-2">
                  <Label>予定日</Label>
                  <div className="flex gap-2">
                    <Input
                      value={editDateText}
                      onChange={(e) => {
                        const value = e.target.value;
                        setEditDateText(value);
                        const match = value.match(/^(\d{4})[./](\d{1,2})[./](\d{1,2})$/);
                        if (match) {
                          const [, y, m, d] = match;
                          const parsed = new Date(Number(y), Number(m) - 1, Number(d));
                          if (!isNaN(parsed.getTime())) {
                            setEditForm({ ...editForm, date: parsed });
                          }
                        } else if (value === "") {
                          setEditForm({ ...editForm, date: undefined });
                        }
                      }}
                      placeholder="例: 2026.1.19"
                      className="flex-1"
                    />
                    <Popover open={editCalendarOpen} onOpenChange={setEditCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button type="button" variant="outline" size="icon">
                          <CalendarIcon className="h-4 w-4" />
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="end">
                        <Calendar
                          mode="single"
                          required
                          selected={editForm.date}
                          onSelect={(d) => {
                            if (d) {
                              setEditForm({ ...editForm, date: d });
                              setEditDateText(formatYyyyMd(d));
                            }
                            setEditCalendarOpen(false);
                          }}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                  </div>
                </div>
                <div className="space-y-2">
                  <Label>完了日（任意）</Label>
                  <div className="flex gap-2">
                    <Input
                      value={editCompletedDateText}
                      onChange={(e) => {
                        const value = e.target.value;
                        setEditCompletedDateText(value);
                        const match = value.match(/^(\d{4})[./](\d{1,2})[./](\d{1,2})$/);
                        if (match) {
                          const [, y, m, d] = match;
                          const parsed = new Date(Number(y), Number(m) - 1, Number(d));
                          if (!isNaN(parsed.getTime())) {
                            setEditForm({ ...editForm, completedAt: parsed });
                          }
                        } else if (value === "") {
                          setEditForm({ ...editForm, completedAt: undefined });
                        }
                      }}
                      placeholder="例: 2026.1.19"
                      className="flex-1"
                    />
                    <Popover open={editCompletedCalendarOpen} onOpenChange={setEditCompletedCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button type="button" variant="outline" size="icon">
                          <CalendarIcon className="h-4 w-4" />
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="end">
                        <Calendar
                          mode="single"
                          selected={editForm.completedAt}
                          onSelect={(d) => {
                            if (d) {
                              setEditForm({ ...editForm, completedAt: d });
                              setEditCompletedDateText(formatYyyyMd(d));
                            } else {
                              setEditForm({ ...editForm, completedAt: undefined });
                              setEditCompletedDateText("");
                            }
                            setEditCompletedCalendarOpen(false);
                          }}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                  </div>
                </div>
                <div className="space-y-2">
                  <Label>ステータス</Label>
                  <Select
                    value={editForm.status}
                    onValueChange={(value: "planned" | "completed") =>
                      setEditForm({ ...editForm, status: value })
                    }
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="planned">予定</SelectItem>
                      <SelectItem value="completed">完了</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="flex justify-between">
                  <Button
                    type="button"
                    variant="destructive"
                    size="sm"
                    onClick={handleDelete}
                  >
                    <Trash2 className="mr-1 h-4 w-4" />
                    削除
                  </Button>
                  <div className="flex gap-2">
                    <Button type="button" variant="outline" onClick={() => setEditOpen(false)}>
                      キャンセル
                    </Button>
                    <Button type="submit" disabled={!editForm.date || !editForm.title}>
                      保存
                    </Button>
                  </div>
                </div>
              </form>
            </DialogContent>
          </Dialog>

          {/* 統合タイムライン（横型） */}
          <div className="relative">
            <div className="mb-4 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Clock className="h-4 w-4 text-muted-foreground" />
                <h2 className="font-semibold">タイムライン</h2>
              </div>
              <Dialog open={open} onOpenChange={setOpen}>
                <DialogTrigger asChild>
                  <Button size="sm">
                    <Plus className="h-4 w-4" />
                    進捗を追加
                  </Button>
                </DialogTrigger>
              </Dialog>
            </div>
            {sortedTimeline.length === 0 ? (
              <p className="text-sm text-muted-foreground">タイムラインがありません</p>
            ) : (
              <div className="w-full">
                <div className="flex items-start gap-0 py-4">
                  {(() => {
                    // 直近の未完了項目のインデックスを計算
                    const firstPendingIndex = sortedTimeline.findIndex(
                      (item) => item.status !== "completed"
                    );
                    return sortedTimeline.map((item, index) => {
                      const isCompleted = item.status === "completed";
                      const isFirstPending = index === firstPendingIndex;

                      // 予定日までの日数を計算
                      const now = new Date();
                      const daysUntilDue = Math.ceil((item.date.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                      const isOverdue = !isCompleted && daysUntilDue < 0;

                      return (
                        <div key={item.id} className="flex flex-col items-center flex-1 min-w-0">
                          {/* 上部：タイトルと編集ボタン */}
                          <div className="text-center mb-2 px-0.5">
                            <div className="flex items-center justify-center gap-0.5">
                              <p
                                className={`text-[10px] sm:text-xs font-medium truncate max-w-full ${
                                  isCompleted ? "" : "text-muted-foreground"
                                }`}
                                title={item.title}
                              >
                                {item.title}
                              </p>
                              <button
                                type="button"
                                onClick={() => {
                                  const p = progressList.find((pr) => pr.id === item.id);
                                  if (p) openEditDialog(p);
                                }}
                                className="rounded p-0.5 text-muted-foreground hover:bg-muted hover:text-foreground shrink-0"
                              >
                                <Pencil className="h-2.5 w-2.5 sm:h-3 sm:w-3" />
                              </button>
                            </div>
                          </div>

                          {/* 中央：ノードと横線 */}
                          <div className="flex items-center w-full">
                            {/* 左側の線 */}
                            {index > 0 && (
                              <div
                                className={`flex-1 h-0.5 ${
                                  sortedTimeline[index - 1].status === "completed"
                                    ? "bg-green-500"
                                    : "border-t-2 border-dashed border-muted-foreground"
                                }`}
                              />
                            )}
                            {index === 0 && <div className="flex-1" />}

                            {/* ノード */}
                            <div
                              className={`flex h-6 w-6 sm:h-8 sm:w-8 shrink-0 items-center justify-center rounded-full border-2 ${
                                isCompleted
                                  ? "border-green-500 bg-green-500"
                                  : isOverdue
                                  ? "border-red-500 bg-background"
                                  : "border-muted-foreground bg-background"
                              }`}
                            >
                              {isCompleted ? (
                                <Check className="h-3 w-3 sm:h-4 sm:w-4 text-white" />
                              ) : (
                                <Circle className={`h-3 w-3 sm:h-4 sm:w-4 ${isOverdue ? "text-red-500" : "text-muted-foreground"}`} />
                              )}
                            </div>

                            {/* 右側の線 */}
                            {index < sortedTimeline.length - 1 && (
                              <div
                                className={`flex-1 h-0.5 ${
                                  isCompleted
                                    ? "bg-green-500"
                                    : "border-t-2 border-dashed border-muted-foreground"
                                }`}
                              />
                            )}
                            {index === sortedTimeline.length - 1 && <div className="flex-1" />}
                          </div>

                          {/* 下部：日付と説明、アクションボタン */}
                          <div className="text-center mt-2 px-0.5">
                            <p className="text-[10px] sm:text-xs text-muted-foreground truncate">
                              {formatDateJp(item.date)}
                            </p>
                            {item.completedAt && (
                              <p className={`text-[9px] sm:text-[10px] ${item.completedAt > item.date ? "text-red-500" : "text-green-500"}`}>
                                → {formatDateJp(item.completedAt)}
                              </p>
                            )}
                            {item.description && (
                              <p className="mt-1 text-[9px] sm:text-[10px] text-muted-foreground truncate max-w-full" title={item.description}>
                                {item.description}
                              </p>
                            )}

                            {/* アクションボタン */}
                            <div className="mt-2 flex flex-col gap-1">
                              {/* 未完了にするボタン（直近の完了タスク） */}
                              {isCompleted && (
                                firstPendingIndex === -1
                                  ? index === sortedTimeline.length - 1
                                  : index === firstPendingIndex - 1
                              ) && (
                                <Button
                                  variant="outline"
                                  size="sm"
                                  className="text-xs h-7 px-2 border-orange-300 text-orange-600 hover:bg-orange-50 hover:text-orange-700"
                                  onClick={() => markAsIncomplete(item.id)}
                                >
                                  未完了
                                </Button>
                              )}
                              {/* 完了にするボタン（直近の未完了タスク） */}
                              {isFirstPending && (
                                <Button
                                  variant="outline"
                                  size="sm"
                                  className="text-xs h-7 px-2"
                                  onClick={() => markAsCompleted(item.id)}
                                >
                                  完了
                                </Button>
                              )}
                            </div>
                          </div>
                        </div>
                      );
                    });
                  })()}
                </div>
              </div>
            )}
          </div>

          {/* TODO（この日までに行うリマインダー） */}
          <Card>
            <CardContent className="pt-6 space-y-4">
              <div className="flex items-center gap-2 mb-4">
                <ListTodo className="h-4 w-4 text-muted-foreground" />
                <h2 className="font-semibold">TODO</h2>
              </div>
              <form onSubmit={handleTodoSubmit} className="space-y-3">
                <div className="flex gap-2 flex-wrap items-end">
                  <div className="flex-1 min-w-[200px] space-y-1">
                    <Label htmlFor="new-todo-content" className="text-xs text-muted-foreground">内容</Label>
                    <Textarea
                      id="new-todo-content"
                      value={newTodoContent}
                      onChange={(e) => setNewTodoContent(e.target.value)}
                      placeholder="この日までに行うことを入力..."
                      rows={2}
                      className="resize-y"
                    />
                  </div>
                  <div className="space-y-1">
                    <Label className="text-xs text-muted-foreground">期日</Label>
                    <Popover open={newTodoCalendarOpen} onOpenChange={setNewTodoCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button
                          type="button"
                          variant="outline"
                          className={cn(
                            "w-[180px] justify-start text-left font-normal",
                            !newTodoSelectedDate && "text-muted-foreground"
                          )}
                        >
                          <CalendarIcon className="mr-2 h-4 w-4" />
                          {newTodoSelectedDate
                            ? formatDateJp(newTodoSelectedDate)
                            : "期日を選択"}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={newTodoSelectedDate}
                          onSelect={(date) => {
                            setNewTodoSelectedDate(date);
                            if (date) {
                              const y = date.getFullYear();
                              const m = String(date.getMonth() + 1).padStart(2, "0");
                              const d = String(date.getDate()).padStart(2, "0");
                              setNewTodoDueDate(`${y}-${m}-${d}`);
                              setNewTodoCalendarOpen(false);
                            }
                          }}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                  </div>
                  <Button type="submit" size="default" disabled={!newTodoContent.trim() || !newTodoDueDate}>
                    追加
                  </Button>
                </div>
              </form>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {todos.length === 0 ? (
                  <p className="text-sm text-muted-foreground">TODOはありません</p>
                ) : (
                  todos.map((todo) => (
                    <div
                      key={todo.id}
                      className={cn(
                        "flex items-start justify-between gap-2 p-3 rounded-lg border border-border",
                        todo.completedAt ? "bg-muted/30 opacity-90" : "bg-muted/50"
                      )}
                    >
                      <div className="flex-1 min-w-0">
                        <p className={cn("text-sm", todo.completedAt && "line-through text-muted-foreground")}>
                          {todo.content}
                        </p>
                        <p className="text-xs text-muted-foreground mt-1">
                          期日: {formatDateJp(new Date(todo.dueDate + "T00:00:00"))}
                          {todo.completedAt && (
                            <>
                              {" · "}
                              完了: {formatDateJp(new Date(todo.completedAt))}
                            </>
                          )}
                        </p>
                        {/* メッセージツリー表示 */}
                        {todo.completedMemo && (
                          <div className="mt-2 space-y-1">
                            {parseTodoMessages(todo.completedMemo).map((msg, idx, arr) => (
                              <div key={idx} className="flex items-start gap-2 text-xs text-muted-foreground">
                                <div className="flex flex-col items-center">
                                  <div className="w-2 h-2 rounded-full bg-zinc-400 dark:bg-zinc-600 mt-1.5"></div>
                                  {idx < arr.length - 1 && (
                                    <div className="w-0.5 h-full bg-zinc-300 dark:bg-zinc-700 min-h-[16px]"></div>
                                  )}
                                </div>
                                <div className="flex-1 p-2 rounded bg-background/50 border border-border/50">
                                  <p className="text-xs">{msg.message}</p>
                                  <p className="text-[10px] text-muted-foreground/70 mt-0.5">
                                    {formatDateJp(new Date(msg.createdAt))}
                                  </p>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                      <div className="flex gap-1 shrink-0">
                        {todo.completedAt ? (
                          <div className="flex flex-col gap-1">
                            <Button
                              type="button"
                              variant="ghost"
                              size="sm"
                              className="h-7 text-xs"
                              onClick={() => openAddMessageDialog(todo)}
                              title="メッセージを追加"
                            >
                              <Plus className="h-3 w-3 mr-1" />
                              メモ
                            </Button>
                            <Button
                              type="button"
                              variant="ghost"
                              size="sm"
                              className="h-7 text-xs"
                              onClick={() => handleTodoReopen(todo)}
                            >
                              再開
                            </Button>
                          </div>
                        ) : (
                          <>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="h-7 w-7"
                              onClick={() => openTodoEditDialog(todo)}
                            >
                              <Pencil className="h-3.5 w-3.5" />
                            </Button>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="h-7 w-7 text-green-600 hover:text-green-700"
                              onClick={() => openTodoCompleteDialog(todo)}
                              title="完了"
                            >
                              <CheckCircle2 className="h-3.5 w-3.5" />
                            </Button>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="h-7 w-7 text-destructive hover:text-destructive"
                              onClick={() => openTodoDeleteDialog(todo)}
                            >
                              <Trash2 className="h-3.5 w-3.5" />
                            </Button>
                          </>
                        )}
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>

          {/* タブ UI */}
          <Tabs defaultValue="details" className="w-full" value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="grid w-full grid-cols-4">
              <TabsTrigger value="details">案件情報</TabsTrigger>
              <TabsTrigger value="legal">法令</TabsTrigger>
              <TabsTrigger value="construction">工事</TabsTrigger>
              <TabsTrigger value="comments">コメント</TabsTrigger>
            </TabsList>

            <TabsContent value="details" className="mt-6">
              <Card>
                <CardContent className="pt-6 space-y-4">
                  <div className="grid grid-cols-3 items-start border-b pb-3">
                    <span className="text-sm font-medium text-muted-foreground">現地住所</span>
                    <div className="col-span-2 flex items-center gap-2">
                      <span className="text-sm">{project.address || "未登録"}</span>
                      {project.address && (
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 w-6 p-0"
                          onClick={copyAddress}
                        >
                          {copiedField === "address" ? (
                            <Check className="h-3 w-3 text-green-500" />
                          ) : (
                            <Copy className="h-3 w-3" />
                          )}
                        </Button>
                      )}
                    </div>
                  </div>
                  <div className="grid grid-cols-3 items-start border-b pb-3">
                    <span className="text-sm font-medium text-muted-foreground">座標</span>
                    <div className="col-span-2 space-y-3">
                      <div className="flex items-center gap-2">
                        <span className="text-sm">{project.coordinates || "未登録"}</span>
                        {project.coordinates && (
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-6 w-6 p-0"
                            onClick={copyCoordinates}
                          >
                            {copiedField === "coordinates" ? (
                              <Check className="h-3 w-3 text-green-500" />
                            ) : (
                              <Copy className="h-3 w-3" />
                            )}
                          </Button>
                        )}
                      </div>
                      {project.coordinates && (
                        <div className="flex flex-wrap gap-2 mt-2">
                          <Button variant="outline" size="sm" asChild className="h-8">
                            <a
                              href={getMappleUrl(project.coordinates) || ""}
                              target="_blank"
                              rel="noopener noreferrer"
                            >
                              <ExternalLink className="h-3 w-3 mr-2" />
                              MAPPLE
                            </a>
                          </Button>
                          <Button variant="outline" size="sm" asChild className="h-8">
                            <a
                              href={getGoogleMapsUrl(project.coordinates) || ""}
                              target="_blank"
                              rel="noopener noreferrer"
                            >
                              <ExternalLink className="h-3 w-3 mr-2" />
                              Google Map
                            </a>
                          </Button>
                          <Button variant="outline" size="sm" asChild className="h-8">
                            <a
                              href={getHazardMapUrl(project.coordinates) || ""}
                              target="_blank"
                              rel="noopener noreferrer"
                            >
                              <ExternalLink className="h-3 w-3 mr-2" />
                              ハザード
                            </a>
                          </Button>
                        </div>
                      )}
                    </div>
                  </div>
                  <div className="grid grid-cols-3 items-start border-b pb-3">
                    <span className="text-sm font-medium text-muted-foreground">法令</span>
                    <div className="col-span-2">
                      {(() => {
                        // 保存された法令情報を解析
                        const legalStatuses = project?.legalStatuses
                          ? (() => {
                              try {
                                return JSON.parse(project.legalStatuses) as Record<string, { status: string; note?: string }>;
                              } catch {
                                return null;
                              }
                            })()
                          : null;

                        if (legalStatuses && Object.keys(legalStatuses).length > 0) {
                          // 該当・要確認・非該当でグループ分け
                          const applicable = Object.entries(legalStatuses).filter(([, v]) => v.status === "該当");
                          const needsCheck = Object.entries(legalStatuses).filter(([, v]) => v.status === "要確認");
                          const notApplicable = Object.entries(legalStatuses).filter(([, v]) => v.status === "非該当");

                          return (
                            <div className="space-y-2">
                              {applicable.length > 0 && (
                                <div className="flex flex-wrap gap-1.5">
                                  {applicable.map(([name, info]) => (
                                    <span
                                      key={name}
                                      className="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800 dark:bg-red-900/40 dark:text-red-200 border border-red-200 dark:border-red-800 cursor-pointer hover:bg-red-200 dark:hover:bg-red-900/60 transition-colors"
                                      onClick={() => setActiveTab("legal")}
                                      title={info.note || "該当"}
                                    >
                                      {name}
                                    </span>
                                  ))}
                                </div>
                              )}
                              {needsCheck.length > 0 && (
                                <div className="flex flex-wrap gap-1.5">
                                  {needsCheck.map(([name, info]) => (
                                    <span
                                      key={name}
                                      className="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200 border border-amber-200 dark:border-amber-800 cursor-pointer hover:bg-amber-200 dark:hover:bg-amber-900/60 transition-colors"
                                      onClick={() => setActiveTab("legal")}
                                      title={info.note || "要確認"}
                                    >
                                      {name}
                                    </span>
                                  ))}
                                </div>
                              )}
                              {notApplicable.length > 0 && (
                                <details className="text-xs">
                                  <summary className="text-muted-foreground cursor-pointer hover:text-foreground">
                                    非該当 ({notApplicable.length}件)
                                  </summary>
                                  <div className="flex flex-wrap gap-1.5 mt-1.5">
                                    {notApplicable.map(([name]) => (
                                      <span
                                        key={name}
                                        className="inline-flex items-center px-2 py-0.5 rounded-full text-xs bg-muted text-muted-foreground"
                                      >
                                        {name}
                                      </span>
                                    ))}
                                  </div>
                                </details>
                              )}
                              <button
                                className="text-xs text-primary hover:underline mt-1"
                                onClick={() => setActiveTab("legal")}
                              >
                                法令タブで詳細を確認・編集
                              </button>
                            </div>
                          );
                        }

                        // 法令情報がない場合
                        return (
                          <div className="space-y-2">
                            <span className="text-sm text-muted-foreground">
                              法令情報は登録されていません
                            </span>
                            {getLegalSearchUrl() && (
                              <button
                                className="block text-xs text-primary hover:underline"
                                onClick={() => {
                                  const url = getLegalSearchUrl();
                                  if (url) {
                                    const urlObj = new URL(url, window.location.origin);
                                    const lat = urlObj.searchParams.get("lat");
                                    const lon = urlObj.searchParams.get("lon");
                                    const prefecture = urlObj.searchParams.get("prefecture");
                                    if (lat && lon && prefecture) {
                                      setLegalSearchParams({ lat, lon, prefecture });
                                      setActiveTab("legal");
                                    }
                                  }
                                }}
                              >
                                法令タブで確認・登録
                              </button>
                            )}
                          </div>
                        );
                      })()}
                    </div>
                  </div>
                  <div className="grid grid-cols-3 items-start border-b pb-3">
                    <span className="text-sm font-medium text-muted-foreground">地権者</span>
                    <div className="col-span-2 flex items-start gap-2">
                      <div className="space-y-3 text-sm flex-1">
                        {/* 地権者1 */}
                        {project.landowner1 && (
                          <div className="p-2 rounded-lg bg-muted/30 space-y-1">
                            <div className="font-medium">{project.landowner1}</div>
                            {project.landownerAddress1 && (
                              <div className="text-xs text-muted-foreground">住所: {project.landownerAddress1}</div>
                            )}
                            <div className="flex flex-wrap gap-2 text-xs">
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.inheritanceStatus1 === "有" ? "bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200" :
                                project.inheritanceStatus1 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                相続: {project.inheritanceStatus1 || "未確認"}
                              </span>
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.correctionRegistration1 === "有" ? "bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200" :
                                project.correctionRegistration1 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                更正登記: {project.correctionRegistration1 || "未確認"}
                              </span>
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.mortgageStatus1 === "有" ? "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200" :
                                project.mortgageStatus1 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                抵当権: {project.mortgageStatus1 || "未確認"}
                              </span>
                            </div>
                          </div>
                        )}
                        {/* 地権者2 */}
                        {project.landowner2 && (
                          <div className="p-2 rounded-lg bg-muted/30 space-y-1">
                            <div className="font-medium">{project.landowner2}</div>
                            {project.landownerAddress2 && (
                              <div className="text-xs text-muted-foreground">住所: {project.landownerAddress2}</div>
                            )}
                            <div className="flex flex-wrap gap-2 text-xs">
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.inheritanceStatus2 === "有" ? "bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200" :
                                project.inheritanceStatus2 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                相続: {project.inheritanceStatus2 || "未確認"}
                              </span>
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.correctionRegistration2 === "有" ? "bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200" :
                                project.correctionRegistration2 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                更正登記: {project.correctionRegistration2 || "未確認"}
                              </span>
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.mortgageStatus2 === "有" ? "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200" :
                                project.mortgageStatus2 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                抵当権: {project.mortgageStatus2 || "未確認"}
                              </span>
                            </div>
                          </div>
                        )}
                        {/* 地権者3 */}
                        {project.landowner3 && (
                          <div className="p-2 rounded-lg bg-muted/30 space-y-1">
                            <div className="font-medium">{project.landowner3}</div>
                            {project.landownerAddress3 && (
                              <div className="text-xs text-muted-foreground">住所: {project.landownerAddress3}</div>
                            )}
                            <div className="flex flex-wrap gap-2 text-xs">
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.inheritanceStatus3 === "有" ? "bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200" :
                                project.inheritanceStatus3 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                相続: {project.inheritanceStatus3 || "未確認"}
                              </span>
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.correctionRegistration3 === "有" ? "bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200" :
                                project.correctionRegistration3 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                更正登記: {project.correctionRegistration3 || "未確認"}
                              </span>
                              <span className={cn(
                                "px-2 py-0.5 rounded-full",
                                project.mortgageStatus3 === "有" ? "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200" :
                                project.mortgageStatus3 === "無" ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
                                "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
                              )}>
                                抵当権: {project.mortgageStatus3 || "未確認"}
                              </span>
                            </div>
                          </div>
                        )}
                        {!project.landowner1 && !project.landowner2 && !project.landowner3 && (
                          <span>未登録</span>
                        )}
                      </div>
                      {(project.landowner1 || project.landowner2 || project.landowner3) && (
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 w-6 p-0"
                          onClick={copyLandowners}
                        >
                          {copiedField === "landowners" ? (
                            <Check className="h-3 w-3 text-green-500" />
                          ) : (
                            <Copy className="h-3 w-3" />
                          )}
                        </Button>
                      )}
                    </div>
                  </div>
                  <div className="grid grid-cols-3 items-start border-b pb-3">
                    <span className="text-sm font-medium text-muted-foreground">地目・面積</span>
                    <div className="col-span-2 space-y-1 text-sm">
                      {(project.landCategory1 || project.landArea1) && (
                        <div className="flex items-center gap-2">
                          <span>{project.landCategory1 || "-"}</span>
                          <span className="text-muted-foreground">:</span>
                          <span>{project.landArea1 || "-"} ㎡</span>
                        </div>
                      )}
                      {(project.landCategory2 || project.landArea2) && (
                        <div className="flex items-center gap-2">
                          <span>{project.landCategory2 || "-"}</span>
                          <span className="text-muted-foreground">:</span>
                          <span>{project.landArea2 || "-"} ㎡</span>
                        </div>
                      )}
                      {(project.landCategory3 || project.landArea3) && (
                        <div className="flex items-center gap-2">
                          <span>{project.landCategory3 || "-"}</span>
                          <span className="text-muted-foreground">:</span>
                          <span>{project.landArea3 || "-"} ㎡</span>
                        </div>
                      )}
                      {!project.landCategory1 && !project.landArea1 && 
                       !project.landCategory2 && !project.landArea2 && 
                       !project.landCategory3 && !project.landArea3 && (
                        <span>未登録</span>
                      )}
                      <div className="flex items-center gap-2 pt-1 border-t mt-1">
                        <span className="font-medium">合計:</span>
                        <span className="font-medium">
                          {calculateTotalArea(
                            project.landArea1 ?? "",
                            project.landArea2 ?? "",
                            project.landArea3 ?? ""
                          )} ㎡
                        </span>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 w-6 p-0"
                          onClick={copyTotalArea}
                        >
                          {copiedField === "totalArea" ? (
                            <Check className="h-3 w-3 text-green-500" />
                          ) : (
                            <Copy className="h-3 w-3" />
                          )}
                        </Button>
                      </div>
                    </div>
                  </div>
                  {/* 環境データ */}
                  <div className="grid grid-cols-3 items-start border-b pb-3">
                    <span className="text-sm font-medium text-muted-foreground">環境データ</span>
                    <div className="col-span-2 space-y-1 text-sm">
                      <div className="flex items-center gap-4">
                        <div className="flex items-center gap-2">
                          <span className="text-muted-foreground">垂直積雪量:</span>
                          <span className="font-medium">{project.verticalSnowLoad || "未登録"}</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <span className="text-muted-foreground">風速:</span>
                          <span className="font-medium">{project.windSpeed || "未登録"}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                  {/* どこキャビ連携 */}
                  <div className="grid grid-cols-3 items-start border-b pb-3">
                    <span className="text-sm font-medium text-muted-foreground">どこキャビ</span>
                    <div className="col-span-2 text-sm">
                      {project.dococabiLink ? (
                        <Button variant="outline" size="sm" asChild className="h-8">
                          <a
                            href={project.dococabiLink}
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            <ExternalLink className="h-3 w-3 mr-2" />
                            どこキャビを開く
                          </a>
                        </Button>
                      ) : (
                        <span className="text-muted-foreground">未登録</span>
                      )}
                    </div>
                  </div>
                  <div className="flex justify-end pt-2">
                    <Button variant="outline" size="sm" onClick={openDetailEditDialog}>
                      <Pencil className="h-4 w-4 mr-2" />
                      詳細情報を編集
                    </Button>
                  </div>
                </CardContent>
              </Card>

              {/* ファイル */}
              <Card className="mt-6">
                <CardContent className="pt-6">
                  <h3 className="font-semibold mb-4">ファイル</h3>
                  <ProjectFiles projectId={Number(id)} initialFiles={files} />
                </CardContent>
              </Card>
            </TabsContent>

            <TabsContent value="legal" className="mt-6 space-y-6">
              <LegalSearchTab
                searchParams={legalSearchParams}
                projectAddress={project?.address || null}
                projectCoordinates={project?.coordinates || null}
                projectLandCategories={
                  project
                    ? {
                        landCategory1: project.landCategory1 ?? null,
                        landCategory2: project.landCategory2 ?? null,
                        landCategory3: project.landCategory3 ?? null,
                      }
                    : null
                }
                projectId={project?.id}
                initialLegalStatuses={project?.legalStatuses}
                onLegalStatusesChange={(statuses) => {
                  if (project) {
                    setProject({ ...project, legalStatuses: JSON.stringify(statuses) });
                  }
                }}
              />
            </TabsContent>

            <TabsContent value="construction" className="mt-6 space-y-6">
              {/* 工事タブ */}
              <Card>
                <CardContent className="pt-6 space-y-6">
                  {/* 基本日程 */}
                  <div>
                    <div className="flex items-center gap-2 mb-4">
                      <HardHat className="h-4 w-4 text-muted-foreground" />
                      <h3 className="font-semibold">工事日程</h3>
                    </div>
                    <div className="grid gap-4 md:grid-cols-2">
                      <div className="space-y-2">
                        <Label>着工可能日</Label>
                        <Popover open={constructionAvailableDateOpen} onOpenChange={setConstructionAvailableDateOpen}>
                          <PopoverTrigger asChild>
                            <Button variant="outline" className={cn("w-full justify-start text-left font-normal", !project?.constructionAvailableDate && "text-muted-foreground")}>
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {project?.constructionAvailableDate ? formatYyyyMd(new Date(project.constructionAvailableDate + "T00:00:00")) : "選択してください"}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0" align="start">
                            <Calendar
                              mode="single"
                              selected={project?.constructionAvailableDate ? new Date(project.constructionAvailableDate + "T00:00:00") : undefined}
                              onSelect={async (d) => {
                                const value = d ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}` : null;
                                await fetch(`/api/projects/${id}`, {
                                  method: "PATCH",
                                  headers: { "Content-Type": "application/json" },
                                  body: JSON.stringify({ constructionAvailableDate: value }),
                                });
                                fetchProject();
                                setConstructionAvailableDateOpen(false);
                              }}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                      </div>
                      <div className="space-y-2">
                        <Label>納品日</Label>
                        <Popover open={deliveryDateOpen} onOpenChange={setDeliveryDateOpen}>
                          <PopoverTrigger asChild>
                            <Button variant="outline" className={cn("w-full justify-start text-left font-normal", !project?.deliveryDate && "text-muted-foreground")}>
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {project?.deliveryDate ? formatYyyyMd(new Date(project.deliveryDate + "T00:00:00")) : "選択してください"}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0" align="start">
                            <Calendar
                              mode="single"
                              selected={project?.deliveryDate ? new Date(project.deliveryDate + "T00:00:00") : undefined}
                              onSelect={async (d) => {
                                const value = d ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}` : null;
                                await fetch(`/api/projects/${id}`, {
                                  method: "PATCH",
                                  headers: { "Content-Type": "application/json" },
                                  body: JSON.stringify({ deliveryDate: value }),
                                });
                                fetchProject();
                                setDeliveryDateOpen(false);
                              }}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                      </div>
                      <div className="space-y-2">
                        <Label>着工予定日</Label>
                        <Popover open={constructionStartScheduledOpen} onOpenChange={setConstructionStartScheduledOpen}>
                          <PopoverTrigger asChild>
                            <Button variant="outline" className={cn("w-full justify-start text-left font-normal", !project?.constructionStartScheduled && "text-muted-foreground")}>
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {project?.constructionStartScheduled ? formatYyyyMd(new Date(project.constructionStartScheduled + "T00:00:00")) : "選択してください"}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0" align="start">
                            <Calendar
                              mode="single"
                              selected={project?.constructionStartScheduled ? new Date(project.constructionStartScheduled + "T00:00:00") : undefined}
                              onSelect={async (d) => {
                                const value = d ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}` : null;
                                await fetch(`/api/projects/${id}`, {
                                  method: "PATCH",
                                  headers: { "Content-Type": "application/json" },
                                  body: JSON.stringify({ constructionStartScheduled: value }),
                                });
                                fetchProject();
                                setConstructionStartScheduledOpen(false);
                              }}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                      </div>
                      <div className="space-y-2">
                        <Label>着工日</Label>
                        <Popover open={constructionStartDateOpen} onOpenChange={setConstructionStartDateOpen}>
                          <PopoverTrigger asChild>
                            <Button variant="outline" className={cn("w-full justify-start text-left font-normal", !project?.constructionStartDate && "text-muted-foreground")}>
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {project?.constructionStartDate ? formatYyyyMd(new Date(project.constructionStartDate + "T00:00:00")) : "選択してください"}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0" align="start">
                            <Calendar
                              mode="single"
                              selected={project?.constructionStartDate ? new Date(project.constructionStartDate + "T00:00:00") : undefined}
                              onSelect={async (d) => {
                                const value = d ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}` : null;
                                await fetch(`/api/projects/${id}`, {
                                  method: "PATCH",
                                  headers: { "Content-Type": "application/json" },
                                  body: JSON.stringify({ constructionStartDate: value }),
                                });
                                fetchProject();
                                setConstructionStartDateOpen(false);
                              }}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                      </div>
                      <div className="space-y-2">
                        <Label>完工予定日</Label>
                        <Popover open={constructionEndScheduledOpen} onOpenChange={setConstructionEndScheduledOpen}>
                          <PopoverTrigger asChild>
                            <Button variant="outline" className={cn("w-full justify-start text-left font-normal", !project?.constructionEndScheduled && "text-muted-foreground")}>
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {project?.constructionEndScheduled ? formatYyyyMd(new Date(project.constructionEndScheduled + "T00:00:00")) : "選択してください"}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0" align="start">
                            <Calendar
                              mode="single"
                              selected={project?.constructionEndScheduled ? new Date(project.constructionEndScheduled + "T00:00:00") : undefined}
                              onSelect={async (d) => {
                                const value = d ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}` : null;
                                await fetch(`/api/projects/${id}`, {
                                  method: "PATCH",
                                  headers: { "Content-Type": "application/json" },
                                  body: JSON.stringify({ constructionEndScheduled: value }),
                                });
                                fetchProject();
                                setConstructionEndScheduledOpen(false);
                              }}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                      </div>
                      <div className="space-y-2">
                        <Label>完工日</Label>
                        <Popover open={constructionEndDateOpen} onOpenChange={setConstructionEndDateOpen}>
                          <PopoverTrigger asChild>
                            <Button variant="outline" className={cn("w-full justify-start text-left font-normal", !project?.constructionEndDate && "text-muted-foreground")}>
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {project?.constructionEndDate ? formatYyyyMd(new Date(project.constructionEndDate + "T00:00:00")) : "選択してください"}
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent className="w-auto p-0" align="start">
                            <Calendar
                              mode="single"
                              selected={project?.constructionEndDate ? new Date(project.constructionEndDate + "T00:00:00") : undefined}
                              onSelect={async (d) => {
                                const value = d ? `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}` : null;
                                await fetch(`/api/projects/${id}`, {
                                  method: "PATCH",
                                  headers: { "Content-Type": "application/json" },
                                  body: JSON.stringify({ constructionEndDate: value }),
                                });
                                fetchProject();
                                setConstructionEndDateOpen(false);
                              }}
                              initialFocus
                            />
                          </PopoverContent>
                        </Popover>
                      </div>
                    </div>
                  </div>

                  {/* 工事進捗 */}
                  <div>
                    <div className="flex items-center gap-2 mb-4">
                      <ListTodo className="h-4 w-4 text-muted-foreground" />
                      <h3 className="font-semibold">工事進捗</h3>
                    </div>
                    {isLoadingConstruction ? (
                      <div className="flex items-center justify-center py-8">
                        <Loader2 className="h-6 w-6 animate-spin" />
                      </div>
                    ) : (
                      <div className="space-y-3">
                        {CONSTRUCTION_PROGRESS_CATEGORIES.map((category) => {
                          const progress = constructionProgressList.find(p => p.category === category);
                          const currentStatus = progress?.status || "pending";
                          return (
                            <div key={category} className="flex items-center gap-4 p-3 bg-muted/30 rounded-lg">
                              <div className="flex-1">
                                <span className="font-medium">{category}</span>
                                {progress?.note && (
                                  <p className="text-xs text-muted-foreground mt-1">{progress.note}</p>
                                )}
                              </div>
                              <Select
                                value={currentStatus}
                                onValueChange={(value) => handleConstructionProgressUpdate(category, value)}
                              >
                                <SelectTrigger className={cn(
                                  "w-32",
                                  currentStatus === "completed" && "bg-green-100 dark:bg-green-900/30 border-green-300",
                                  currentStatus === "in_progress" && "bg-amber-100 dark:bg-amber-900/30 border-amber-300"
                                )}>
                                  <SelectValue />
                                </SelectTrigger>
                                <SelectContent>
                                  <SelectItem value="pending">未着手</SelectItem>
                                  <SelectItem value="in_progress">進行中</SelectItem>
                                  <SelectItem value="completed">完了</SelectItem>
                                </SelectContent>
                              </Select>
                            </div>
                          );
                        })}
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>

              {/* 工事写真 */}
              <Card>
                <CardContent className="pt-6 space-y-6">
                  <div className="flex items-center gap-2 mb-4">
                    <Camera className="h-4 w-4 text-muted-foreground" />
                    <h3 className="font-semibold">工事写真</h3>
                  </div>

                  {/* 写真アップロード */}
                  <div className="p-4 border-2 border-dashed rounded-lg space-y-4">
                    <div className="grid gap-4 md:grid-cols-2">
                      <div className="space-y-2">
                        <Label>写真カテゴリ *</Label>
                        <Select value={photoUploadCategory} onValueChange={setPhotoUploadCategory}>
                          <SelectTrigger>
                            <SelectValue placeholder="カテゴリを選択..." />
                          </SelectTrigger>
                          <SelectContent>
                            {CONSTRUCTION_PHOTO_CATEGORIES.map((cat) => (
                              <SelectItem key={cat} value={cat}>{cat}</SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>
                      <div className="space-y-2">
                        <Label>撮影業者名</Label>
                        <Input
                          value={photoContractorName}
                          onChange={(e) => setPhotoContractorName(e.target.value)}
                          placeholder="業者名を入力..."
                        />
                      </div>
                    </div>
                    <div className="space-y-2">
                      <Label>メモ</Label>
                      <Input
                        value={photoNote}
                        onChange={(e) => setPhotoNote(e.target.value)}
                        placeholder="写真に関するメモ..."
                      />
                    </div>
                    <div className="flex items-center gap-4">
                      <input
                        ref={photoInputRef}
                        type="file"
                        accept="image/*"
                        className="hidden"
                        onChange={(e) => {
                          const file = e.target.files?.[0];
                          if (file) handlePhotoUpload(file);
                        }}
                      />
                      <Button
                        variant="outline"
                        onClick={() => photoInputRef.current?.click()}
                        disabled={uploadingPhoto || !photoUploadCategory}
                      >
                        {uploadingPhoto ? (
                          <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        ) : (
                          <Upload className="h-4 w-4 mr-2" />
                        )}
                        写真をアップロード
                      </Button>
                      {!photoUploadCategory && (
                        <span className="text-xs text-muted-foreground">カテゴリを選択してください</span>
                      )}
                    </div>
                  </div>

                  {/* 写真一覧（カテゴリ別） */}
                  {CONSTRUCTION_PHOTO_CATEGORIES.map((category) => {
                    const categoryPhotos = constructionPhotos.filter(p => p.category === category);
                    if (categoryPhotos.length === 0) return null;
                    return (
                      <div key={category} className="space-y-3">
                        <h4 className="font-medium text-sm flex items-center gap-2">
                          <ImageIcon className="h-4 w-4" />
                          {category}
                          <span className="text-muted-foreground">({categoryPhotos.length})</span>
                        </h4>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                          {categoryPhotos.map((photo) => (
                            <div key={photo.id} className="relative group">
                              <a href={photo.fileUrl} target="_blank" rel="noopener noreferrer">
                                <img
                                  src={photo.fileUrl}
                                  alt={photo.fileName}
                                  className="w-full h-32 object-cover rounded-lg border"
                                />
                              </a>
                              <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg flex items-center justify-center">
                                <Button
                                  variant="destructive"
                                  size="sm"
                                  onClick={() => handlePhotoDelete(photo.id)}
                                >
                                  <Trash2 className="h-4 w-4" />
                                </Button>
                              </div>
                              <div className="mt-1 text-xs space-y-0.5">
                                {photo.contractorName && (
                                  <p className="text-muted-foreground">業者: {photo.contractorName}</p>
                                )}
                                <p className="text-muted-foreground truncate">{photo.fileName}</p>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    );
                  })}

                  {constructionPhotos.length === 0 && (
                    <p className="text-sm text-muted-foreground text-center py-8">
                      工事写真はまだアップロードされていません
                    </p>
                  )}
                </CardContent>
              </Card>
            </TabsContent>

            <TabsContent value="comments" className="mt-6 space-y-6">
              {/* コメントフィード */}
              <div className="relative">
                <div className="mb-4 flex items-center gap-2">
                  <MessageCircle className="h-4 w-4 text-muted-foreground" />
                  <h2 className="font-semibold">コメント</h2>
                </div>
                {/* コメント投稿欄 */}
                <form onSubmit={handleCommentSubmit} className="mb-4">
                  <div className="flex gap-2">
                    <Textarea
                      value={newComment}
                      onChange={(e) => setNewComment(e.target.value)}
                      placeholder="コメントを入力..."
                      rows={2}
                      className="flex-1"
                    />
                    <Button type="submit" size="icon" disabled={!newComment.trim()}>
                      <Send className="h-4 w-4" />
                    </Button>
                  </div>
                </form>
                {/* コメント一覧 */}
                <div className="space-y-3 max-h-64 overflow-y-auto">
                  {comments.length === 0 ? (
                    <p className="text-sm text-muted-foreground">コメントはありません</p>
                  ) : (
                    comments.map((comment) => (
                      <Card key={comment.id} className="bg-muted/50">
                        <CardContent className="p-3">
                          <div className="flex items-start justify-between gap-2">
                            <div className="flex-1">
                              <p className="text-sm">{comment.content}</p>
                              <p className="mt-1 text-xs text-muted-foreground">
                                {formatDateJp(new Date(comment.createdAt))}
                                {comment.userName && (
                                  <span className="ml-2">· {comment.userName}</span>
                                )}
                              </p>
                            </div>
                            <div className="flex gap-1">
                              <Button
                                variant="ghost"
                                size="icon"
                                className="h-7 w-7"
                                onClick={() => openCommentEditDialog(comment)}
                              >
                                <Pencil className="h-3.5 w-3.5" />
                              </Button>
                              <Button
                                variant="ghost"
                                size="icon"
                                className="h-7 w-7 text-destructive hover:text-destructive"
                                onClick={() => openCommentDeleteDialog(comment)}
                              >
                                <Trash2 className="h-3.5 w-3.5" />
                              </Button>
                            </div>
                          </div>
                        </CardContent>
                      </Card>
                    ))
                  )}
                </div>
              </div>
            </TabsContent>
          </Tabs>

          {/* 詳細情報編集ダイアログ */}
          <Dialog open={detailEditOpen} onOpenChange={setDetailEditOpen}>
            <DialogContent className="max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>詳細情報を編集</DialogTitle>
              </DialogHeader>
              <form onSubmit={handleDetailUpdate} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="address">現地住所</Label>
                  <Input
                    id="address"
                    value={detailForm.address}
                    onChange={(e) => setDetailForm({ ...detailForm, address: e.target.value })}
                    placeholder="例: 長野県..."
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="coordinates">座標</Label>
                  <Input
                    id="coordinates"
                    value={detailForm.coordinates}
                    onChange={(e) => setDetailForm({ ...detailForm, coordinates: e.target.value })}
                    onBlur={() => {
                      const normalized = normalizeCoordinateString(detailForm.coordinates);
                      if (normalized) setDetailForm({ ...detailForm, coordinates: normalized });
                    }}
                    placeholder="例: 36.6485, 138.1942（スラッシュ区切りも可）"
                  />
                </div>
                <div className="space-y-4">
                  <Label>地権者</Label>
                  {/* 地権者1 */}
                  <div className="p-3 border rounded-lg space-y-2">
                    <div className="text-xs font-medium text-muted-foreground">地権者1</div>
                    <Input
                      value={detailForm.landowner1}
                      onChange={(e) => setDetailForm({ ...detailForm, landowner1: e.target.value })}
                      placeholder="氏名"
                    />
                    <Input
                      value={detailForm.landownerAddress1}
                      onChange={(e) => setDetailForm({ ...detailForm, landownerAddress1: e.target.value })}
                      placeholder="住所"
                    />
                    <div className="grid grid-cols-3 gap-2">
                      <Select
                        value={detailForm.inheritanceStatus1}
                        onValueChange={(value) => setDetailForm({ ...detailForm, inheritanceStatus1: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="相続" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">相続: 有</SelectItem>
                          <SelectItem value="無">相続: 無</SelectItem>
                          <SelectItem value="未確認">相続: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                      <Select
                        value={detailForm.correctionRegistration1}
                        onValueChange={(value) => setDetailForm({ ...detailForm, correctionRegistration1: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="更正登記" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">更正登記: 有</SelectItem>
                          <SelectItem value="無">更正登記: 無</SelectItem>
                          <SelectItem value="未確認">更正登記: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                      <Select
                        value={detailForm.mortgageStatus1}
                        onValueChange={(value) => setDetailForm({ ...detailForm, mortgageStatus1: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="抵当権" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">抵当権: 有</SelectItem>
                          <SelectItem value="無">抵当権: 無</SelectItem>
                          <SelectItem value="未確認">抵当権: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                  {/* 地権者2 */}
                  <div className="p-3 border rounded-lg space-y-2">
                    <div className="text-xs font-medium text-muted-foreground">地権者2</div>
                    <Input
                      value={detailForm.landowner2}
                      onChange={(e) => setDetailForm({ ...detailForm, landowner2: e.target.value })}
                      placeholder="氏名"
                    />
                    <Input
                      value={detailForm.landownerAddress2}
                      onChange={(e) => setDetailForm({ ...detailForm, landownerAddress2: e.target.value })}
                      placeholder="住所"
                    />
                    <div className="grid grid-cols-3 gap-2">
                      <Select
                        value={detailForm.inheritanceStatus2}
                        onValueChange={(value) => setDetailForm({ ...detailForm, inheritanceStatus2: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="相続" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">相続: 有</SelectItem>
                          <SelectItem value="無">相続: 無</SelectItem>
                          <SelectItem value="未確認">相続: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                      <Select
                        value={detailForm.correctionRegistration2}
                        onValueChange={(value) => setDetailForm({ ...detailForm, correctionRegistration2: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="更正登記" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">更正登記: 有</SelectItem>
                          <SelectItem value="無">更正登記: 無</SelectItem>
                          <SelectItem value="未確認">更正登記: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                      <Select
                        value={detailForm.mortgageStatus2}
                        onValueChange={(value) => setDetailForm({ ...detailForm, mortgageStatus2: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="抵当権" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">抵当権: 有</SelectItem>
                          <SelectItem value="無">抵当権: 無</SelectItem>
                          <SelectItem value="未確認">抵当権: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                  {/* 地権者3 */}
                  <div className="p-3 border rounded-lg space-y-2">
                    <div className="text-xs font-medium text-muted-foreground">地権者3</div>
                    <Input
                      value={detailForm.landowner3}
                      onChange={(e) => setDetailForm({ ...detailForm, landowner3: e.target.value })}
                      placeholder="氏名"
                    />
                    <Input
                      value={detailForm.landownerAddress3}
                      onChange={(e) => setDetailForm({ ...detailForm, landownerAddress3: e.target.value })}
                      placeholder="住所"
                    />
                    <div className="grid grid-cols-3 gap-2">
                      <Select
                        value={detailForm.inheritanceStatus3}
                        onValueChange={(value) => setDetailForm({ ...detailForm, inheritanceStatus3: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="相続" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">相続: 有</SelectItem>
                          <SelectItem value="無">相続: 無</SelectItem>
                          <SelectItem value="未確認">相続: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                      <Select
                        value={detailForm.correctionRegistration3}
                        onValueChange={(value) => setDetailForm({ ...detailForm, correctionRegistration3: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="更正登記" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">更正登記: 有</SelectItem>
                          <SelectItem value="無">更正登記: 無</SelectItem>
                          <SelectItem value="未確認">更正登記: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                      <Select
                        value={detailForm.mortgageStatus3}
                        onValueChange={(value) => setDetailForm({ ...detailForm, mortgageStatus3: value })}
                      >
                        <SelectTrigger className="text-xs">
                          <SelectValue placeholder="抵当権" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="有">抵当権: 有</SelectItem>
                          <SelectItem value="無">抵当権: 無</SelectItem>
                          <SelectItem value="未確認">抵当権: 未確認</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                </div>
                <div className="space-y-2">
                  <Label>地目・土地の面積</Label>
                  <div className="space-y-2">
                    {/* 1つ目 */}
                    <div className="flex items-center gap-2">
                      <Select
                        value={detailForm.landCategory1}
                        onValueChange={(value) => setDetailForm({ ...detailForm, landCategory1: value })}
                      >
                        <SelectTrigger className="w-24">
                          <SelectValue placeholder="地目" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="山林">山林</SelectItem>
                          <SelectItem value="原野">原野</SelectItem>
                          <SelectItem value="畑">畑</SelectItem>
                          <SelectItem value="田">田</SelectItem>
                        </SelectContent>
                      </Select>
                      <Input
                        type="number"
                        step="0.01"
                        value={detailForm.landArea1}
                        onChange={(e) => setDetailForm({ ...detailForm, landArea1: e.target.value })}
                        placeholder="面積（㎡）"
                        className="flex-1"
                      />
                    </div>
                    {/* 2つ目 */}
                    <div className="flex items-center gap-2">
                      <Select
                        value={detailForm.landCategory2}
                        onValueChange={(value) => setDetailForm({ ...detailForm, landCategory2: value })}
                      >
                        <SelectTrigger className="w-24">
                          <SelectValue placeholder="地目" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="山林">山林</SelectItem>
                          <SelectItem value="原野">原野</SelectItem>
                          <SelectItem value="畑">畑</SelectItem>
                          <SelectItem value="田">田</SelectItem>
                        </SelectContent>
                      </Select>
                      <Input
                        type="number"
                        step="0.01"
                        value={detailForm.landArea2}
                        onChange={(e) => setDetailForm({ ...detailForm, landArea2: e.target.value })}
                        placeholder="面積（㎡）"
                        className="flex-1"
                      />
                    </div>
                    {/* 3つ目 */}
                    <div className="flex items-center gap-2">
                      <Select
                        value={detailForm.landCategory3}
                        onValueChange={(value) => setDetailForm({ ...detailForm, landCategory3: value })}
                      >
                        <SelectTrigger className="w-24">
                          <SelectValue placeholder="地目" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="山林">山林</SelectItem>
                          <SelectItem value="原野">原野</SelectItem>
                          <SelectItem value="畑">畑</SelectItem>
                          <SelectItem value="田">田</SelectItem>
                        </SelectContent>
                      </Select>
                      <Input
                        type="number"
                        step="0.01"
                        value={detailForm.landArea3}
                        onChange={(e) => setDetailForm({ ...detailForm, landArea3: e.target.value })}
                        placeholder="面積（㎡）"
                        className="flex-1"
                      />
                    </div>
                    {/* 合計 */}
                    <div className="flex justify-end items-center gap-2 pt-1 border-t">
                      <span className="text-sm">合計:</span>
                      <span className="font-medium">
                        {calculateTotalArea(detailForm.landArea1, detailForm.landArea2, detailForm.landArea3)} ㎡
                      </span>
                    </div>
                  </div>
                </div>
                {/* 環境データ */}
                <div className="space-y-2">
                  <Label>環境データ</Label>
                  <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-1">
                      <Label htmlFor="verticalSnowLoad" className="text-xs text-muted-foreground">垂直積雪量</Label>
                      <Input
                        id="verticalSnowLoad"
                        value={detailForm.verticalSnowLoad}
                        onChange={(e) => setDetailForm({ ...detailForm, verticalSnowLoad: e.target.value })}
                        placeholder="例: 30cm"
                      />
                    </div>
                    <div className="space-y-1">
                      <Label htmlFor="windSpeed" className="text-xs text-muted-foreground">風速</Label>
                      <Input
                        id="windSpeed"
                        value={detailForm.windSpeed}
                        onChange={(e) => setDetailForm({ ...detailForm, windSpeed: e.target.value })}
                        placeholder="例: 34m/s"
                      />
                    </div>
                  </div>
                </div>
                {/* どこキャビ連携 */}
                <div className="space-y-2">
                  <Label htmlFor="dococabiLink">どこキャビ連携URL</Label>
                  <Input
                    id="dococabiLink"
                    value={detailForm.dococabiLink}
                    onChange={(e) => setDetailForm({ ...detailForm, dococabiLink: e.target.value })}
                    placeholder="https://..."
                  />
                </div>
                <div className="flex justify-end gap-2">
                  <Button type="button" variant="outline" onClick={() => setDetailEditOpen(false)}>
                    キャンセル
                  </Button>
                  <Button type="submit">
                    保存
                  </Button>
                </div>
              </form>
            </DialogContent>
          </Dialog>

          {/* コメント編集ダイアログ */}
          <Dialog open={commentEditOpen} onOpenChange={setCommentEditOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>コメントを編集</DialogTitle>
              </DialogHeader>
              <form onSubmit={handleCommentEditSubmit} className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="edit-comment-content">内容</Label>
                  <Textarea
                    id="edit-comment-content"
                    value={editCommentContent}
                    onChange={(e) => setEditCommentContent(e.target.value)}
                    rows={3}
                  />
                </div>
                <div className="flex justify-end gap-2">
                  <Button type="button" variant="outline" onClick={() => setCommentEditOpen(false)}>
                    キャンセル
                  </Button>
                  <Button type="submit" disabled={!editCommentContent.trim()}>
                    保存
                  </Button>
                </div>
              </form>
            </DialogContent>
          </Dialog>

          {/* コメント削除確認ダイアログ */}
          <AlertDialog open={commentDeleteOpen} onOpenChange={setCommentDeleteOpen}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>コメントを削除</AlertDialogTitle>
                <AlertDialogDescription>
                  このコメントを削除しますか？
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>キャンセル</AlertDialogCancel>
                <AlertDialogAction
                  onClick={handleCommentDelete}
                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                >
                  削除
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>

          {/* TODO削除確認ダイアログ */}
          <AlertDialog open={todoDeleteOpen} onOpenChange={setTodoDeleteOpen}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>TODOを削除</AlertDialogTitle>
                <AlertDialogDescription>
                  このTODOを削除しますか？
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>キャンセル</AlertDialogCancel>
                <AlertDialogAction
                  onClick={() => {
                    if (deletingTodo) {
                      handleTodoDelete(deletingTodo.id);
                    }
                    setTodoDeleteOpen(false);
                    setDeletingTodo(null);
                  }}
                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                >
                  削除
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>

          {/* TODO完了ダイアログ */}
          <Dialog open={todoCompleteOpen} onOpenChange={setTodoCompleteOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>TODOを完了</DialogTitle>
                <p className="text-sm text-muted-foreground">
                  完了メモを残すことができます（任意）
                </p>
              </DialogHeader>
              {completingTodo && (
                <form onSubmit={handleTodoCompleteSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="complete-todo-memo">完了メモ</Label>
                    <Textarea
                      id="complete-todo-memo"
                      value={completeTodoMemo}
                      onChange={(e) => setCompleteTodoMemo(e.target.value)}
                      placeholder="完了時のメモを入力..."
                      rows={3}
                      className="resize-y"
                    />
                  </div>
                  <div className="flex justify-end gap-2">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => setTodoCompleteOpen(false)}
                    >
                      キャンセル
                    </Button>
                    <Button type="submit">
                      <CheckCircle2 className="h-4 w-4 mr-2" />
                      完了する
                    </Button>
                  </div>
                </form>
              )}
            </DialogContent>
          </Dialog>

          {/* TODOメッセージ追加ダイアログ */}
          <Dialog open={todoAddMessageOpen} onOpenChange={setTodoAddMessageOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>メッセージを追加</DialogTitle>
                <p className="text-sm text-muted-foreground">
                  完了済みTODOにメッセージを追加します
                </p>
              </DialogHeader>
              {addingMessageTodo && (
                <form onSubmit={handleAddMessageSubmit} className="space-y-4">
                  {/* 既存メッセージの表示 */}
                  {addingMessageTodo.completedMemo && (
                    <div className="space-y-1 max-h-40 overflow-y-auto">
                      <Label className="text-xs text-muted-foreground">既存のメッセージ</Label>
                      {parseTodoMessages(addingMessageTodo.completedMemo).map((msg, idx) => (
                        <div key={idx} className="text-xs p-2 rounded bg-muted/50 border border-border/50">
                          <p>{msg.message}</p>
                          <p className="text-[10px] text-muted-foreground/70 mt-0.5">
                            {formatDateJp(new Date(msg.createdAt))}
                          </p>
                        </div>
                      ))}
                    </div>
                  )}
                  <div className="space-y-2">
                    <Label htmlFor="new-todo-message">新しいメッセージ</Label>
                    <Textarea
                      id="new-todo-message"
                      value={newTodoMessage}
                      onChange={(e) => setNewTodoMessage(e.target.value)}
                      placeholder="メッセージを入力..."
                      rows={3}
                      className="resize-y"
                    />
                  </div>
                  <div className="flex justify-end gap-2">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => setTodoAddMessageOpen(false)}
                    >
                      キャンセル
                    </Button>
                    <Button type="submit" disabled={!newTodoMessage.trim()}>
                      <Plus className="h-4 w-4 mr-2" />
                      追加
                    </Button>
                  </div>
                </form>
              )}
            </DialogContent>
          </Dialog>

          {/* TODO編集ダイアログ */}
          <Dialog open={todoEditOpen} onOpenChange={setTodoEditOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>TODOを編集</DialogTitle>
              </DialogHeader>
              {editingTodo && (
                <form onSubmit={handleTodoEditSubmit} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="edit-todo-content">内容</Label>
                    <Textarea
                      id="edit-todo-content"
                      value={editTodoContent}
                      onChange={(e) => setEditTodoContent(e.target.value)}
                      placeholder="この日までに行うことを入力..."
                      rows={3}
                      className="resize-y"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label>期日</Label>
                    <Popover open={editTodoCalendarOpen} onOpenChange={setEditTodoCalendarOpen}>
                      <PopoverTrigger asChild>
                        <Button
                          type="button"
                          variant="outline"
                          className={cn(
                            "w-full justify-start text-left font-normal",
                            !editTodoSelectedDate && "text-muted-foreground"
                          )}
                        >
                          <CalendarIcon className="mr-2 h-4 w-4" />
                          {editTodoSelectedDate
                            ? formatDateJp(editTodoSelectedDate)
                            : "期日を選択"}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={editTodoSelectedDate}
                          onSelect={(date) => {
                            setEditTodoSelectedDate(date);
                            if (date) {
                              const y = date.getFullYear();
                              const m = String(date.getMonth() + 1).padStart(2, "0");
                              const d = String(date.getDate()).padStart(2, "0");
                              setEditTodoDueDate(`${y}-${m}-${d}`);
                              setEditTodoCalendarOpen(false);
                            }
                          }}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                  </div>
                  <div className="flex justify-end gap-2">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => setTodoEditOpen(false)}
                    >
                      キャンセル
                    </Button>
                    <Button type="submit" disabled={!editTodoContent.trim() || !editTodoDueDate}>
                      保存
                    </Button>
                  </div>
                </form>
              )}
            </DialogContent>
          </Dialog>

        </div>
      </div>
    </div>
  );
}
</file>

</files>
